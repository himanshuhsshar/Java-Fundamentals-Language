Course Overview
Course Overview
Hi everyone. My name is Jim Wilson. Welcome to my course, Java Fundamentals: The Java Language. I'm president of JW Hedgehog Incorporated, and I've had the good fortune to have been a professional software developer now for more than 30 years. Did you know that Java is the most sought after programming language skill among software developers? Java is supported on everything from smartphones to servers to many of the special‑purpose devices that make up the Internet of Things. In addition to being important to software developers, a recent survey listed Java as one of the five most important skills for data scientists, those folks who work their way through all of that big data. In this course, we're going to teach you everything you need to know to get started working in the Java programming language. Some of the major topics we'll cover include setting up your Java development environment, language constructs and control flow, classes, class inheritance, and interfaces, exceptions and error handling, creating and using Java packages. By the end of this course, you'll be ready to begin working in any of the many environments that rely on the Java programming language. This is a beginner course, and therefore makes no assumptions on prior programming experience. I hope you'll join me as we learn Java programming with the course, Java Fundamentals: The Java Language, at Pluralsight.

Introduction and Setting up Your Environment
Introduction
Welcome to the Pluralsight course, Java Fundamentals: The Java Language. This is our first module, Introduction and Setting Up Your Environment. My name is Jim Wilson.

What to Expect in This Course
Our focus throughout this whole course is really to give you a strong foundation in the Java language to teach you what you need to work effectively with the Java programming language. We're going to do that as a very hands‑on approach. We're going to be writing lots of code as we go through and seeing what happens when we write and change that code. And our focus here really is on this, again, the idea of the language, the Java syntax, the language constructs, the concepts, and how to use all those things together to program effectively. And what we're really trying to do here is give you the language skills you need to work effectively in any Java‑based environment. The topics we cover here are useful in traditional Java, what's often called Java Standard Edition, but also when working in enterprise‑level applications, even Java smart client applications. Alright, and that carries on even down to small devices with Java Micro Edition and Android. And so we've really got that whole thing covered. And the thing that's interesting to note is that, you know, even though Android is really kind of the most popular phone platform that uses Java, that doesn't mean Java Micro Edition isn't important, right? Although Java Micro Edition is not a big part of phones anymore, it still plays a really important role in smart devices and the Internet of Things. Alright, so understanding Java programming language really gives you what you need to work across all levels of computers, from desktops, all way down to small devices, all the way back up to great big servers.

What to Expect in This Module
The goal of this first module is to give us the information we need to start working with and learning the Java programming language. So first thing we'll look at is just take a brief overview of what Java is, what one the parts of it, what it's made up of. Then we're going to talk about the JRE versus the JDK, two terms people throw around pretty freely in a Java world. We want to understand what those are and what they mean. We're going to look at the details of actually setting up your Java development environment. And then looking at your Java integrated development environment, the tools we use to build Java programs. And we're not going to kind of endorse or focus on any Java, or any specific Java IDE in this course, we just want to talk about what the options are out there and help you to choose which one is right for you.

What Is Java
The first thing we need to understand to get started is exactly what is Java? When someone says Java, what are they talking about? Well, Java is a programming language, but Java is also a runtime environment. It's actually both of those things. So when we think about the programming language, it has things like the syntax, the data types, control flow, like looping and conditional statements and being object‑oriented, right, doing inheritance, and so forth. And then runtime, of course, has to support those things, but it also provides things like configuration, security, a threading model,, input/output, that sort of thing. So when someone says Java, they could be referring to a programming language or the runtime environment or the whole thing. Now in general, the runtime environment someone is talking about when they just say Java is often referred to as Java Standard Edition. Right, that's kind of the basic Java environment. But it also provides other environments that derive from that, Enterprise Edition, Java Micro Edition, and Java FX. So those are all either supersets or subsets of this main thing, which is just the Java Standard Edition. But the thing that's neat about Java, it's so flexible that there are even run times that are not tied to the Java one produced by Oracle. Right, Android is kind of most well known one. Android provides a very different runtime than the standard Java run times from Oracle. The thing is, though, that all those environments support effectively the same Java programming language, right. So that one language equips us the work in all those different places.

JRE vs. JDK
The JRE and the JDK are two terms you hear people mention very frequently in the Java world, and what they are are the two parts that we need in order to run and create Java applications. The JRE is the Java Runtime Environment. JDK is the Java Development Kit. And so the JRE is what you require in order to run Java applications, and end users normally install the JRE. They're the ones who are going to run our apps. The JDK provides the tools that we need to create Java apps. So, normally, developers are the ones who install the JDK on their machines. And in order to develop apps, you need to run them, so the JDK installation includes a JRE. So how does all this work together? If we sit down, and we type up a Java source file with our program code inside of it, and we want to go ahead and run that in some host environment, how do we do it? A host environment might be Windows, Linux. It could be Mac. It could even be a browser. It might be a phone running Android. How do we get from that source code we've typed up to something that can actually run on that other computer? Well, that's where the Java Development Kit comes in. Using the Java Development Kit, we can feed our source code into it, and it will produce our Java application. Now Java's not like a low‑level language like C. C, when you compile a C program, it produces an application that can run directly on the host computer. Java uses an abstraction called byte codes that's platform independent. It allows us to not be tied to a particular host environment, but actually we have something that can be run in different host environments. And that's where the Java Runtime Environment comes in. The Java Runtime Environment provides what we need in order for our Java app to display codes that execute in any host environment. So that's why end users install the Java Runtime Environment because they just need to run that code. We, as developers, install the JDK to give us the tools to produce that application.

Demo: Setting up the JDK
Let's go ahead and install the JDK onto our machine. Now that URL I have on screen, the bit.ly/psjdkdownload, is set to point to whatever the current version of the JDK is. As I'm recording this, the current version is JDK 8, so that's the one I'll install. If you watch this course into the future and another version of JDK 9 or 10 comes out, that same URL you see will take you to the appropriate place to download that current version. So here we are in our browser. So let's go ahead and put in that URL. We'll hit Enter. And so here we are at the current download page, or I should say here we are at the page where you can get the current Java downloads. You'll notice here on the left we've got one here for the JDK, also called the Java Platform, so we'll go ahead click on that. Here we are on the JDK download page. So go ahead and scroll down here a little bit until you see that here's all the various versions we can download. And basically you just download the version for whatever platform you're using. If you're on Linux you can get that one, of course. If I was on my Mac right now, I'd get to Mac one. But in this case I'm currently on a 64‑bit Windows machine, so I want to install that version, Windows 64. One thing you want to make sure you remember to do is accept this license. If you don't accept the license, it won't allow you to do the download. So when we're ready, we'll just going ahead and click on this to download the file. So my download is completed, so I'm going to go ahead and just run the installer. So I'm just going to go ahead and double‑click on this guy. And now here we are inside the installer. So I'm just going to go ahead and let the installer get started here, go ahead and say yep, go ahead and install everything. And you'll notice that one of the things it has here is that the JRE, the Java Runtime, so it actually puts that in there for us. So we're going to say yep, go ahead and do that. And notice down here it prompts us again for a destination folder, because again, this is the folder where the Java Runtime is going to go. I'm going to go ahead and just accept the default for that. So I'll say Next. And with that, we're done. We now have the JDK along with the JRE installed on our computer.

Integrated Development Environments (IDE)
If you wanted to, you could build your Java applications having only installed the JDK. You could use some arbitrary text editor to type in your program code, and then you could use command line tools to do all the compiling and executing of your programs, and that would work fine, and people did that for years, and some people still do that, but in general when we're developing, we want to use a more productive model than that. We like these things called integrated development environments that allow us to type in our code, compile it, debug it, everything all in one place. Now Java has lots and lots of IDEs available, and two of those you'll most commonly hear about are NetBeans and IntelliJ, both of which are available for free. For many years, NetBeans was maintained by the Oracle Corporation, and when Oracle was maintaining it, it was the official IDE for Java development. But Oracle support for NetBeans stopped as of JDK 8, so if you're working with an older version of the JDK, you can get NetBeans directly from Oracle, but for a version of NetBeans that supports JDKs newer than JDK 8, we need to go out to the Apache organization. Now the version of NetBeans supported by the Apache organization only supports Java SE officially. The other thing you might find is that when working with the version of NetBeans distributed by Apache, depending on the version of the JDK you're using, you may need to go out and make manual changes to the configuration files. Because of this, sometimes NetBeans can make it challenging for beginners to get started. Another very popular IDE for Java is IntelliJ. I really like IntelliJ, it's my preferred Java environment. Now the IntelliJ Community Edition is a free version of a commercial product, and so a company called JetBrains actually builds and sells a full‑blown installation of IntelliJ, but they make this Community Edition available to us for free. And what I like about it is that the Community Edition supports Java Standard Edition and Android, alright, so you can use one IDE for both of those environments, which I find really convenient. If you were to decide to go ahead and go with the commercial version of IntelliJ, you would pick up additional features. There's some other development features, it supports Java EE, does some cool server debugging stuff, but you don't have to go to the commercial version. The Community Edition is quite substantial and certainly is good enough for everything we do in this course, and you'll find that most things you're likely to want to do are supported in the Community Edition.

NetBeans IDE
As I mentioned, NetBeans is now distributed by the Apache organization, so if you want to download NetBeans, you'll find it at netbeans.apache.org. Now NetBeans is still a good IDE. But since NetBeans is no longer maintained directly by Oracle, you'll find that the releases of NetBeans are not as closely synced with the releases of the JDK as it once was. For this reason, sometimes working with NetBeans can make getting started difficult for beginners. So as a beginner, unless you have a really compelling reason to use NetBeans, I'd encourage you to instead consider using IntelliJ. IntelliJ is far and away one of the most popular IDEs used for Java. We'll talk about IntelliJ in our next clip. And we'll be using it throughout this course.

Demo: Setting up IntelliJ IDEA Community Edition
Let's walk through installing the IntelliJ Community Edition. The URL on screen there, the bitly URL, will take you to whatever the current version of IntelliJ is. Currently that happens to be 14.1, but even as the versions evolve, that URL should still remain valid. Here we are in our browser, so let's go ahead and put that URL in and get to the IntelliJ page. I'll hit Enter, and we'll just scroll down a little bit here so you can see where we're at. And you see this one page has got both the commercial edition and the community edition. We want to make sure we go ahead and download the Community Edition, so we'll go ahead and just click on the Download button here. Once the download is complete, we can just go ahead and run the installer. So we'll just step through this now, so I'll click Next. I'm going to go ahead and accept the default installation folder. Now, I'm going to go ahead and create a desktop shortcut to make it a little easier to find. And also I've got these associations, so I'm going to go ahead and associate with .java so that way if I just double‑click on any .java file, it'll automatically open it up inside of IntelliJ. Click Next. I'm going to keep all the defaults here on the groups, and now it's off and installing. So my installation is complete, so I'm going to go ahead here and just click this box that says go ahead and run IntelliJ when I exit, so I'll click Finish. I'm going to tell it to not worry about importing any previous settings, so I'm just going to say OK. Now the first time you run it, it wants to ask you how do you want to set it up, do you want to customize its appearance and everything, I'm going to say just skip all that and just set the defaults. And you can see now I'm at the starting window, so we now know we have IntelliJ installed as well. And, again, in the next module we'll actually start using this and building some code with it, but we now know we have a successful install.

Summary
To wrap up, the key thing to remember here is that when we talk about Java, Java actually comes as both a language and a runtime environment, and there may be some variations in those individual runtime environments. But the cool thing is that the language remains pretty consistent. So by knowing the Java language well, you've got the ability to work across a very wide range of platforms. Now in terms of installations, end users only require the JRE, that Java Runtime Environment. As developers, we want the JDK as well. Now remember that the JDK cancellation installs the JRE for you so you can go ahead and run those applications that you're creating. And although the JDK is all we actually need to create our applications, we probably want to use an IDE of some sort. And there's a whole bunch of ones out there. Again, you pick the one that you like best. Of the two I showed you, one is NetBeans, which is the one that Oracle provides. The other one I showed you, IntelliJ, is, again, very popular as well, and there's no magic to it. it really comes down to you just pick the one that you like best. And with that, we have everything we need to set up our environments. So in the next module, we'll start coding.

Creating a Simple App
Introduction
Welcome to this module on Creating a Simple App. My name is Jim Wilson. In this module, first we're going to look at creating your very first IntelliJ project. In other words, how do we create a simple application using IntelliJ? We'll then look at running our Java programs from the command line. We'll take a look at the syntax of Java statements and comments. We'll introduce the concept of Java packages. And then we'll walk through creating and running a project using the NetBeans IDE.

Demo: Creating Your First IntelliJ Project
Let's go ahead now and create our very first Java project, and we'll go ahead and just use the IntelliJ IDEA to do this one. I have a shortcut to IntelliJ on my desktop, so let's go ahead and just double‑click that guy to start up. So once IntelliJ starts up here, it takes me to this initial window. What I want to do is just create a new project. So click on that. Now it takes me into the wizard to create the project. Now one of the first things we have to do is, of course, choose if we want to have a Java project because, remember, IntelliJ works for a variety of things. And then we also have to associate the JDK version we want to use. Now you only have to do this step once, but what we have to do here is that where it says Project SDK, and you'll notice that there are none now, there's none to choose, so what we're going to do is just click on this New button here on the right. We're going to choose to set up a Project SDK, which is the JDK. And what we're going to do now is just navigate to where we installed the JDK. So for me in here, it's on Program Files, scroll down, Java, and then make sure you choose JDK, not the JRE. You want the JDK. Say OK. And now that we've done that, we can now create projects with that JDK. So now one thing that's just a little bit of a challenge is that this wizard screen doesn't render well on the resolution that we record at. So I'm just going to pull this up here just a little bit. Notice that the button's across the bottom. So what I'm going to do is click the Next button to move on to the next step of the wizard. So I'll click on the Next button. So now it says, What template do you want to use, or do you want to use a template at all? We're going to say, Yeah, go ahead and create it from a template. And what that does is just creates some initial file layouts for us, sets things up so we can kind of get started easily. And we're just going to create a regular command line application, which is just the most basic kind of Java application. If I pull this dialog up, again, we're going to click that Next button down there at the bottom. So now we'll go ahead and we'll want to name things. So, kind of in the life‑long tradition of programming and programming courses, we're going to create a Hello world app. Let's just go ahead and call this project name HelloWorld. So I've named the product HelloWorld. I'm going to go ahead here where it says base package, I'm going to go ahead and delete that away for now. We'll come back to that a little bit later. And I'm just specifying where I want it to go. So I'm just going to put into a folder under my demo folder for this module called HelloWorld. I'll pull this guy up. Notice down here at the bottom now, there's actually a Finish button. So that's what I'm going to select this time is the Finish button. So as it starts up, it brings me into the project. One of the features of IntelliJ is that it actually has kind of the tip of the day, just kind of to show you different facts about working in their environment and so forth. I'm going to close that up. You notice here it's generated a source code file for me. On the left here, I've got my Project Explorer. It just shows me kind of the hierarchy of the files it's created. If I expand HelloWorld and this src folder here, there's the Main. That's the class file that goes with the class I've created. I'm going to talk a whole bunch more about classes later in the course. This basically just becomes the start of our application. Now IntelliJ always creates this initial class as class name Main. That class name doesn't actually matter. We'll talk a lot more about class names a little bit later. What does matter is inside here, there's what's called a method. That's where our code actually runs. And for Java applications, the startup of your application must be in a class that has a member called Main that looks just like this. So it has to be public, I mean, just publicly accessible. We'll talk more about that modifier later. The modifier static void has to be called main and has to look just like this. So whenever you run your code in Java, it's going to look for this as an entry point. So I'm just going to delete this line away here, and we'll do the classic Hello world application. So I'm going to use an object here, or a type called System, and I'm going to use something called out and println. And this is just the mechanism in Java we use to print things out to the console. And we're going to say Hello World. So we have that there. So this is kind of the most fundamental application we can build. Now, the way we run this in IntelliJ is that we go up here to the Run menu, click on that, and we choose Run. When we do that, we'll see that IntelliJ will go ahead and compile our code for us, and then down here at the bottom, it shows a console window and actually shows the output of our application. So in this case, it says Hello World. Now our focus here is on Java and not on the development environment, but just to show you a couple things that makes it easier. We saw how to run it from the menu. Once we have this window down here, if we say we want to change something, like I'll say Hello World, we'll just say Again, if I want a go ahead and rerun the code, I can go down here on the bottom where I have this little green arrow, click on that, and it will just run the code over again, compile it and run it for us. And now we see Hello World Again. So we've successfully run our very first Java Hello World program.

Demo: Running from the Command Line
Let's walk through a demo now of running our program from the command line. In other words, what we want to do is look at how we can run our program without having to use a developer tool like IntelliJ to do it. In the previous demo when we wrote our application, where we did all the work here inside of a developer tool, in this case IntelliJ, and that did our compiling and even that ran it for us. Now as developers, we have that tool, but how will end users run a program, or how does an end user execute the program without having one of these developer tools? And that's what we look at now. Now the thing we want to remember is that the main class for our application here is called Main. It didn't have to be, but that's what it's called here, and we're going to have to remember that when it becomes time to run our program. Now remember that we say that end users have to install the JRE, the Java Runtime Environment, and let's take a look in there for a second. Here I am on the C drive of my windows computer, and what I want to do is get onto here to Program Files. And inside there's a folder called Java, and inside there, that's the JRE. That's the execution environment the Java Runtime Environment. We said that that's what actually runs our programs. Java programs don't run directly. They run within the Java environment. If I go inside of this folder, you see there's another folder called bin, and you'll notice inside of here, if I scroll down a little bit, there's actually a program called java. That Java program is what actually runs our program. All right now, if you're on Linux or Mac, you can basically use that Java program directly. If your're on Windows, you want to make sure that it's actually in your path so that you can actually type just the word java and it'll find it in this folder. So what we want to do is keep track of this location where we found the java.exe, so we're going to just copy this. And again, what we do is, we want to put that into the path of our machine. So what I've got over here is Control Panel. So I'm going to go ahead and open up the Control Panel, and here in Control Panel I'm going to find the System entry. Open that guy up. And what I want to do is go to Advanced system settings, and from here, I want to go to Environment Variables. And what I want to do here is, I want to go ahead and add that to my path. All right, so I'm going to add it my my user path. Now I happen to have no current user path set up. On your machine you may already have an entry in here that says Path. If you have an existing one, you're going to highlight it and say Edit. I want to create a new one because I don't have Path yet. So I'm going to call it Path, and what I'm going to do is paste in that location where the java.exe was. And when I say OK, now we see Path listed here. All right, so to just kind of clarify it, when you opened Environment Variables, if you already saw Path, you would highlight it and click Edit. Because I didn't have it already, I clicked New. All right, so we're going to say OK and OK, and close these guys up. And so now I have the folder where my Java program's located in my path so I can just type it from the command line. So now what we want to do is run our program. So what I want to do now is go to the folder where I created our applications project. So when I created our applications project I created it in this Demo folder, and remember I called it project HelloWorld. All right, so I go here into HelloWorld. You see a series of folders. Now, the exact layout of these folders is specific to the way IntelliJ does it, but in any environment you're using, you're going to see something similar to this. So what we want to do here is go to our out folder. And again, the name out is specific to IntelliJ. Whatever tool you're using will have something like that. And so we go to out, and we'll and see production is another folder inside there. And then inside of here we see HelloWorld. If I go inside of there, we can see, in this case, our class file. This HelloWorld folder under out and production is the result of compiling our program. And again, the names out and production are specific to IntelliJ. But whatever environment you're working from, you'll have some folder structure like that. The key is, we want to have wherever the output was placed, which is our HelloWorld. All right, now that we're here, we can actually open up a command line and run our program. So what I'm going to do is, I'm just going to jump here, just type cmd to open up a command prompt in this location. So I've got a command prompt here, and what I'm going to do is just type java ‑version. And we notice there it outputs that it gives me the version number of Java, and basically, what this really tells me is that my Java command's working. If that doesn't work for you, if you get something like command not found or you get a version different than the one you were expecting, what you may have to do is just log out and log back in, because user‑level environment variables don't take effect right away. All right, so if you get, again, if you get like program not found when you type java, just log out and log back in. It should then work when you open your next command prompt. If it doesn't, just go back and make sure you've got your path setting to the right location to where that java.exe was located. So now we'll run our program. What we're going to do is say java, and what we want to do is give it the class name that actually had that main entry point in it. And remember that in our case, our class name was actually Main. So I'm just going to go and hit Enter, and then we see HelloWorld again. All right, so we see that we actually successfully ran our program without having to use any fancy IDE. This is how it would run in an end user environment. They would have your class file, the thing we produced when we built the program, and just using the java command, goes ahead and launches it.

Statement Structure and Whitespace
Java programs are made up of statements. Now, a lot of different things can go on in a particular statement, and we'll talk about those things throughout this course, but fundamentally, programs are made with statements. Now each statement ends with a semicolon. Java is a language where the newline and the Enter key doesn't really create a new statement. It actually relies instead on the semicolon. If you're going from any of the C‑based languages, that's something you're very familiar with. Other languages like Visual Basic actually use the end of line to mark a statement. In Java, it's the semicolon. And the parts of a statement can be separated by zero or more whitespaces, and a whitespace could be many different things. It can be the space character, it can be a tab. And because statements don't end with newline, even the newline itself is just a whitespace in Java. Java's a language that gives us a lot of flexibility with whitespaces, so remember we said that the parts could be separated by zero or more whitespaces, so it allows us to format things in a way that works well for us. So I can have a statement like this where all the parts are pushed all together with no whitespaces between them, but then I can have this same statement where I just put a space after the println, a space after the parenthesis, a space before the other parenthesis. It'll do the exact same thing. I can put multiple spaces in there, and that still does the exact same thing. Now remember that because the newline is considered a whitespace, I can even format it like this. This is kind of a crazy way to format it, and I wouldn't suggest you do this, but it's all just whitespace. So after that println, we've got a newline, followed by a bunch of the space characters. That's fine. Right after that parenthesis, we've got a newline again. After Hello World, we've got a newline, another newline, then a whole bunch of whitespaces or a whole bunch of space characters. And so it just shows us that the whitespace allows us to indent, format, put line breaks in a way that works well for us. The whitespaces are just separators, and it's that semicolon that marks the end of a statement.

Comments
Java, like most programming languages, has the ability to include comments. All right, and comments are just basically text inside of your source code that the compiler doesn't see. Right, and there are really kind of just two general uses for comments. One is that it allows you to add human readable notes to your source code, right, it allows you to type things in the source code so that when you look at it later, or someone else looks at it, it's just leaving notes to understand what you were doing there. It's also useful for hiding source cool without deleting it. Maybe you're testing things out, so you want to just kind of take some things away and type some new stuff, or if there's something you don't want to anymore, but you think you want to do it again in the future, so comments allow you to take that stuff out so the content is in your source code, but the compiler doesn't compile it. There are three types of comments in Java. One, which is called line comments, and if you basically just put a double slash, basically the compiler ignores everything until the end of the line, and when I said by the end of the line. it's actually until you hit the Enter Key, the new line character. It's not like other statements where it relies on the semicolon, right. So the compiler just skips everything until the next new line. Then what are called block comments where you use a slash star to begin the comment and a star slash to end it. So the compiler skips everything between those notations. They can be happened in the middle of a line or they can span multiple lines. And the last kind is a special kind of comment called a JavaDoc comment, which starts out slash star star and then ends star slash. There's a utility called JavaDoc that allows you to generate documentation using this special comment format. It allows you basically to write your code documentation right inside of your source code, and then when you run the JavaDoc utility, if you follow the appropriate structure in your comments, that utility will generate documentation right from the source code. The details of JavaDoc are outside the scope of this course, but I've got that you URL up there on the screen for you, if you want to dig into JavaDoc and learn more about it.

Demo: Comments
Let's take a quick look now using comments in our code. Here I am back in the program we wrote earlier, and let's do, let's just take this line we wrote out Hello World Again, and let's copy that and put it back in a couple more times. Just say Hello World One, Two, and Three. And if go ahead and run our program down here, we'll see that all three of those lines get written out, right, Hello World One, Two, and Three. So using comments, right, we can add information into our source code. So first, I'll use a line comment, so I'll just do a slash slash, say this is a comment, and this comment only exists until I get to the new line, right. You'll notice that even the IDE is using a different color text to make the comments stand out. All right, but if I run this, it's had no impact on what my program does. All right, it still says Hello World One, Two, and Three. But if I go down to the next line here and I put a double slash in front of that, that line is now ignored by the compiler, right. So if I go ahead and run this, I get Hello World One, Hello World Three, right. So it allows us, again, to just kind of have this comment that only exists for a single line. And, of course, these comments can also be on a line by themselves. If I add a line here, and I just type something like this is a standalone comment. I'm going to go ahead and run this guy again. All right, no change in the output, right. Because, again, the comment lasts until the end of the line. Right, now blocked comments actually have distinct starting and ending points. So before this method here, if I put a slash star, that comment exists until the star slash. Right, so I can say this is the first line of a comment. And I can even add another line, say, this is the second line of a comment. Right, I can have as many of these lines here as I want to, because a comment doesn't end until it gets to the star slash. Using that same technique, block comments can start and end in the middle of the same line. Right, so if I wanted to just change this text here, but not delete it, so I do a slash star, and I put a star slash at the end, and now I put in here, This is different text. Everything between the slash star star slash is ignored. But then once we hit the end of the block comment, the compiler looks at it again. Or I should say, the compiler sees the text again. All right, so if I go over and I run this now, I get my Hello World One, but then I get the, This is different text. And so the really key thing there is that the slash slash comment just exists until the very end of the line. The block comments have distinct starting and ending points. One thing to be aware of in block comments is that you cannot nest them. So I've got a block comment here at the top, with this is the first line of the comment, this is second line of the comment. If I put a slash star in here, you notice that at that second star slash, the one at the bottom now shows up as an error because the compiler doesn't have a distinct idea of for every starting block comment there is an ending block. Basically, as soon as it sees the very first encounter of star slash, all the comments are ended, so you cannot nest block comments. Now it is okay to put line comments instead of a block comment. So if I put a slash slash line comment in here, all right, that's not an error. Now you wouldn't intentionally do that, really, because you're already in a comment block, so why put a line comment in there? But if you happen to have an existing line comment and you wrap it in a block comment, that's still safe. The bottom line here is that comments allow us to put text inside of our source code that we don't want to be seen by the compiler. Right, whether it's notes to to ourselves or another human being, or we just want certain source code to be ignored for some period of time.

Introducing Packages
Let's talk briefly about Java packages. Now packages are a very important concept in Java, and we can actually talk a great deal more about them later. We have a whole module dedicated to them. I want to look at just a couple of simple things about packages right now to get us started. Now, if we look at our source code, all the source code we've written up until now has just kind of our class definitions, and that's kind of by itself. But if you look at most Java source code out there, you'll see that at the top of the source code files is the word package, followed by some name, and what this does when we add this package concept is it provides organization within a Java program. Now, again, there're a lot of aspects of that, but I want to look at just kind of two basic aspects of it to get us started. One is that these package names follow a standard naming convention, and they actually affect our source code file structure. Now in terms of the naming convention, one very simple rule is that package names are all lowercase. That's just a convention. The compiler would actually allow it not to be a lowercase, but that is the convention that package names are all lowercase, and one of the things that we're trying to do with package names is create a sense of uniqueness. So one aspect of uniqueness is on a global scale, throughout the entire world. So in order to assure package name uniqueness on a global scale, what we generally do is use the reversed domain name. So for an example of that, Pluralsight owns pluralsight.com. There's actually an authority out there that makes sure that no one else buys the name pluralsight.com. So what we do is that we start off our package names using a domain name. So any package created by Pluralsight would actually use the name com.pluralsight. Again, it's reversed. So the top level of it's com and then pluralsight, so that now assures that as long as everything we do at Pluralsight starts with that naming structure, no one else will name a package like that. And, again, there's nothing that enforces this rule. It's just a convention that we all follow to keep things from colliding with one another. And then what we want to do is that we add further qualifiers beyond that to assure uniqueness within an organization in the case of a company or some group. If we're creating packages that belong to com.pluralsight, each of our individual packages would have another part to it that just identifies some project. So, in this case, it's myproject. And that's kind of the simplest way to assure uniqueness, that each project can have its own kind of last node part to that or last part of the package name, and it stays unique. As organizations get larger, you may have to get a little bit more sophisticated about your package names because if you have multiple development groups within an organization, if you only have these three parts, the top level, com.pluralsight, and then that last part, all the groups would have to coordinate to make sure they didn't collide with one another. So what often happens is that as you get into larger organizations, you'll add another standardized part to it. So maybe you have com.pluralsight, but if Pluralsight had their own development group for the accounting department, you might agree that, well, everything created by the development group in the accounting department is com.pluralsight.accounting. And then say if there was another group instead of Pluralsight and say that was the group that took care of course management that was their own development group, they would then agree that, well, all the packages they create are com.pluralsight.coursemgmt. And then there's no concern about colliding because then when they name their individual projects, if they named them both myproject, there is no package name collision because the earlier part that was qualified by their group created the uniqueness. And, again, these are all conventions. There's nothing enforcing all this, but these are rules that we follow to make sure our package names don't collide. Now as we put members into a package, those members, of course, become part of that package, and that package becomes part of the members name. So if we just build a class called Main, well, the name of that class is just Main. But now once we put that class inside of a package, the package name becomes part of the overall class name. So the class is no longer known as just Main. The class is now known as com.pluralsight.myproject.Main, and that becomes again, a unique name. And because we all follow these naming conventions, we now know that anyone else in the world can create a class called Main, but because it's qualified by a package that follows a convention, the class name itself is actually unique when qualified fully by the package. Now one of the most significant things that affects us about packages at this early point in talking about Java is that it turns out these package names actually affect the source file structure. Now what's interesting is that Java itself requires no correlation between your package names and your source code file structure. In other words, it doesn't care how the packages are named, it doesn't force you to position or structure your source files in any given way. That's Java itself. The thing is most IDEs do require your subfolder structure to match up to the parts of the package name. So the thing is that even though Java doesn't require it, we kind of can almost ignore that because in practice, most tools that you work with are going to require that your source file structure match up to your package names. So what does that look like? Well, if we build a class, as we have earlier, where we didn't put it inside of a package, well, the way the IDE expects that to go is that you've got your source code folder, and then your Java class file just goes right inside that same source code folder. That's exactly what it expects. But if we now have a package definition in our source code file, the presence of that package name now enforces a structural rule on the way the IDE expects the source code to be laid out. And, basically, it's that each of the parts of that package need to be there‑‑‑I should say each of the parts of that package name need to be in their own subfolder. So, under src, the IDE expects a com subfolder to match the first part of the package name. Then under that it expects a pluralsight subfolder, and then an example subfolder, and then, finally, our Main.java is expected to be inside of there. So as you have different package names, this hierarchy is going to have to match up to all those. Again, this is true in IntelliJ. It's true in NetBeans. It's true in most IDEs.

Demo: Packages
Let's take a look now at how packages affect our application. So here we are in IntelliJ. Let's go and create a new project. It'll, of course, be a Java project? Again, remember that button's at the bottom or off the screen here at this resolution. So we're going to click that Next button. Just accept the defaults here. I'm going to go ahead and create the project template as a command line. I'm going to go down here and click the Next button. So now I'm going to create my project. My project name is going to be Organized. We'll name that as the project. But now I'm going to go ahead and give this one a package name. So we're going to follow the rules we talked about, com.pluralsight. And then we're going to go ahead and add our final qualifier, and let's just call this one getorganized. So now our project name, Organized, is an IDE concept. It's just what we're calling the project within the IDE. But this package name, com.pluralsight.getorganized, is the package name we're using with the Javasense. Very often, the last part of the package name is the same as your project name, but I just wanted to make them different in this case just to show that they're not directly related. So let's go ahead and just finish this. So here we are in our application now. We've got our source code, excuse me, our class in place just like we did before. But now we have that package declaration at the top. What we want to do here is let's go ahead and delete this line away. And let's go ahead and write some output, but this time we'll say something like, Hello Get Organized. Let's just go ahead and run this and make sure everything's fine. So we'll run it just like we did before. Run, Run. We see there in our output that our console window shows Hello Get Organized. So everything ran just like it did before. So within the IDE, nothing's really any different. Let's take a look now about how that change to a package affected our source code of a hierarchy. So I created a project called Organized, so this is the folder I created it in. So it's inside of there. Our src, our source code area. But now notice that we have a com, pluralsight, and then a getorganized. So that's where our Main.java is, so it created our folders just like we thought it would. But let's see how it affects our class name now. So I'm going to go back up here to the Organized level. We're going to go to the output folder, so out, production, and then Organized. So we'll go in there. Let's go and open up a command line here. Now you notice right away that you don't see the main.java in there. In fact, the main.java is actually buried down, again, under this com folder structure. But I don't want to focus on that. We'll talk more about that aspect of it later in the course. What I want to do now is open up the command prompt right there. So we've got our command prompt, and we're going to go ahead and run the program. Now remember that we said when we run our programs, we actually identify the class name. So I'm just going to say java, because we're running a Java program. I'm going to say com.pluralsight.getorganized, that's our package name, .Main. So now when I run that, we get our Hello Get Organized because, remember, we said by putting it in the package, our class Main real name is now the fully qualified name within the package, com.pluralsight.getorganized.Main. So by running that class name, qualified with the package, our application ran correctly.

Creating and Running a NetBeans Project
Up to now, we've done all of our IDE work inside of IntelliJ. So let's take a quick look at using NetBeans to create and run a project. I have a shortcut to NetBeans right here on my desktop, so let's go ahead and start that up. So here we are inside of the NetBeans IDE. So let's create a new project. So I'm just going to say File, New Project. And when we come here, it just asks what kind of project do I want it to be. So I want it to go ahead and be a Java project. It's going to be a Java application. So that's all fine, so let's click Next. So now it comes in here, and it first wants the project name. So we'll go ahead and call this, we'll just call this our HelloNetBeans project. So just like IntelliJ, the project name is really an IDE concept. So what we want to do now is go through and identify where we want it to go. So I'm just going to put it in the same demo folder I've been using for the other parts, for the other demos. And down here at the Create Main Class, so remember that we have our Main entry point into our application. Now, in NetBeans, you actually specify the package name and the class name all together. So we're going to follow the same rules of com.pluralsight. So I've got that top level of the package name. I'm just going to make the next level just say example. So at this point, that's still my package name. And then we'll give it that initial class. Now, remember, we said that although IntelliJ always called it Main, we can call it anything we want. So I'm going to go ahead and call it AppMain. So what this is really saying is that my initial class is called AppMain, and it's in the package com.pluralsight.example. So let's click Finish. So here we are inside of the source code. I'm going to go ahead and close this output window for now, just get it out of the way so we can see more. So you'll notice there, over there on the left, we've got our source packages, and that's our AppMain.java, which is the source code file we're in right now. Notice there at the top, it creates our package declaration, com.pluralsight.example, and we see our class definition. We've got our main entry point, which is the public static void main. So that's where our code will run from initially. And you notice also that NetBeans even put some initial comments in. There's a block comment at the very top there just telling us a little about working with the IDE itself. If you notice, there's the /** above the AppMain. That's actually a JavaDocs comment. So it's even initially laying it out so that we have JavaDocs in place for the AppMain and even for our main entry point. So let's go inside of here, and let's just add a little code to output something. So we've added the code now just to print out Hello NetBeans. So let's go up here and try running it. So I'm going to go up here to my Run menu, choose Run Project. So we can see there in our output window that we've got the Hello NetBeans printed out. So we were able to run, or I should say compile and run our application that easily, very much like what we did in IntelliJ. We saw there were some basic differences in terms of how we created that initial class name and created the project. But, fundamentally, all the IDEs work in very similar ways. Now let's take a look at if we wanted to actually run this application from the command line where we would actually find the folder so that we could actually run it. So remember that I mentioned earlier that each of the IDEs kind of sets up its output folder structure a little bit differently. So here I am in my demo folder, and here's our HelloNetBeans folder that we created for this project. Go down inside of there. And you'll notice here that in NetBeans instead of having an output folder, we actually have this build folder. So let's go in there, and there's a classes folder. And that's where we're going to run our application from the command line here in the NetBeans project. So I'm going to go ahead and just open a command prompt. And just like before, we're going to say java to run it. And we're going to, again, give the package qualified class name, so com.pluralsight.example, and then our class name, which in this case we called AppMain. If we hit enter, we can now see our output, Hello NetBeans. So we still ran it exactly the same. The only difference was that the IDE for NetBeans created a slightly different output file structure than IntelliJ had.

Summary
To wrap up, remember that we used the java command to execute our Java programs from the command line. The key thing there is that it allows us to run our Java programs without having to have a full IDE, that's actually our Java execution environment. When you run the program, we specify the class name, including its full package name. We're not running a file, we're actually running the class. On Windows, in order to access the java command, what you want to do is make sure that you have your JRE's bin folder in your path environment variable. As we saw, programs are made up of statements, so statements, and with semicolons, and the parts of a statement are separated by 0 or more whitespaces. So that gives us a lot of flexibility in how we want to format our source code. As we saw, though, on some of the examples, that can get really ugly, especially if we start using too many new lines. So you want to be careful about how much whitespace you use, but use enough to keep things clear and easy to read. Comments are a useful tool for adding notes to our source code, as well as hiding statements that we don't want to be seen by the compiler. For example, we just want to take some code out to test something or maybe preserve some code for later. And as we saw, packages provide organization, they help us to assure uniqueness in our class names. And we also saw that most IDEs will actually tie the source code file structure to the package name so that each part of the package name is a separate subfolder. As I mentioned earlier, packages are a really important part of Java, and we're going to talk a whole bunch more about this later. In fact, they get their own module.

Variables, Data Types, and Math Operators
Introduction
Welcome to this module on Variables, Data Types, and Math Operators. My name is Jim Wilson. In this module, we'll first look at how they name and use variables. We'll then look at the primitive data types in Java and their behavior. We'll go through the arithmetic operators and order of precedence. And then finally, type conversions, both implicit and explicit type conversions.

Variables
In order to do anything interesting in a program, we have to have the ability to store and manipulate values. What allows us to do that are what we call variables. Now a variable, simply put, is just named data storage. Now Java is a strongly‑typed language. Now what that means is that when we declare a variable like, in this case, we have a variable named dataValue, we have to specify the type of that variable, in this case, it's what we call an int, something that can store integers. So what that means is that the dataValue variable can only store things that are compatible with the type int. As we go through the course, we'll talk about this idea of one type being compatible with another. Now when we declare a variable, we can, of course, then assign a value to it, so our variable dataValue now holds the value 100. Now when we use variables, we can do it the way we've done here where we declare it, then assign it, or as a matter of convenience, we can declare them and assign them in a single statement. Java is a language that allows you to modify the values stored in a variable, so you can store an initial value in a variable, and throughout the course of your program, you can modify the value that's stored inside that variable. When it comes to naming variables in Java, we follow a combination of rules and conventions. The rules allow us to use letters, numbers, the dollar sign, and the underscore. But by convention, we only use letters and numbers. The rules require that that first character is not a number, but since conventions say that we never use a dollar sign or an underscore, that means that we always end up starting it with a letter. So some examples are like If I wanted to declare a variable called total, right, T‑O‑T‑A‑L, right, that's valid. Or grade4, because the four is not the first character, that's a valid variable name. By convention, we follow the naming style known as camel case. What that means is that the first letter of the variable name is a lowercase letter. We start each word after the first with an uppercase letter and all other letters are lowercase. An example would be bankAccountBalance. Alright, the first word is bank, so that starts with a lowercase, second word is account, so we have a capital A, next word is Balance, it's a capital B. Another example, level2Training. First word, level, is all lowercase. We still have the number 2 in there, that's valid, but when we start the next word, training, we use a capital T. So let's take a look now at a simple case of using some variables. So I've got a program stubbed out here with my entry into my main method. I'm going to get a declare variable here called myVar whose type int. We can also call this a local variable just because it's local to the method main, and we'll see some other ways to store information that are not local throughout this course. Here we have this local variable, myVar, and if I go ahead and try to use myVar right now instead of try to print that out, that would actually be an error because local variables don't automatically get a value. There's nothing defined stored inside of them, so we don't want to do that. Before we actually use a variable, we want to make sure and put something inside of it. Alright, so in this case, I have stored the value 50 inside of myVar. So, of course, now if I print that out, I'll get the value 50. Now I can go ahead and declare another variable here, I'll call it anotherVar. And you notice that my variables don't have to be all declared at the top. I can declare them anywhere in my flow of logic that I want to. Alright, so my anotherVar has the value 100 stored inside of it. If I print that out, of course, I get 100. I can assign one variable to another. Alright, so I've assigned anotherVar to myVar. What I'm saying is that I'm assigning the value in anotherVar to myVar. So if I print out myVar, I get the value 100. And one thing that's interesting to note is that if I go out here and I change anotherVar, so I assign it to 200, if I print it out, it has 200 in it, but if I print out myVar, it still only has 100 in it. And basically, we're doing what's called copying by value there. We'll talk a little more shortly about what's actually happening under the covers that allows it to assign between one variable and another without them staying linked. But the key thing to remember here is that you can declare variables, we can assign values to them, we can modify our variables, and we can assign values from one variable to another.

Primitive Data Types
So as we've seen when we declare our variables, we give them a type, and the most fundamental types in Java are what are called primitive data types, and these are the data types that are actually built into the language. Now, when you hear the term primitive data type, you may think there's something kind of lowly about them, you know, something kind of, you know, less than modern about them. But that's not true at all. Primitive data types are actually very important. They're really the foundation of all other types that we use in Java, so they're really that kind of strong foundation that we're going to build on for any other data types we use in our programs. Now there are four categories of primitive types in Java. There are the integer types, floating point, character, and Boolean. So let's look first at the integer types. Now there are four different integer types, but the difference then really is just the size of storage that they take up. But that difference in the size of storage they take up affects the range of values that could be stored there. All right, so the smallest integer type is the byte type. So it takes a 8 bits, so it can only store between minus 128 and positive 127. And so we see when declare it, we just declare a variable of type byte, and we just assign the integer, excuse me, the integer literal to it. All right, so here we have a byte numberOfEnglishLetters = 26. The next larger integer type is short, which takes up 16 bits. Let's let you start with, store between negative 30,000 and positive 32,000. Use it exactly the same way. So we have here short feetInAMile is 5280. Probably the most commonly used integer type is the one called int. That's a 32‑bit integer. And being 32 bits, let's a store between minus 2 billion and positive 2 billion. And then the big integer type is what we call a long. That's a big 64‑bit integer. And you see it can store huge values in it. The key thing to notice though is that when you use a long literal value, you have to put that capital L at end of it. Now Java also has floating‑point types. Now, the floating‑point types conform to the IEEE standard for floating point, and that may or may not be meaningful to you. What it really comes down to is that floating points allow you to store values that have a fractional portion to them. Basically, it supports positive, negative, and zero values that have some fractional portion. There's a lot of nuances to the way floating points work, and they're kind of outside the scope of this course, but I've got that URL on the screen there for you. If you want to know a lot more about the details in terms of how floating points work and kind of the oddities of them, I encourage you to check that out. But basically, we have our two floating‑point types in Java. First, we have the float type, which is a 32‑bit floating‑point value. Notice that when we use the float type, we have to put the f at the end of any constants for it. So when we declare this float called milesInAMarathon, we say 26.2f, saying it's actually a floating‑point value. And then we also have double, which is a 64‑bit floating‑point value. If you just use a literal that has a decimal in it, the compiler assumes it's a double, but you can also make it explicitly a double by putting a d at the end. So if we look here, we have double atomWidthInMeters. You see that 0.0000000001d denotes that that is a double literal. And our last two primitive types are character and Boolean. And a character, or actually, the char type, stores a single Unicode character. And basically, you denote the literals of these by just using single apostrophes or single quotes around the constants. So if I say char, the regularU equals, and I put 'U', that assigns that char into it. Now note this is different than strings. We'll talk about strings later. Char is just a single character value. And because the char type supports Unicode, you can actually specify any valid Unicode character in there. So if you want to assign a Unicode character that you don't have on your keyboard, you can use the Unicode code point by using that \u notation. So you see here I've got this char accentedU with the '\u00DA. Says that that is actually a U with an accent on it. And then finally, we have our Boolean types. Boolean types store true and false. The literals for that are true and false, so if I say boolean iLoveJava = true.

Primitive Types are Stored By-value
Java primitive types are stored by value, and that's important to understand because it affects the behavior applications when we assign values from one variable to another. Let's take a look here. If I declare an initial variable called firstValue and I assign the value 100 to it, what's actually happening under the covers is that an area of memory is being allocated that's named firstValue and the value 100 is stored inside that memory. So now if I declare another variable, in this case, other value when I assign first value to it, again, I'm looking in an area of storage, I'm giving it a name otherValue, and when I make the assignment, the value 100 is being copied from firstValue into otherValue. And what that means is that there is a distinctly separate copy of that value 100 being moved over into otherValue. What that allows me to do then is that if I make modifications to firstValue, for example, assign the value 50 to it, that 50 replaces what's in firstValue, but it leaves the very well called other value completely untouched, right, and that's what I mean by being stored by value so that each primitive type variable has its own separate copy of the data.

Arithmetic Operators
Something we commonly have to do in our programs is perform arithmetic operations. Java provides three basic categories of operators for performing math operations. They're the basic operators, like add, subtract, multiply, and divide, what are called prefix and postfix operators, and then what are called compound assignment operators. The basic math operators are just what you would expect, things like add, subtract, multiply, and divide. The operators we use for these are, again, things that are very familiar. If I'm adding, I use a plus sign. And when I do things like add, it doesn't really matter whether I'm using a floating point or an integer. So if I say 1 + 2, the answer is going to be 3. For subtraction, we use the minus sign. Again, it doesn't really matter whether we're using floating point or integers. If I subtract 4 from 5, I get 1. If we multiply, we use an asterisk, 4 * 2 is 8. And all that stuff is really straightforward. As we get to the divide operations, though, there are some differences between floating point and integer. If I take 13.0 and divide it by 5.0, that's a floating point operation. Floating points have fractions, so I will get 2.6. But now if I take the integer 13 divided by 5, that's an integer operation. Integers don't have fractions, so I'll actually get just 2. It doesn't matter what the fractional portion would be. It's just dropped. There's no rounding or anything. It's just the whole number of times that you can do the division. So 5 goes into 13 two whole times. There's another operator called the modulus operator, also known as the remainder operator, and that gives you the remainder of the divide. So let's look at the integer first on this one. If I say 13 % 5, that's the percent symbol, my answer will be 3. Five goes into 13 two whole times, leaving 3, 5 * 2 is 10, subtract 10 from 13, you get 3. And you can do a modulus on floating points as well. So if I do 13.0 % 5.0, I'll have a remainder of 3.0. As we look at the prefix and postfix operators, they allow us to operate directly on a value. The ++ symbol is the increment. It increments a value by 1. The ‑‑ symbol decrements a value by 1. So if you look here, if I have a variable, myVal, and I set it to 5, if I say print out ++myVal, that's the increment operator. Because it's before the actual variable, the ++ is before the variable, that's a prefix, which means that the operation is actually applied before we get the value back. So the result of this print statement is actually 6, the 5 was incremented, so we print out it was 6. If I print myVal again, it's still 6. But now if I move the operator after the variable, it's now a postfix operator. And what that means is that I get the value back, and then the operation is performed. So if I look at similar code here where I have my variable, myVal, I set it to 5, but this time when I print it out, I say myVal++, so I'm doing a postfix increment. The value printed will be 5 because that 5 was returned. But myVal is now incremented. If I print myVal now, I will get 6. The last category of math operators is what we call compound assignment operators. And what these do is they combine an operation and the assignment. So, basically, it looks at the right side of the operator, takes whatever that is, and applies the operation to the left side, and then stores the value into the left side. So let's see what that looks like. If I go ahead and have myVal, and I set it equal to 50, if I say myVal ‑= 5, so the right hand side's value is 5, the left hand side value is currently 50, it applies the operation, which is the minus sign, so it subtracts 5 from 50, and then stores that value back into myVal. So if I print out myVal, myVal has 45. And they're available for all five basic math operations. In my experience, I use the ‑= and the += far and away the most, but you do find occasions to use the other ones as well. So looking at another example, if I have an int result = 100, and I have 2 more variables, val1 = 5 and val2 = 10, if I now say result /= val1 * val2, remember that it's going to take the complete result of the right side. So if I look a val1 * val2, the result of 5 * 10 is 50. It then takes the existing value in result, which in this case is 100, and then it then takes that operator, the divide, and performs that operation between them. So it's going to divide 100 by 50 and then store that back into our variable called result. So we print out the value of 2.

Operator Precedence
The operators are evaluated in a well‑defined order. If we look at them, basically, the postfix operators are evaluated first, then prefix operators. Then the multiplicative operations, all right, multiplication, division, and modulus. And then finally, the additive operations, right, plus and minus. Operates of equal precedence are evaluated from the left side of the equation, moving right. And you can override precedents by using parentheses. If you have nested parentheses, those parentheses are evaluated from the inside out.

Demo: Operator Precedence
To get a better sense of how operator precedence works, let's take a look at some code. We have a simple program here with four variables declared at the top. We want to do is kind of set up some math operations and see how the order of precedence affects the result we get. So let's go ahead and declar an integer for a result, so I just call that result1. And what I'm going to do here is going to take the variable valA, and then I'm going to go ahead and subtract valB from it, and then I'll divide that by valC. So let's go here, and just go ahead and just duplicate that now, so another one just like it. Call this one result2. And all I'm going to do is put a set of parentheses in, put a set of parentheses around valA and valB here. All right, we've got these parentheses in place, so the last thing I want to do is just go ahead and print these guys out. All right, so let's go ahead and run it. And as we run it, we see that we get two very different results. The first one, result1, gives us a value of 19. The second one, result2, gives us a value of 5. What's happening there? All right, well, in the first line where set result1, remember that multiplicative operations take precedence over additive operations. So division is a multiplicative operation, so basically, valueB, which is 6, was divided by valueC, which is 3, which gave us a result of 2, and so then we subtracted that 2 from valueA, which is 21, giving us 19. The second one, result2, because of the parentheses, we overrode that that normal order of operations. As a result, we first subtracted 6 from 21, which gave us 15, and then we divided that by 3, which gave us a result 5. All right, so we overrode that normal order of operations by adding parentheses. So let's look at another case here. We'll go and set up another equation. We'll set up a result3 here. And for result3, what we'll do is we'll set valueA, we'll divide that by valueC, then we'll multiply that times valueD, and then finally add in valueB. All right, so that sets up one, so let's go ahead and copy this now, and will duplicate it, but then we'll modify it a little bit. So we'll call a result here, result4, and we'll use some parentheses. So first thing I'll do is put parentheses around this addition here, valueD and valueB, and then what I'll do is I'll put another set around valueC and the result of valueD plus valueB. So I've now got nested parentheses. So with that in place now, what I want to do is let's go ahead and print these guys out as well. Okay, we're all set there. Let's go ahead and run it. And notice again we get very different results. For the result3, we get 13. For result4, we get the number 1. Well, what's different? Well, again, remember that multiplicative operations come ahead of additive, and then when two operations are on the same precedence they're left to right. So in our result3, the first thing that happens is valueA is divided by valueC. ValueA has a value of 21, valueC has a value of 3, so that gives us a value of 7. Then that's multiplied by valueD, which has a value of 1, so that's still 7. And then we add in valueB, which has a value of 6, and that gives us 13. But then on result4, because of the parentheses, we're changing that order of operations. So we have nested parentheses going to the innermost one, so first we get valueD plus valueB. So valueD is 1, valueB is 6, so 1 plus 6 is 7. We multiply that times valueC, which is 3, which is 21, and then we divide valueA, which is 21 by 21, giving us result of 1.

Type Conversion
Operations in our applications will commonly involve multiple data types. Because of that, we have to deal with type conversions. Now there are implicit type conversions, and those are type conversions that are performed automatically by the compiler. To see a simple example of that, we look at something like here we have an integer iVal that we've assigned the value 50. If I then say long lVal equals iVal, the compiler has to convert that 32‑bit integer iVal into a 64‑bit integer as it's stored into lVal. And there are also explicit type conversions, and these are conversions that I explicitly perform in my code, and I do that using a cast operator. We see here if I had that long lVal = 50 now, so I'm now assigning a 64‑bit integer the value of 50, if I want to assign that into this iVal, a 32‑bit integer, I have to explicitly cast it. I have to tell part of that I want to go from that 64‑bit integer into a 32‑bit integer. And I do that by using the type I want to convert to, in this case, int, putting it inside of parentheses, and putting it next to the value I want to cast. So this says, the int in parentheses says, take the lVal and cast it down to a 32‑bit integer. If we look now at these implicit type conversions, these are generally what we call widening conversions, and these can be done automatically because we're moving to a wider data type. So if I have a 32‑bit integer and I want to move to a 64‑bit integer, that's wider, right? So the values can be safely moved, so those can be done implicitly. And the compiler has to make decisions about how to make these conversions. And the rules are pretty straightforward. If I have expression with multiple integer sizes in it, maybe have a short and a long, whatever the largest integer size is is what things will be converted to. So if I do an operation with a short and the long, the short will be implicitly cast into a long. If I perform an operation with mixed floating‑point sizes, so I have a float and a double, it'll always go to the double because double is the largest floating‑point size. And then if I have an operation that uses integer types and floating‑point types, the compiler will cast to whatever the largest floating point in the equation is. So if I do an operation with a long and a float, the long will be cast to a float. If I do an operation with a long and a double, the long will then be cast to a double. Explicit type conversions are the ones that we explicitly perform in our code using this cast operation. When we do that, we're taking responsibility for whatever happens as a result of that type conversion. Because of that, we can perform both widening conversions and narrowing. So widening going from a 32 bit to say a 64 bit, narrowing going from a 64 bit down to a 32 bit. We should just want to be aware that we know what could potentially happen. If we do an explicit cast from a floating point to an integer, while floating points can have fractional portions, integers can't. So any fractional portion would be dropped when I cast that float down to an integer. You want to be careful when performing a narrowing conversion. If I have a 64‑bit integer, it has the ability to hold values that are too large to fit into a 32‑bit integer. So if I cast that 64 bit to a 32 bit, the program will actually do it, but if the value was too large to fit into a 32 bit, you'll get some odd results from that. So you want to make sure that when you're casting it, doing a narrowing cast, that you know that what you're doing is safe. And the last one is just that you want to be careful when converting from an integer to a floating point. Because if you have an integer with a large number of significant digits, because of the way floating points are stored, you could lose some of those significant digits. The deep details of how these type conversions occur are beyond the scope of this course, but if you'd like to understand them in more detail, I've got that URL on the screen for you that actually points to the Java documentation that talks about those details. If you check that out, you'll particularly want to look at the sections on widening primitive conversion and narrowing primitive conversion.

Demo: Type Conversion
Let's jump into some code now and see these type conversion behaviors in action. We have a simple program here that has some declarations at the top, right, float, double, byte, short, and long, and the variables are each named to help identify what their types are, like float is floatVal, long is longVal, and then println just prints out of a Success message if it runs. So let's just see how some of the type conversions come into play here. So, first of all, let's just go ahead and create a variable. We have a short, and we'll just call it result. In fact, then go ahead and call it result1, and let's just do a simple assignment. And so first we'll just assign the byteVal to it. All right, now as we expect, if I go ahead and run this, so run successfully. We know that's a valid assignment because a byte could be assigned into a short because that is a widening conversion. Right now, if I take this byteVal thoug and I make it a longVal instead, all right, so now it's actually a long, if I run this, I get the error message here saying incompatible types, possible loss conversion from long to short. All right, so what I can do here then is I can do an explicit cast. I'll just put short in front of this. So now it's valid, so I can run it, and, of course, it works. Right, because the long could not go into the short because that was a narrowing conversion. But by putting the explicit cast in front of it, now it's valid. If I want to, I can put a cast notation into my one, if I want to be very explicit and say that, hey you know, I know although a blank conversion is legal, I want to explicitly show that I'm casting it by putting the short cast in there. I can do that, and that's completely legal. So let's take a look at another scenario and create another variable called result2. And result2 is a short as well. And what I want to do here is I'm just going to take my byte value, and I want to subtract the long value. Right, now we know that's not legal because the result of the expression is going to be the size of the largest integer in it, which is the long. Right, so if I run this, I just get an error saying that it's not valid to convert a long to a short, but let's say I want to go ahead and keep that result to a short, well I need to do a cast. All right, but what I want to cast this time is the value of the entire result here, right. So what I'm going to do is put the short cast in front of it here, then what I'll do is go ahead and wrap the whole thing in parentheses, right. So now what we're saying is that the result of byteVal minus longVal, which will be a size long, we want to cast that down to a short. So if I run this now, it will run successfully. So now let's try another one. Let's go ahead and declare another one called result3, but I'll declare this one as a long. So I've got my result3, and what I'll do here is I'll assign that, our longVal minus our floatVal. All right, so now if I run that, my error now says that it's a loss conversion converting from a float to a long, right. Because whenever we have an integer type and any floating point type, the result is going to be the floating point type. So let's go ahead and convert our result now to a float. All right, so by making that a float, I should be able to go ahead and run it. And it runs successfully. But now if I take the floatVal here and I convert this to be a doubleVal, and if I try to run this, alight I get the error because it says the result is going to be a double. Right, because, again, when you do an integer and a floating point, it's the size of the largest floating point in the equation, right. So let's go ahead and make this result a double, so now we can run it. All right, let's look at one more. So I'm going to have another result that I'll make a long. So this result we're calling result4. And what I'll do here is I'll just take the short value and subtract the long value from it. Now we know that's valid because the largest type in there is the long and result is long, so that's okay. But now let's go ahead and add in the floatVal, right. So if I run it now, I'll get an error message saying well it doesn't know how to convert a float to a long? Let's go one step further now, and let's go ahead also and add in our doubleVal. All right, now if we run it, we'll still get an error, but now it says it's unable to convert a double to a long. So as we see our result here, our errors are changing based on the types that are involved. Right, when it was all integers, it was the size of the largest integer there. Once there was a floating point involved, it's the size of the largest floating point, right. So when it was a short and a long, it was a long. When it was a short, a long, and a float, the result became a float, and then it was a short, a long, a float, and a double, result became a double. So the run this, let's go ahead and cast this whole thing to be a long. So I'll make this a long. Again, we'll wrap the whole thing in parentheses. And now we should be able to run it just fine.

Summary
To wrap up, remember that variables are strongly typed in Java, and the foundation of the Java type system is the primitive types. We saw that there were four categories of those, integers, floating point, character, and Boolean. But then within the integer and floating point types, there're even types of varying sizes. So images could be as small as a byte with only 8 bits or as large as a long with 64 bits. So many floating points had float with 32 bits and double with 64 bits. We have a really rich list of math operators, anything from the basic operations like add, subtract, multiply and divide to the postfix of prefix operators that allow us to increment and decrement values to the compound assignment operators that allow us to apply an operation to the value in a variable and store that result back into the same variable. Remember, too, that our math operators follow a well‑defined order of precedence. Remember that you can actually affect that order of precedence by using parentheses. And when it comes to type conversions, we often have to move between different types because our programs, as they get more complexity, will likely involve multiple data types. The compiler can handle type conversions that are widening, moving from one type to another that can hold larger values. But you can also use casting to explicitly perform those type conversions that the compiler can't perform automatically.

Conditional Logic, Looping, and Arrays
Introduction
Welcome to the next module in our Java Fundamentals course on the Java language. In this module, we're going to take a look at Conditional Logic, Looping, and Arrays. My name is Jim Wilson. We've got a jam‑packed module here. We're going to talk about a lot of great stuff. We're going to start out looking at the various aspects of conditional logic in Java. Then we're going to look at the basic looping capabilities. We'll take a look at arrays, something called the for‑each loop, and then we'll finish up with the switch statement.

Conditional Logic and Relational Operators
Adding conditional logic is one of those simple things we do in our programs, but they're really central to them behaving well. When we talk about adding conditional logical, all we're saying is that our program will behave differently based on differences in data values. And there are four things we need to understand to do this. One is relational operators, that gives us the ability to test different values; something called conditional assignments, which allows us to assign values differently based on conditions; the if statement, which allows us to change our code path in our application; and then logical operators that allow us to combine different conditions together. Looking first at relational operators, these allow us to test values against one another. These are very familiar if you're coming from any other programming language. We'll just go through them quickly. The first one is greater than, is the first value larger than the second value? Look at our integer example 5 > 4. We get into character data values. What this does is this uses the different Unicode code point, so if the code point is larger than the sort or the comparison is considered larger, so 'c' > 'a'. And there's no way to do a greater than with a Boolean. Alright, then there's greater than or equal to, which says that if they are the same or the first one is larger, right, so 5 >= 4, but 4 is also >= 4, right, because it's the same; our character ones, so 'c' >= 'a' and 'a' >= 'a'. Less than, is the first one less than the second one; 4 <= 5, right, 'a' < 'c'. Less than or equal, 4 <= 5 and 4 is also <= 4. Now we get to equal to, right. Now equal to is the equivalent, or the value is the same, right? And we use two equal signs to do that, right, so 5 == 5, right, and 'c' == 'c' that makes sense, but when we get to the Booleans, basically they're equal if both sides are the same, right, so true == true, so that makes sense, but also false == false, right. So if you have two false values compared for equal, that resolves the true because those values are the same. And then finally, not equal to is simply, are they different, right, 4 != 5, 'a' != 'c', and true != false.

Conditional Assignment
A conditional assignment allows us to assign a value to a variable based on the result of some condition. So if we look at setting up an assignment here, we're actually going to divide things into multiple parts where we have a question mark and a colon. And what that lets us do is have a condition, and then we test that condition. If the condition is true, we return the value immediately after the question mark, but if the condition is false, we return the value after the colon. So to see that in action, I have some simple code here where I've got two variables, v1 is 7 and v2 is 5. And now I set this up so that my vMax = v1 > v2. So we're doing that condition. We test that condition, is 7 greater than 5? Since it is, vMax gets back the first value there, the v1, which is a 7. It's a true value. Look at another example. If I set this up where I have students is 30 and rooms is 4. If I say that studentsPerRoom = the condition, is rooms == 0?, well, if it was true, we return 0, but if it's false, which it is, we go ahead and do the equation of dividing students by rooms, so the value of studentsPerRoom is 7.5, the result of that equation.

If-else Statement
The if‑else statement allows us to conditionally execute another statement. So rather than just returning a value, we can execute an actual statement. And so basically we start with just the keyword if followed by parentheses and inside of these parentheses, we add a condition, and then following that, we have the statement we want to execute if that condition is true. If the condition was false, we would just skip over that statement. Alright, so to see that in action, I have some code here where I have two variables, v1 is 10, v2 is 4. I say if (v1 > v2), printout v1 is bigger. So basically it just evaluates that condition as long as it's true, which in this case, it is. It prints out v1 is bigger. If statements can optionally have an else clause added to them, which says what do you want to do if the condition is false? Simply put else, followed by whatever you want that action to be on the false side. So our code here, we say else, printout v1 is not bigger. Oftentimes you'll have more than simply if this condition is true or it's false. You may have multiple things you need to evaluate, so you can actually chain if‑else statements together. And when you do that, the system will just keep evaluating them until one is true. Alright, so we set that up with our regular if statement just like we did before, followed by the else, but after the else we can put another if and another condition. And if that condition is true, we have its true statement. And we can repeat this as many times as we want. We could have 20 or 30 of these in a row if we wanted to. That probably wouldn't be good coding practice, but it's completely legal. And you can optionally have just an else at the end to say, well, if none of those were true, what should I do in that case? So to see that in code, we have our v1 is 10, v2 is 40. We said, well, if(v1 > v2), printout v1 is bigger, else if(v1 < v2), printout v2 is bigger. And if neither of those are true, then printout v1 and v2 are equal. So in this case, the system would first evaluate the is v1 > v2? It's not, so it jumps down to that next condition, is v1 < v2? Oh, it is. Go ahead and printout v2 is bigger.

Block Statements
Thinking about our if statements, remember we said that an if statement conditionally executes another statement. And if you think about it, we never saw any kind of end if for anything like that. So how do we execute multiple statements conditionally? Well, that's where a block statement comes in. A block statement groups individual statements into a compound statement. So if we have a series of statements that we want a group together, what we can do is wrap them in an opening bracket and a closing bracket, and that now makes them a compound statement and enables and be treated as a single statement. So we look at this in code. I have some code set up here where I've wife v1 = 10, v2 = 4, and a variable diff. And I say if v1 is greater than v2, and I put in diff = v1 ‑ v2, and print out v1 is bigger, and then diff. The way this code is currently written, the assignment of diff = v1 ‑v2 is conditional on whether v1 is greater than v2, but the two print statements there, v1 is bigger and diff, will print every time because only the single statement of the assignment of diff is tied to the condition. So that's where block statements come in, by putting an open bracket after the if and then a closed bracket after that print of diff. Now that becomes a block statement, and so the if now condition is tied to those entire three statements. Similarly, I could do that with, like, an else if. I've got an else if v2 greater than v1. Although, by the way, I have my code indented, it looks like all three of these statements, the diff assignment and the two printouts, are tied to that v2 greater than v1. Currently only the diff assignment is tied to the condition. Again, I need to put an open bracket and a close bracket to bring those into a block statement. And here I also add an else. So the thing to note is that block statements are kind of independent from one another, right? So if you have an if and an else if and an else, if you want to have block statements on part of them, like I do on the if and the else if, but just single statements on other parts, like we do with the else, that's just fine. Just one other thing I want to bring note to as well in this code, notice the very first line of code. I'm doing variable declarations in a way I haven't done before. Notice that on one line I'm declaring multiple variables of type int. All right, normally in all of our other code we've done those on individual lines. And I just wanted to show you here that you can actually do multiple variable declarations on the one line like that. So we're saying that v1 is an int that has value of 10 initially, v2 is an int that has a value of 4 initially and diff is an int that's not yet initialized.

Demo: Nested If-statements
Let's take a look at a demo where we nest one if statement inside of another. I have a simple program here where we have two variables declared, students, which is set to 0, and rooms. And let's say we want to do a very simple bit of code, right, just say if students is greater than zero, if that's true, I want to print out the average number of students in each room. And then if students is not greater than zero, I just want to go ahead and print out the fact that there are no students. Okay, so that's pretty simple, right? So let's go ahead and run it. And we run it, we get the message we expect, right, no students prints out, so that code is working well. But now, if we look at this code, you know, I realized that, you know, I'm dividing students by rooms. What would happen if rooms was zero? We'll just like in real mathematics, you can't divide by zero. Well, in Java you can't divide by zero either. All right, so if we're going to really be, you know, good defensive programmers here, we would actually check to make sure that rooms was not zero before we actually tried to do this division. All right, so what I'm going to do here is just add a line here that just says, well, only do this if rooms is greater than zero. All right, so I've got that test in there. Let's go ahead and indent this so that it matches up with our style here of indenting underneath the ifs. Let's go ahead and run this now. And you notice that when we run it, we don't see our no students message. What happened? Right, that worked before. Why is it gone now? Well, because the else is matching up to the closest if to it. Right, so in this case, the else is matching up to the test for rooms being greater than zero. Even though we really want it test against, or match up against students greater than zero. So how do we fix that? Well, we can use the block statement style. What we can do is take the if here, put an open bracket before it, and then another open bracket here. And now that closes up that if block. Right, so that that prevents the else from matching up to the if for rooms. We closed that if for rooms within a block under the if for students. That way, the else matches up to the if that we want it to. All right, so if I go ahead and run this now, our program now performs correctly, printing out the no students message.

Block Statements and Variable Scope
As we use these block statements, what happens if we declare a variable inside of a block? Well, it turns out that variables that are declared inside of a block are only visible within that block. They're not visible beyond the scope of that block. And, in fact, this idea of where a variable is visible is known as the variable scope. Let's take a look at some code. So I've got code set up here where I initialized students to 30 and rooms to 4. So I put an if statement in place where I want to just make sure that rooms is greater than 0. And I open it up with my bracket, meaning I want to create a block, so I have a closing bracket to close the block. And inside there, I print out students and rooms, and then I declare a float called average, which has a result of students divided by rooms. Now, if I then outside the if block attempt to print out average, I'll actually hit a compile error because once I leave that block, average no longer exists. But notice that variables can come into the block. I've got students declared before the block started, and students is valid to use within the block. Same thing is true for rooms. And so the way it works is that variables that are in scope when the block starts remain in scope. But variables that are created within the block go out of scope at the end of the block. So the way I would have to fix this code is I'd have to do one of two things. I'd have to declare average before the start of the block, so move it up before the if, or I can move the print statement inside the block while average is still available.

Logical Operators
Logical operators are useful for arriving in a true or false value by operating on other things to provide true or false values. They could be Boolean variables, but more commonly, logical operators are used to work on the results of other relational operations. So there are basically four fundamental logical operators and, or, exclusive or, and what we call negation. And if we look at this, is that the and allows us to take two things that can resolve to true or false, and if both of those are true, then the and returns true. All right, so if we look at a little bit of code here, if I have three variables declared, a, b, and c, and I say if a is greater than b and b is greater than c, print out a is greater than c. What this does is that first we do the comparison of a being greater than b. In this case it is, 20 is greater than 14, so a greater than b resolves the true. Then we operate on b greater than c. Well, 14 is greater than 5. That resolves to true. And then we and those two trues together, and true and true equals true. All right, so an and resolves to true only if both sides of it are also true. Then we have an or. An or compares the two sides, and only one side needs to be true. So if the first one's false and the second side is true, then that resolves to true. If the first side is true and second side is false, that still resolves to true. And even if both sides are true, the or resolves to true. Now that's different than the exclusive or. In the exclusive or, exactly one side needs to be true. It can be false or true and then true or false. In the case of exclusive or, it just can't be true or true. And the last one is negation. Negation basically reverses the result. So basically, when you use negation, not false is true. And so if we look at that in code, if I have a boolen variable done, I say done is false, well, if I go if not done, print out "Keep going". Well, if we look at done, done is false, but then the not of done, or the not of false is true. There are two special logical operators called conditional logical operators. There's a conditional and and conditional or. Now, conceptually, these resolve the same way as the other ands and ors we we looked at. The key difference though is that they only execute the right side of their test if they need to do that to determine the result. So in the case of an and, for and, both sides have to be true. So a conditional logical and only executes the right side if the left side was already true. Because if the left side was false, we know the and's going to fail anyway, so there's no reason to even run the right side of it. In the case of the conditional logical or, it only executes the right side if the left side is false. Because if the left side were true, in that case we'd already know we were done, so we wouldn't need to execute the right side. So looking at the conditional and, we still need both sides to be true for that to resolve to true, but when doing a test, if the left side had resolved the false, it would never even run the right side because we already know the result of the and would be false. Looking at the conditional or, the left side is false, but you or that with a right side of true that resolves the true. If you do a conditional or and the left side is true, it never even runs the right side because we already know the result's going to be true.

Demo: Logical and vs. Conditional Logical And
Let's take a look at a demo, comparing the behavior of a logical and to that of a conditional logical and. We have a simple program here where we have two variables declared the top, all right, students = 150 and rooms = 0. And let's say I just want to put a condition in here where I want to print out the message Crowded if there are more than 30 students to a room. All right, so I'm just going to run if my statement. And I'll just take students, divide that by rooms, and then if that's greater than 30, I'll go ahead and I'll print out my message. So if the result of students divided rooms is greater than 30, I print out that Crowded message. Now, of course, one of the issues I have is that well, what if rooms a zero? Right, again, you can't legally divide by zero. So what I really want to say is that, well, if rooms is greater than zero and students divided by rooms is greater than 30, then I'll print out that message. So what I'll do here is just put in ere, rooms greater than zero and then and students divided by rooms is greater than 30. Right, so that way we'll do both tests. Right, rooms is greater than zero, so it's going to be a valid division, and then the result of the division. Rights, so let's go ahead and run this. And notice what happens there. I'm getting an error message, right, because it's not legal to divide by zero. Because what happened is that it first did rooms greater than zero, now that tested to false, all right because rooms is not greater than zero. But then it tried to do the right‑hand side of the and as well. Right, it tried to do the students divided rooms, which created the error because you can't legally divide by zero. But now, if I go ahead and change this to the double ampersand, making it the conditional logical and, now we'll only do the right‑hand side if the left‑hand side was true, right conditionally, right, it does the right‑hand side conditionally. Now, if I run it, I don't get the error message. It ran successfully. Now it didn't print the message out, right, because the combined value of the test was false. Right, rooms was not greater than zero, but we ran successfully. So we were able to conditionally execute the right‑hand side of the and based on the left‑hand side. If the left‑hand side had been true, we would have also run the right‑hand side to see if it was true. But once the left‑hand side was false, we never been bothered running the right‑hand side.

Demo: CalcEngine
Let's do another demo we'll call our CalcEngine demo. And what we'll do in this demo is we're going to create a simple application that can go through various just mathematical calculations as we're starting in this module, but we'll be using it throughout the course, enhancing it with the various things we learn. We'll start out by creating a brand new project. I'm going to use IntelliJ for mine, but you could use whatever you prefer. We'll create a new project. Remember that, as I mentioned earlier, that just because of the screen resolution with recording you can't see the very bottom of this wizard screen. So if you scroll up here, you'll notice there's a Next button down there at the bottom. I'm just going to go ahead and create a Java project by clicking Next. I'm going to go ahead and create a command line project. Again, down there at the bottom, there's a Next button, so I'll go ahead and click that. So I'm going to call this project CalcEngine. And then for my packaging, I'm going to be com.pluralsight, and I'll call it .calcengine. So I've got my project name and my package name. Now I'm going to click the Finish button down there at the bottom. So now we have our application created. I'm going to go in here and just get rid of this comment line, get that out of the way. Throughout this project and throughout this course as we build on this project, we're going to again just do some mathematical operations and have the program kind of just do kind of smarter and smarter things for us. But we're going to initially start out very simple, just doing two‑member calculations, you know, adding two numbers together, multiplying two numbers together, that sort of thing. So what we're going to do is declare a couple of variables here at the top, first of all. So we want to declare two variables that are double, val1 and val2. I've got those two variables. Let's go ahead and have another double for result. So now I have the ability to have two values to operate on and store the result. And what we'll do is that we'll use a concept that we'll call opCode. So we're just going to use a one‑letter code to indicate the mathematical operation we want to execute, like a for add, s for subtract, that sort of thing. I'm going to create a char variable called opCode. So that's my basic ability to set the values of what I want to do. And so I'm going to go through now and just add if statements to perform those operations. So the first one will be add. So that's going to be the opCode a. So we're going to say if and then opCode == a. So of the opCode is a, what I want to do in that case is add the two numbers together and assign it the result. So it's that simple. So I've got the a in place now for add, and I want to do an s for subtract. So I'm just going to do an else if, in this case opCode == s. And of course, in that case, I'm just going to subtract value 2 from value 1. And we'll do the same thing for d for divide and m for multiply. And finally what we want to do is just print out the value of result. We're going to now notice here that throughout the program, the IDE is kind of underlining all my variables. They're showing me that there must be something wrong. And what it is is that we're trying to use all these variables without having initialized them. So what we need to do is go ahead and initialize them. So let's go ahead and set val1 to 100 and val2 to 50. So we've got those initialized. And let's set our first opCode here. Let's just make that a for add. So now we've got all the variables we're using initialized. Now we're going to assign result, but, you know, it's possible that maybe we'd set the opCode wrong. Instead of it being a proper value like a, s, d, or m, maybe we actually put something like x or whatever. So what we'll do here is that at the end of our else if, we'll add an else. And just if it's not any of the values we expect, we're just going to go ahead and set the result to 0. Alright, so now we have a very simple program in place that we can actually just set an opCode, set two values, and get the result. So right now I'm set to add 100 + 50. So let's go ahead and run it, and we display 150. So it did the math correctly. Of course, all I have to do now is change this from an a to a d, and now it'll divide instead. So if I run it, I get 2 because 100 divided by 50 is 2. Alright, so we're off to a good start here. Now we can make things a little better here, and we can get this bottom window out of the way. Now when we have this bad opCode, just showing a result of 0 could be confusing. So what we probably want to do is maybe we can put in an error message here. So let's go ahead and print out an error message that says Error ‑ invalid opCode. And so now if we put in a bad value, it would actually just display a message and show something useful. So now I currently have a good value here though. The opCode is d, so that's still fine. Let's go ahead and run it and make sure everything's okay. And you'll notice that when I ran it now, I didn't get the proper answer, 2.0. I got 0. And that's because I need to make this a block else or block statement with this else because remember the else only had ties to the one line here. So by actually adding this print statement here, I'm forcing it to always set result to 0 no matter what is done before that. So I'm going to go ahead and make this a block statement. And now, of course, it'll do the right thing because it only sets result to 0 if we're inside the else block. So of course now if I run it, I get my 2.0 displayed again. And now one other thing, we're still exposed on our divide to a divide by 0. So a good programming practice, of course, is to always check to see if the bottom value, the divisor, is 0. So what I want to do here is say that if val2 is not equal to 0, then in that case, I'll do the division. Otherwise, I want to set that equal, set the result equal to 0. So now if I run it leaving val2 as 50, it displays 2.0. But if I change val2 to be a 0 and run it, now I get the 0. So it's doing the right thing. Now one thing to note here is that an if statement like this where you simply do a condition and then set a result to one thing or another, that's a great time to use that conditional assignment idea. So what I can do here is instead of that if else like that, I can simply say results = val2 != 0. And if it's not equal to 0, then go ahead and divide val1 by val2. Otherwise, return 0. So that one line replaces all of this. So I'm going to go ahead and comment that out. So now if I run it, it still runs correctly, so 0 because val2 is 0. If I change val2 back to 50, run it again, now it's 2.0. Now one thing to note here is that it appears that we have multiple lines under this else if for opCode = d. But remember that those last four lines are commented out. So it's still treated as if there's only one line under the else if. So we didn't need to make that a block statement. With a situation like this where I've got code hanging around, it's kind of confusing because it just may seem odd that I've got all these statements there and they all seem to apply to the else if. It's often useful to go ahead and use a block statement just to make your code more readable. So what I'm going to do is just put this in a block. Even though it's not necessary for the program to run correctly, it makes the program much more readable.

Loops
Let's take a look now to three basic ways to write loops in Java. First is a while loop, then a do‑while loop, and then the for loop. A while loop is really the simplest way to write a loop. All right, it allows you just to repeatedly execute some statement as long as the condition is true. The while loop is structured so the condition is checked at the start of the loop. So basically we use the while keyword, we have our condition, and then we have the statement we want to repeatedly execute. Now because the condition is checked at the start of the loop, it's possible that the statement never executes. All right, let's look at an example. Let's write a simple bit of code that we'll use to do a factorial function, right. Factorial is just you multiply a number times each number below it right. So five times four times three times two times one, that sort of thing. So we set it up with our while and we want to say that our value kVal is greater than one. Right, so kVal starts out at 5, and we're going to keep inside this loop as long as kVal is greater than 1. We then say our factorial is equal to itself times kVal. Right, so the first time into this loop, factorial is 1, kVal is 5, so factorial becomes 5, right 5 times 1. Then we reduce kVal by 1, kVal minus equals 1, making kVal 4 now. Right, it goes back up to the while statement. So now it checks, 4 is greater than 1, we do the factorial times kval, so now that's 5 times 4 is 20, kVal becomes 3. We go back to the loop, right, 3 is still greater than 1. Factorial is 20 times 3, which is 60. Right kVal becomes 2, 2 is still greater than 1. Factorial then is 60 times 2, 120. KVal now decrements down to 1 and we check our while loop. One is not greater than 1, so falls through, and then it would print the value 120. Notice we're using a block statement here in a while loop, because the while loop itself will only execute one statement unless you put it in a block. To kind of give an example of that, there's a way we could actually write this same code to do the work without using a block statement. If we set this up, right again, kVal is 5, factorial is 1. We do our loop, kVal greater than 1, and then the statement we executed simply factorial times equals kVal minus minus, the decrement operator. In this case, we're now performing the exact same work, but we didn't have to use a block statement because now we can just go ahead and print it out. So we'll repeatedly execute that factorial times equals kVal minus minus until kVal gets down to 1. Another form of loop is a do‑while loop. The do‑while loop repeatedly executes a statement, as long as the condition is true, but unlike the while loop, it checks the condition at the end of the loop. So when we look at the layout for it, we have the do keyword. The statement would execute the while keyword and then the condition. Now because it checks the condition at the end of the loop, the body of the do‑while always executes at least once. So I see some code here. If I set this up and I have some integer value, iVal set to 5, my do in place, now I'm going to execute multiple statements. So I'm going to set up a block. Then inside of here, I'm going to go ahead and print out iVal. You'll notice now, most of the time up until now we've called print line, println, in this case we called just print. And what that does is when we print the value out, it prints it and doesn't go to a new line. All right, so now if I print out after that, * 2 =, it'll actually put that on the same line. So now I go ahead and calculate iVal times equals 2, which now makes iVal 10. When I print line that, now I get 10 displayed and the next thing I print will be on a new line. So I'll go ahead and close my loop here. And now I can just kind of walk this loop over and over again. The last thing I need to do, of course, is include the condition. So I'm going to stay in this loop as long as iVal is less than 100. So we know currently iVal is 10. So the next pass through the loop, it's going to print out 10 times two equals 20, so iVal is now 20, so less than 100. Twenty times 2 is 40, 40 is still less than 100. Forty times 2 is 80, 80 is still less than 100. And now 80 times 2 equals 160, but now iVal is now not less than 100, it's greater than 100, 160, so our code ends. Now the key difference here from the while loop is that it will always execute at least once. Right, so if I initialize iVal instead of being 5 to be something like 150, right, it will still go through the loop 1 time, printing out 150 times 2 equals 300. The last of the basic loops we're going to look at here is the for loop. Just like the others, it repeatedly executes a statement as long as the condition is true and condition is checked at the start of the loop, right, very much like the while loop. And really what it is is the for loop is more of a convenience layout for a while loop. Let's look at a very common while loop behavior. If we want to set up a while loop, the first thing we do is initialize some value, in this case, it's iVal. And then that while loop, we would check a condition, in this case iVal less than 100. We would then do some work inside that loop, like print something out, and then we would update our loop control variable. Right, we would actually, in this case, times equals 2. Right, that's something we do very, very frequently. So the for loop provides a simplified notation for this scenario. We use the for loop, we used the for keyword, then within the parentheses, we initialize things, we have our condition for being in the loop, and we have a place to update the loop control. And then, of course, that executes our statement. So to see an example of that, we start out with our for keyword in the parentheses, we do the initialization, iVal = 1, we have our condition, iVal less than 100. Notice that each of these sections are separated by a semicolon. And then we have our update, iVal times equals 2. And then in the body of the loop, we print out iVal. All right, so this while loop and the for loop both do the exact same thing. All right, the for loop just makes that standard behavior of initialization, condition, and update a bit more simplified. Just as all the loops, if you want to actually execute multiple statements, you can put it in a block. All right, so just here for notation, we could have an opening bracket and a closing bracket, and we could place as many statements inside there as we need to.

Arrays
Arrays are a really important part of Java. Their formal definition is that they provide an order collection of elements. What that really means is that they allow us to store multiple values of a common type under a single name. So if we do something like float theVals, but you notice that we've got that square bracket right after float that indicates that we're declaring theVals as an array. So that allocates out a name now that can access an array, and then we use this keyword new, and then float[3]. What this says is actually allocate space to store three float values, and they're all accessible under this one name, theVals. Now each of the members or elements of the array are accessed through an index, and the index is zero based. So, basically, the indexes run from 0 to 1 less than the number of elements. So in this case, we'd have our first one is 0, then 1, then 2. So using that, we can now put values in and get the values from the array. So if I say theVals[0] = 10, well, that stores 10 in the 0's position. Then theVals[1] is 20 puts 20 in the 1 position, and then theVals[2] is 15 puts 15 in the number 2 position. So let's say I want to do something like go through this array and add everything up. Well, if we're going to add them up, we're going to allocate some space to store the result called sum. The beauty of arrays is it makes it very easy to move through these values using loops. And one of the questions, of course, is we have to know how many spaces to walk through. Well, arrays expose a value called length to tell us how many elements are in there. So I can write a loop like for(int i = 0) as long as i is less than theVals.length, well, that will walk through each element as long as I increment i by 1 each time, which we've done here. So I can sum up the values in this array by simply sum += theVals[i], each passed as a loop, I'll go through a different element, the 0s first, and then the number 2 element. Then I can, of course, print out that sum. Now you notice here that this process of allocating the array and initializing it is pretty cumbersome. It takes a lot to do that, and that's something we might want to do very often in a program. So Java makes it very easy to create a shorthand for that so that after we declare the array name, we can use an open bracket and then just list the values and then close it. And that has the same effect; it automatically allocates the right number of spaces, in this case three, and initializes the value in each one of those spaces.

For-each Loop
One of the most convenient ways to walk through the members of an array is the for‑each loop, also know as an enhanced for loop. And what it does is it takes care of just executing that loop or the statement within the loop, once for each member in the array. So basically, it's just a for keyword, and we have parentheses, but rather than having explicit conditions or array initializations, we actually just put the array in there, preceded by a colon, and then we declare a variable to hold an individual array member, and then we can walk through the body of our loop. It'll go through once for each member of the array. And it takes care of handling the details of getting the length of the array, as well as accessing each of the values. Later in the course we'll see that a for‑each loop can also work with other special data types other than arrays, but of the types we've talked about so far, arrays are the only thing it works with. Now, to see it in action, imagine we have the scenario again where we've got an array of values. In this case, we've got three values, 10.0, 20.0, and 15.0, and we want to sum them up just like we've done before. Well, rather than an array in that explicit for loop where we set up an index variable, incriminate ourselves, keep testing its condition, with the for‑each loop, we can just set up the for, say that, well, I know that array has floats in it, have the colon, and then we have theVals. We simply have the array name there. And now, inside the body of our loop here, we can simply say sum += currentVal. And what'll happen is that the first time through that loop, currentVal will have a value of 10.0, which would make sum 10.0. Next time you come around the loop, currentVal will have a value of 20.0, making your sum 30.0. Next time through the loop, currentVal will have a value of 15.0, making our sum 45.0, so we would print out 45.0.

Switch Statement
Switch transfers control to a particular statement based on a value. And really what its purpose in life is is to simplify the idea of testing against multiple matches. So you set up the switch keyword, you put in the value you want to test, note this is not a condition. It's the value you want to test, and then you go through, inside of a set of brackets, the word case and the different values you want to match against, and then the statement you want to run if it matches against that value, then the word case again and another value you want to match against and those statements. Repeat that as many times as you'd like. Now of the primitive types we've talked about, only char and integers can be used with a switch. Later in the course, we'll learn other types that can work with a switch. But of those we've talked about so far, only char and integer types can be used. One thing to notice is that a match can execute more than one statement. Notice that under the case there, I don't have the word statement. I have statements, plural, because you can list many statements underneath of that case keyword. And, in fact, the way that switch works is that once it matches against the case, it will keep running all the statements from below that case all the way to the end of the switch statement. So we have to use the break keyword to prevent what we call falling through, in other words falling through from one case to the next. We'll see an example of that in the next line. Now in addition to matching against specific values, we can also put in a default keyword if we want which will handle any unmatched values, and all we do is we put that at the end of the switch, we use the keyword default, followed by a colon, and any statements we want to run there. So let's see an example of using switch. We have some code here, and we have an integer field iVal, which we've set to 10. And in our switch, I'm going to put iVal % 2, which says to take iVal, divide it by 2, and give me back the remainder. Well, if you divide a whole number by 2, it's always going to be either 0 or 1. So it's a great way to just test if a value is odd or even. So what I'll do here is I have a case, put a value of 0. So all even numbers will have a value of 0. So I'll print out that whatever the value is is even. Well, let's go ahead and put in a case for 1, so that would be our odd values. And then I'll go ahead and put a default in place, and I'll say, "oops it broke" because we should certainly never see the value of this default because all whole numbers are going to either be odd or even right. So if we run this code now, it'll go through, it will take 10, it will divide it by 2. The remainder will be 0, so it'll match the case for 0. So when I run it, it'll actually print out "10 is even." But what would happen then it would then print out "10 is odd," and then "oops it broke" because what's happening is that once it matched on that case of 0, it's now running all the statements below that. So all those different print out, prints, and printlns are being run. The way we prevent that is with the break keyword. So what we can do is that at the end of each case block or each case section, we'll put in the keyword break, which says, Run until you reach this point, and then jump out of the switch statement. So we'll do that for our case of 1, and we'll also go ahead and do that even for the default. The default is the last section, so technically you don't need to have a break there. But it's considered good programming practice. It's especially useful for situations like if you refactor your code, and that default becomes an actual case or something later. So it's just a good programming practice for each of those sections to put a break at the end. So now if we run this, we'll take our 10, 10 % 2 is 0, it matches on the 0, and it prints out just the "10 is even." If we take that iVal there and say we change it to something like 25, well, now we run it, 25 % 2 is 1. It'll match on that, and it prints out that "25 is odd."

Demo: CalcEngine with Arrays, Loop, and Switch
Let's revisit our CalcEngine demo, and now we'll actually add arrays and a loop so that rather than processing one value at a time, you can process multiple values. We'll also use a switch statement to take that complex if else we have in there and make it much cleaner. To update our program to process multiple values at a time, what we'll do is we'll take each of these four declarations at the top and convert them into arrays. So we'll take the first on, so our first one there val1. Let's make that a double array, and instead of calling it val1, we'll call it leftVals. And then we'll initialize it with, say, four values. So we have that. So now what we'll do is we'll replace val2 with something called rightVals, and we'll initialize it with same number of values. And now we'll have opCode. Instead of calling opCode, we'll call it opCodes, so this will be a char array. So we now have each of those initialized with four values, and, of course, want to store those in our result, and we'll do that as an array, so we'll make our result a double array as well. In this case, I'm calling it results, plural, because it can hold multiples. Now I don't want initialize this one with a value. I want to initialize it with space to hold the different results. So what I want to do is use the new and say double. And now for the size, I could set it as a fixed size of 4, but really I want it to kind of be the same size as like opCodes is. So what I'll do is I'll just use opCodes.length, and that now sets me up with the results being the same size as opCodes. And what we have here is these four arrays are what we call parallel arrays, and that idea is that when you set up multiple arrays where the first value on each one works together, the second value on each one works together, and so forth, right? So we'll have 100 from leftVals be used with 50 from rightVals. We'll use the d from opCodes and then store that in the very first position in our results array. So let's go ahead and comment that out, these other ones here, the only ones we're not using anymore. Okay, so they're all gone. So now what I want to do is loop through these values and use them, right? And so, because I'm using the same position from each one of these, I'm going to use a for loop where I actually increment an index, and I use that same index for each one of the arrays. Where I also have a for, I'll just say int i = 0. I'll run while I is less than opCodes.length. And then I'll want to incriminate i each time. I want to include the whole if statement underneath here, so I'm going to go ahead and put brackets around that. Now I need to go through an update each one of these, right? So instead of saying opCode, I want to use opCodes sub i. So I'm going to compare that against a. And then, of course, result will be results sub i, and that's going to equal leftVals sub i plus rightVals sub i. I'm going to do the same thing for the opCode of s. Now we get to d for the divide, initially that's the same, right, opCodes sub i, but now I want to just make sure that we change everything we need to because we actually check val2, as well as use it, so we want to make sure we make val2 on the right val sub i throughout this whole thing. And of course, val1 is leftVal, and, of course, our result is results. So now we have our results of i equals rightVals sub i not equal to 0, then it's leftVals sub i divided by rightVals sub i; otherwise, it's 0. Then we get down here to our opCode m. It's going to be just like it was with a and s. And then the last thing is just to make sure that our l statement uses result sub i. All right, so now we have a for loop here set up to go through each one of the arrays, execute the operation, store the value in results. So now that we've done that, let's go ahead and set up another loop to print out the results. Now, in this case, what I want to do is just go through that results array. And I'm using just that one array in this case, so this is a great time to use the for each statement, right? So I'll just say for double theResult :, and then I'll just say results. And I can update this print statement down here to use theResult. And if I want to get fancy, I can go ahead and make this guy a block statement, and maybe I'll print out something like result =. All right, so we have that all set, so let's go ahead and run it and make sure it works. And we go through and we get our values out. And so we've got our values of 2.0, 117, 208, and 33. And if I go up here, 100 divided by 50 is to 2, 25 added to 92 is 117, 225 minus 17 is 208, and 11 times 3 is 33, so it works just fine. So now let's go in here and take a look where we have this if statement. We have this big if else here. This is a perfect example of a good time to use the switch statement. And we're checking opCodes sub i each time, exactly what switch is meant for. And what I'm going to switch on is opCodes sub i. I'm going to put the brackets at the end of the switch. I'm going to put it down here at the end of this else. And we've got a lot of errors showing up here, but we'll go ahead and clean that up. So what I want to do here is now is that in each one of these ifs, that becomes a case statement. So here for a, I'm just going to make this case, jump to the end, take that last parenthesis, make that a colon, do the same thing for s, as well as d and m. And then where we have our else here, we're going to go ahead and make that a default. Now we end up with an extra bracket here because that's left over from the old else block that was here, so we'll take that off. All right, so now we have this set up to use a switch statement. So we come through an opCodes, check opCodes sub i, and we say case, well, if it's a, do the add, case s, do the subtract, d is divide, of course, m is multiply. If they don't match up, we print out our error message and set results to 0. Let's go ahead and run this, and notice what happens. We see that error message invalid opCode print out each time, and result is set to 0 each time. That's because we're falling through our case statements. Remember that once there's a match, it then runs all the statements after it, right? So in the case of when the a matched, it ran the proper instruction of adding them, but then it dropped down through the s and ran the subtraction, dropped down through the d, ran the divide, dropped down through the m, ran the multiply, and then dropped down through the default and printed the error message. So what you do here is go into each one of these and add a break statement. So we now have our break statement for all the cases, and let's scroll down, and let's go ahead from just a good style standpoint and add a break to the default as well. And so now when we go and run this, we get the right answers again because the break made sure we only ran the code we wanted to run and then broke out of the switch statement. And so now we have our application enhanced quite a bit here. We can process multiple values, it's much more readable with the case statement, so we're definitely moving forward in making this a much richer application.

Summary
We covered a ton of stuff in this module. Let's take a look at some of the highlights. Remember that we used the if‑else statement to provide conditional logic in our applications that relied on things like relational operators and logical operators. And remember that we can chain if‑elses together if we need to work through multiple possibilities. We rely on block statements a lot. They used brackets to group statements together, and so they're really key for working with things like the if statement or the loops. Remember, though, that any variable declared inside of a block is not visible outside of that block. Both the while and the do‑while loops execute as long as a condition is true, the difference is when they test a condition. While checks at the beginning, do‑while checks at the end. As a result, do‑while loops always execute their body at least once. The for loop provides a simplified notation for dealing with loop initialization and control. The for‑each statement goes even further because it handles all the details of executing the body of the loop once for each member of an array. And then, finally, the switch statement was really useful for those scenarios where you want to test against multiple possible matches. Remember, though, that of the primitive types we've talked about, it can only be used with char and integer types.

Representing Complex Types with Classes
Introduction
Welcome to the next module of our Java Fundamentals course on the Java language. In this module, we'll look at how we represent complex types using classes. My name is Jim Wilson. In this module, we start digging into the object‑oriented aspects of Java. So we'll first look at classes, how we create them, and how we use them. We'll then look at the concept of classes being reference types and how that makes them behave differently than primitive types. We'll look at the idea of encapsulation, in other words, how do we keep the details of our classes inside of her classes and not the concern of those using the classes. We'll look at the basic behavior and creation of methods in Java. And then we'll look at how we control interaction with the data in our classes using field accessors and mutators.

Classes
Java is an object‑oriented language. And that means, of course, that it follows the tenants of object‑oriented programming. And so objects of these things encapsulate the data, operations, and usage semantics. In other words is that what you want to work on and how you work with it are kind of packaged up with this idea of on object. Objects allow the storage and manipulation details of things to be hidden so that when someone's working with an object, they focus on what they want to have done. It's not their concern on how it's done. The class implementer of the object implementer actually focuses on the How. The consumer or user just focuses on the What. So that's a really powerful idea that allows us to build more complex programs. The way we get to objects in Java is through classes. Classes provide a structure for describing and creating our objects. In other words, the classes are the things that we use to be able to describe our objects and then be able to instantiate them and bring them into existence to be worked with. Basically, a class is a template for creating an object. So the idea is that when we want to declare a class, we use the class keyword followed by the class name. Now, normally, when we create our classes, we put them in their own source file, and that source file will have the same name as the class itself. There are some caveats to that that we'll talk about shortly, but in most cases, your source file name will simply be the class name.java. Now the body of the class is then just contained inside of brackets. You have an opening bracket and a closing bracket. And that's where the contents of the class are going to go, all inside of there. Now we mentioned that classes have both the state and what we want to do with it. So the idea is that a class has the data inside of it and all of it's excusable code. So this captures kind of three general ideas that the state itself is in what we call fields. As we look at our class flight we've declared here, it's got two fields in it. They're both integers, one for passengers and one for seats. Classes also have methods. This is the executable code that's going to manipulate the state and perform any operations. And so in this case, our class has a method called addOnePassenger. And, basically, when someone calls that, it makes sure that there's enough seats available. As long as there is, it goes ahead and adds another passenger. And then there's what are called constructors. Constructors are kind of a special case executable code. This is code that gets run during the creation of an object largely to set the initial state. So we've got here a constructor that basically starts out by setting seats to 150 and our passengers to 0. So, basically, it means that when we create a flight, that flight has 150 seats on it.

Using Classes
When you're ready to use a class, as you would expect, you would go ahead and declare a variable. The thing we've got to be aware of though is that declaring a variable simply allocates space to store what we call a reference to the actual object we want to use. To actually create an instance of our class, otherwise known as an object, we have to use the new keyword. So what we do, we've got our variable, nycToSf, we assign that the value of newFlight. What that then does is the call to newFlight allocates the memory associated with that class, and then returns back a reference to it. So what that means then is that that variable nycToSf is not the object itself, but a reference to the object. Now each instance that we create will be separate from one another, and then as you see here that I've actually declared the variable and then assigned the object to it in two separate statements. We can, of course, do that in a single statement. So I've got a variable slcToDallas equals newFlight that allocates out the slcToDallas, which is a space for the reference, creates the instance of Flight and assigns the reference to our variable. So each of these are two distinct instances of our Flight object in each of their own variables. And we can then call a method on one of those instances, in this case we'll call add1Passenger on our slcToDallas, which will cause our passengers to go from 0 to 1. As we saw when we were using our classes and creating class instances, these objects, we saw that the variable wasn't the object itself, and so that was a reference to the object, and that tells us that we're working with reference types. And that has some important implications when it comes to working with objects. So we look at some code here, if I declare a variable flight1 that points to a new Flight, that allocates out the variable flight1, allocates out the instance of our object and puts a reference to that object into flight1. And do the same thing for flight2, right, that creates a separate object and assigns it into a separate variable, flight2. So those two objects are completely separate from one another, right? So if I call, add1Passenger on flight2, the object instance pointed to by flight2 will have its passengers incremented from 0 to 1, so, of course, if I print out flight2 passengers, it prints out 1. Now, if I assign flight1 to flight2, that doesn't copy the entire object pointed to by flight1 and flight2, all that does was reassigned the reference, so that flight2, instead of pointing to the object it currently points to, will now point to the same object that flight1 points to. So now once that object pointed to by flight2 or previously pointed to by flight2 is no longer referenced, that object goes away and flight2 and flight1 are pointing now to the exact same object. If I now print out flight2.passengers, it prints out 0, because that's the value of passengers in the object it's pointing to. So now if I work through flight1, and I say add1Passenger, where that increments passengers from 0 to 1, of course, if I then call add1Passenger again on flight1, that increments it from 1 to 2. So now if I print out flight2.passengers, I get out the value 2, I print out the value 2. Alright, so it's important to understand that when we make these assignments, we're assigning references around not entire objects, right? This is very different from when we were working with primitive types where the values were actually copied around. So it's really important. to understand that, that as reference types, assignments cause us to point to the same object instances as opposed to making complete copies.

Encapsulation and Access Modifiers
Since Java is an object‑oriented language, we want to use good object‑oriented techniques when we build our programs. Remember that one of things we talked about is that when you consume an object or when you use an object, you want to be able to think more about the what of what you're doing, not the how of what you're doing. And so an important idea in there is that as we build our objects, the internal representation of those objects should generally be hidden. The user of an object shouldn't have to know a whole lot about the way that object is built. And so the idea of hiding this internal representation is an idea we call encapsulation. And in Java, the way we achieve encapsulation is by using access modifiers. Let's look at some of the most basic access modifiers. Now the most basic access modifier at all is to have no access modifier. And in fact, that's what we've been doing up until now. If it class or a class member does not have an access modifier on it, then it's considered what we call package private, only usable within its own package. We'll talk more about that one later in the course when we spend more time on packages. Now one of the ones we commonly see is the public access modifier. And if a class or a class member is marked as public, that means it can just be used anywhere, anywhere at all in the program. And the last one we're going to talk about for now is one called private. If a class member is marked as private, it's only accessible from within the class where it's declared. Now top level classes, the kind of classes that we're working with right now, cannot use the private access modifier. A little later in the course, we'll talk about some scenarios with nested classes where we can use the private access modifier.

Applying Access Modifiers
Let's take a look at how the access modifiers affect the uses of our class and its class members. I have here basically the same class we looked at earlier. We have our class flight. It has some fields declared at the top, passengers and seats. It has a constructor. It then has a method, addOnePassenger. And I've also added another method to this called handleTooMany that gets called from addOnePassenger, the idea being that when we call addOnePassenger, if there's not enough seats, addOnePassenger will call handleTooMany to do whatever we want to have happen when we have too many passengers. So now let's take this, and we'll go ahead and add a public access modifier to class Flight. Now what that means, of course, is that we're now allowed to access class Flight from anywhere. So we can go out there and declare our variable called flight1 of type Flight. I'm going to go ahead and mark the constructor as public as well, which means I'm also allowed to now create instances of this class. We'll talk more about constructors shortly. The key thing here is that we are allowed to create instances of the Flight class. Now let's take our two fields, passengers and seats, and we'll mark those as private. Now as private, they're accessible from within the class. So inside of our constructor, we're allowed to access them. Inside that method addOnePassenger, we're allowed to access them. That's fine. But from outside the class, if we try to do something like we did earlier, like print out the value of passengers, that's no longer allowed. That would actually be a compile time error. So we wouldn't be allowed to have that code in our program accessing it from outside the class. Now looking at our methods, let's say we mark addOnePassenger as public and handleTooMany as private. Well, from outside the class, I'm free to call addOnePassenger. That calls into addOnePassenger. AddOnePassenter checks the number of seats. If they're already full, it actually would call down to handleTooMany. And that would be just fine because we're accessing the handleTooMany from inside of our Flight class. But if from the outside, we try to call handleTooMany, again, that would be a compile time error. We're not allowed to access it from outside of the class. Now one thing to note, now that our class is marked as public, remember that earlier I mentioned that the class file for class normally has the same name as the class. Well, once we mark this class as public, that becomes a requirement. Public classes have to be inside of a source file with same name. So a public class called Flight has to be in a source file called Flight.java. Now if it's not marked as public, that requirement is not in place. You're allowed to name a file whatever you want. You always want to be careful about choosing to name the class file something different than a class. There are legitimate reasons to do so, but just consider that carefully.

Naming Classes
This is a great time for us just to take a minute and look at the rules and conventions for creating class names. Now, class names have the same rules as variable names in terms of what characters are allowed, and they actually even follow most of the same conventions. They still use only letters and numbers. The first character is always a letter, but one of the key differences in conventions is they follow a naming pattern called Pascal Case, which says that the first letter of every word, including the first word, is upper case, with all the rest being lower case. So if we have a class name like BankAccount, both the B in bank and the A in account are both capital. Right, and if that was a variable name, the B would have been lowercase, and what we want to do is that when we're naming our classes, we want to use descriptive nouns, so we want to say things like a class called Person, right, or class TrainingVideo, and in general we want to avoid abbreviations, we want to use full words. Now the caveat to that would be any scenario where the abbreviation tends to be more widely used in the word itself, like people rarely say Uniform Resource Locator, using URL is much more common.

Method Basics
Now we've mentioned that methods are basically just executable code that we can use to manipulate the state of our objects and perform operations. Basically, each method has a name. Now the rules for creating method names are the same as they where with variables. One of things we normally do from a stylistic standpoint though is use a verb or some kind of action statement to name our methods. Now, methods have a return type, and in Java there's always a return type. So if a method doesn't return anything, then that return type is void. And then a method can have parameters. And so parameters start with a parenthesis after the method name. You then list the parameters close the parenthesis. And then the body of the method is enclosed in brackets with however many statements it takes to build your method. Now note that these brackets are not a statement block. They're always required. Even if your method only had one statement, that statement goes inside of brackets in a method. All right, so to see an example, let's create a really simple method here, and we'll have it not return any any values. We'll make it a void method. And let's say we'll call this guy showSum. And let's say what we want this method to do is maybe take two floating‑point values, add them up, and then it'll print out that value multiple times. So it'll be three parameters here. So we have our open paren, so let's say I have a float x, a comma to separate it from the next parameter, a float y, a comma to separate it from the next parameter, and then an int count. So the idea is that we'll add x to y and then print that result out count number of times. So we'll close the parentheses, we'll then put our brackets in place for the body, and they we'll do the work. So we'll add x plus y to get sum, we'll create a loop that counts from 0 and is incrementing i each time as long as it's less than count, and then prints that value out. So now when it comes time to use this method, the first thing we want to do is let's just go ahead and just wrap it up inside of a class, because all methods are inside of classes. We'll go ahead and make her method public so we can access it. And then put together some code that will first create an instance of our object, and then we're going to say object instance name, which is m.showSum, calling the method, and we're going to pass in 7.5, 1.4, and 3. So the 7.5 will go into x, the 1.4 goes in the y, and the 3 goes into count. So what would happen then is that sum will become 7.5 plus 1.48, 8.9, and then we'll go inside of our loop and print that out three times, so we would see 8.9 printed out three times.

Exiting from a Method
Looking at that method we created in the last clip, basically, we call into the method, the method runs until it's done, and then it exits. Well, there are actually three reasons a method will exit. One is that it reaches the end of the method, which is the case in our showSum method here. You can also put a return statement in to indicate that you want to exit. And there's a third scenario, which is when an error occurs. Now, we're going to talk a lot more about the way the error situation is handled when we get to the module on exceptions. For now, we're going to focus on these first two scenarios, reaching the end of the method or having a return statement. So when a method is done, it returns back to wherever it was called from. So in the case of a little showSum function here, we have our code where we created the class instance, and then we called showSum. If we add another instruction after that to print out a message like, I'm back, what's going to happen is that when we call m.showSum, that's going to pass control into our showSum method, it will do its work, which is print out that 8.9 three times, and the control is getting passed back up to the caller, which will pass control to that println I'm back, which then prints that message out. Now, if we wanted to, we could put a return statement here at the end, and it would actually work exactly the same. In that case, we'll be exiting because it hit the return instead of the end of the method. And in this scenario it doesn't change anything. But the return statement does not have to go at the end of the method. Imagine if we had a slightly different call here, is that when we call showSum, instead of passing 3 as the last parameter we passed a 0. Well, what would happen in that case is we'd call into showSum, we would do the work to add the numbers together, and then our print statement wouldn't do anything. So, basically, our showSum method would actually have no real results. Now, in this case, we're just doing something very simple, adding, but in many methods, you may be doing a lot of work that you end up not using, so it is often useful to check your parameters at the very beginning of a method, and if certain aren't met, you just go ahead and exit. So if we actually go ahead and make a little more room in our method here, what we might do it the very beginning is say, well, if count is less than 1, well, we know we're not going to do anything, so we're just going to go ahead and return. So in this case, what would happen is we call showSum, control is passed into showSum, we check count, which is 0, so we simply exit back out and print I'm back. We end up not doing all that work that we weren't going to use anyway. So the return statements can be placed anywhere inside your method that makes sense for the work that you're doing.

Method Return Values
When a method returns that method's not void, then it actually returns a value. And a method always returns just a single value, and that value can be a primitive type, like a float, a short, a boolean. It can also be a reference to an object. And it can even be a reference to an array because in Java, arrays are objects. So let's take a look that Flight class we've been working with. Now remember that it has two fields in it, passengers and seats. And for now, I'm not going to show the other methods we've seen already. I want to focus on some new methods we're going to add here. So let's say we have a method that we want to check and see that is there room to combine the passengers from another flight with those passengers on this flight. So as you know, we pass in a parameter, which is the other flight we'll call f2. And our return type is boolean. So what we can say here is that we'll figure out the total number of passengers, so how many passengers do we have, with how many passengers does the other flight have, and then we check and see. Well if that total is less than or equal to the number of seats we have, we'll return true. Otherwise, we'll return false. So in this case, it's a method returning back a boolean variable. Notice the code we're using for our return value here. If total <= to seats resolves to true, we then return true. If total <= seats resolves to false, we return false. Well, rather than actually have the if then the return, why don't we just use that value directly? So what we do is we we can replace that if statement by simply saying return total <= seats. Whatever that resolves to will be our return value. So let's make a little more room here since we got rid of some of that code. Let's create another method here. This method we'll call createNewWithBoth. And you notice that this one returns back a reference to a Flight object. And the idea here is that it will actually create a brand new flight that combines the passenger counts from the current flight and that Flight f2 that's passed in. So what we'll do here is we'll create a new instance of the Flight object. We will then say the number of seats in that new flight is equal to the number of seats that our current Flight object has. And then the number of passengers is the combined of our passengers and the other flight. And then we'll just return back this newly created flight. We're returning back a reference to this new flight that we created. So to use this in code, what we'll do is let's go ahead and declare one flight instance. That will be a flight to LAX, to Los Angeles. That will be our Flight lax1. We'll create another flight to Los Angeles, lax2. And we'll say that we just run some code that adds passengers to both of these flights. So upon some point when we get passed this comment, both lax1 and lax2 have some number of passengers. So what I'm going to do is create a new flight reference. But notice I'm not creating a flight. It's just a flight reference. And what I want to do now is check to see that well, if there's room to combine lax1 and lax2's passengers, I want to go ahead and do that. So what I'll do here is have an if statement in place that says well, if lax1.hasRoom lax2. Remember that calls over to our hasRoom method. When we get into the hasRoom method, because we called hasRoom against the lax1 flight instance, anywhere we refer to the class where our variables passengers and seats, where they're unqualified, that means we're referring to the values that are currently in lax1. When we refer to passengers using the f2 reference, that's actually lax2's passengers because that's the one we passed into the parameter. So when we run this method, it basically adds those together. And then if there's room, it'll return back true. And if there's not, it'll return back false. And so then, we can go ahead and say lax3 = lax1.createNewWithBoth passing lax2. So now again, control transfers over to the createNewWithBoth. Again, because we called this against lax1, anywhere we use seats or passengers unqualified, those are the lax1 seats. F2 passengers will be the lax2 passengers. So in this code, we go and create that new Flight instance, assign it to the number of seats from lax1, the flight reference we were called against. And then the passengers are set to the value of lax1's passengers plus lax2's passengers, and then we return back that new flight. So lax3 will receive a reference to that newly created Flight instance returned back from the createNewWithBoth method.

Special References: this and null
Java includes some special reference variables that are important for us to understand. Now, one of these is the 'this' reference, and the 'this' reference allows you to refer to the current object. So it's useful for any time you want to be very explicit and indicate that you're referring to the current object, and it's also useful for cases where an object may need to pass references to itself to other methods. We'll see this used a lot throughout the course, but let's look at a simple example. Remember that we have our Flight class and we have that method we just wrote called hasRoom. Now the hasRoom method uses data from the current instance and it also uses data from an instance passed in, f2. Alright, so we have our f2.passengers, which refers to the passengers of the instance passed in, and then our other passengers refers to the current instance's passengers, and this is completely valid the way we have this written. But if we wanted to make it more explicit that we were referring to the current instance passengers, what we could do is we could actually put 'this' in front of the passengers on the left, saying that we're referring to this one inside of the current instance, right, so it allows us to get rid of that ambiguity and make our code more clear. There are other cases that maybe we had a local variable or something that maybe had a name collision with a member field. We could also use this to disambiguate that. We'll see an example of that shortly later in this module. Another special reference is the null reference, and this is a literal. And null refers to an uncreated object, and you can assign it to any reference variable. And you want to really just use it to say that, hey, this reference variable isn't pointing to anything yet. So if we take a look at some code here, remember that we wrote that code earlier where we declared our two flights, lax1 and lax2, and then we're going to have our other flight, lax3, that if there was room, we would assign a new flight instance to with the combined passengers of lax1 and lax2. Well, this code as it's written kind of creates a problem, right? It knows that our flight lax3, well, if there wasn't room to combine them, lax3 could end up potentially set to nothing. We learned earlier that local variables cannot be uninitialized, so we need to initialize lax3 to something, and we want to initialize it to no object, so that's where null comes in. So what we can do here is that simply say, flight lax3 equals null. So now it's initialized to point to no object all. So let's say that later in our program we do some work and we want to know if lax3 was actually assigned a flight or not. Well, we can actually compare lax3 to null, so we're saying, well, if lax3 is not equal to null. In other words, is lax3 no longer pointing to nothing? Does it point to something? Well, and if it does, we know the flights were combined, so we could print that value out.

Demo: CalcEngine with Classes and Methods
revisit our CalcEngine demo, and update it to use classes and methods. Here we are in our CalcEngine program as we left it at the end of the last model. Remember what we had done was create four parallel arrays, one with the left values, one with right values, one with the opCodes for the operations we want to perform, and then an array to hold the results. And the way we create a commonality across these arrays was that we said that, well, the first member of each array corresponds to the first member in every other array, same for the second, third, and fourth members. A much better way to represent this idea of related values is to use classes. So let's go ahead and add a class to our project here. Now I'm going to go ahead and use the IDEs ability to create a class for us. All it's going to do is create a class file and put the class definition inside of it all. All the major IDEs support this concept, and they all pretty much do it almost the same way. All I'm going to do here is go to my package name, alright, com.pluralsight.calcengine, right‑click on it, say New, take Java Class, and give it the name of the class. So let's call our class MathEquation. I'm going to go ahead and just tell it to go and create it. And what that does is create a source file named MathEquation.java, and put a public class declaration inside of it. Right now, what I want to do inside of here is create fields for each of the values that I need to keep track of. Alright, so if I go back to Main for just a second here, basically I'm going to create fields for leftVals, rightVals, opCodes, and results. Alright, so we go back inside of here, all you need to do is make the space to do that. Alright, so first I'll do leftVal, so I just made it a public double and called it leftVal, very similar to what it was called in the old program. Do the same thing for a rightVal, our opCode, and our result. So now I have the ability to store all those values together inside this one class. Let's head back to the Main program. Now if we look at the Main program, inside of here there's this great big switch statement, and this is, this is kind of broken in terms of the fact that the program has to know a whole lot about how these operations work. The reality is the program just wants to have the work done, so this switch statement could really be moved out of here, and let's move it into our class, and so we can wrap it up inside of a simple method.Alright, so I'm going to go ahead and cut that away, go back to my equation, and let's add a public method on here called execute. Notice that I've marked a method void, saying it doesn't return any values. And in fact, it's not going take any parameters either. So I'm just going to go ahead and put the code block inside of here. What I'll do now is I'll paste that switch statement inside of this execute method. Now, what I want to do now is just update it work on its own values. Alright, so the idea is on, for the first one here, for a, it's going to get rid of the sub scripts because I want to use opCodes as a declarative inside the class. Same thing for results, I'm just going to make that result, same thing for the leftVals and rightVals. So I get my results = leftVal + rightVal, that's using all the members. Here up here on the opCodes, I need to take that s off so it matches. Alright, so now the opCode matches up as well. So I'm now using, in the case of a, all of my member variables, opCode for the switch, then the result, leftVal, and rightVal. I'm going to do the same thing for all of the different cases and the default down here. So now my execute method knows how to perform all the operations using the member fields. So now the next thing I need to do is go ahead and start creating instances in my math equation. Alright, so I'm going to go back here to the Main program, and what we're going to do is get rid of all these arrays up here, I'm just going to go ahead and comment those out, and what we'll do instead is create an array of our MathEquation class. So we're just going to declare a MathEquation, put the array indicator on there. And we'll go ahead and call this equations, and set it equal to a new array of MathEquation. Now we've created the array of MathEquation. Now that creates the array itself, but I, I still need to create the individual MathEquation instances for each array member. So what I basically need to do is say something like equations sub 0 equals new MathEquation, and then go through and set each of the values, each of the fields, right, leftVals, rightVals, and opCodes. Now since I'm going to have to do that four times, it gives us another great chance to use a method. Alright, I can use a method to kind of encapsulate all that work of creating a new instance and setting all the values. So we're going to go ahead and create that here inside of my Main class. Alright, so I'm going to create a new method here, and I'm just going to go ahead and call the method create. So I'll mark it as public. This uses a modifier called static that we haven't talked about yet. We'll revisit, we'll talk about that one little bit later in a course, let's just go ahead and put it in for now. And what our Create method is going to do is return back a new instance of MathEquation. So if the return type is MathEquation, and again we're going to call it Create, and what it will do is it accepts a parameter for each of the fields we want to set, right, leftVals, rightVals, and opsCodes. And so we have all the parameters there, let's just go ahead and put the brackets in place. So now what we're going to do inside of here is create a new instance of the MathEquation, so I'm going to declare MathEquation, we'll called it equation, and then new‑up the MathEquation. So that gives us our instance of the MathEquation. And what we want to do, let me just scroll down here so we can see a little better, alright, what we want to do is go through and set all of the fields that correspond to the parameters. So for leftVal, I'm going to say equation.leftVal equals leftVal. So it takes whatever that leftVal parameter is and sets the leftVal field on equation. We'll do the same thing for rightVal and opCode. With all the values set, the only thing left to do is return back our equation. So with that all set, what we can do is up here in the Main part where we create each one, rather an explicitly create them, we can instead call that Create method. So I'll do here is just call Create, and then pass in the values I want to use. So for leftVal on the first one, I'll use 100.0, then I'll use 50.0, and then the opCode d. And I'll do this same thing for the other three members. So now we have our MathEquation array created, and then we also have the individual MathEquation instances created into each one of the arrays. So I'm going to go ahead and get rid of this for statement here, we don't need that one anymore. What I'll do here is that where we had this for each where we're going through the results before, what we can do now is go to that MathEquation array. Alright, so I'll go ahead and declare is MathEquation, I'll call the variable equation, and what it will loop through is equations. So now what I can do inside of here is for each one, I can simply say equation.Execute. What that'll do then is when I call equation.Execute, right, for each one, each of the sets of values, it'll go into MathEquation, call execute, check the opCode, perform the appropriate operation, store that in result. So when I go back here, what I can then print out a simply equation.result. Alright, and so now I have a much more encapsulated application here, right, in the sense that I have the idea of what I want to perform, modeled into my class MathEquation, alright, so it has the fields for each of things I need to perform the operations. The execute method does the actual work. If we go back to the application, the application doesn't care about any of those kinds of details, it simply creates each MathEquation instance, loops through them, tells each one to execute, and then displays the result. So if we go ahead and run this, we get our appropriate results out. Alright, is that 100 divided by 50 is 2, 25 plus 92 is 117, 225 minus 17 is 208, and 11 times 3 is 33.

Field Encapsulation, Accessors, and Mutators
Most of the time, we do not want to allow access to the fields within our classes from outside of that class. We want to hide those kind of details because the fields are a very fundamental part or very, kind of, low‑level part of the way a class solves a problem. And they're very likely to change over time. So we don't want to have those kind of details exposed outside of the class. That doesn't mean that we don't want to allow interaction with the information inside those fields from outside the class. So what we do is we generally use methods to control access to our fields. As you would expect, this is an issue that we have to address very frequently. So a common pattern, called the access or mutator pattern, has arisen to deal with that. Now, if you're not familiar with the term pattern, all that means is it's just kind of a common way we solve the problem. Let's take a look at our flight class we've been working with. We have a couple fields inside of here, passengers and seats. Let's say that we decide that, you know, we'd like to allow interaction with the seats values. Now again, we don't want to give them direct access to seats, we don't make that public, so what we'll do it is we'll use methods to address that. So what we do is we use what's called an accessor to get to the field value. It's often just called a getter. And what we do is we create a method, normally, that has the word get followed by the field name. Right, so the accessor for our seats would simply be getSeats. Notice that the return type is the same as the field itself and also notice that the method is following camel case, right, a lower case G for the first word, and an uppercase s for seats, the second word, right. Even though the field started with lower case s, that doesn't matter. We're going to use consistent camel casing as we name things. And all the accessor does is just return seats. So easy for the consumer or the class to get to the value, but we've got control. If we ever change the way we manage seats, that will not affect anyone using this class. To allow the value of seats to be modified, we use what's called a mutator, also known as a setter. As you might have guessed, the way we named that method is simply set and the field name. So a mutator for our seats field shows we have public void setSeats. Notice that the return type is void because the setter doesn't return anything back, and it has a parameter to receive the incoming value. So now inside of setSeats, what we want to do is set our field seats to have the value of that parameter. Now we have an interesting challenge here. Notice that we're saying seats = seats. Well, because on the right hand side, we want the one that's the parameter, on the left hand side, we want the one that is the field. This is a great time to use this. Right, by putting this in front of the seats in the left that says that I want the field seats to receive the value of the parameter seats. All right, if we go ahead and set up some code and we create an instance of our flight, if I want to set the number of seats, I simply call our slcToNyc reference against setSeats, pass in 150, that would set the value of seats to be 150. To get the value back, I simply call getSeats against slcToNyc, and returns back the value we set, 150.

Demo: CalcEngine with Accessor and Mutators
In this demo, we'll add accessors and mutators to our CalcEngine app. And we'll look at how to deal with situations where we may want to provide the ability to see a value, but not modify a value. So here we are back in our CalcEngine app, and I'm here in the MathEquation class, and we have our four fields at the top that are all currently public. Now the first thing we want to do is go ahead and make these guys all private. So with the values all private, now we can go ahead and add our accessors and our mutators, and this is going to be really straightforward. Let's go ahead and let's look first at doing it for leftVal. So for leftVal, go ahead and make it public. Return value will be the same as leftVal, which is double. We'll call it getLeftVal. And all that does is simply return back leftVal. So that gives us an accessor for leftVal. For our mutator, again it'll be public. This time it'll be void though because mutators don't return a value. It'll be setLeftVal and will accept a parameter of type double we'll call leftVal. And then from there, we simply assign the parameter to our field. So that's pretty straightforward. And we're going to do that for rightVal and opCode as well. So with those accessors and mutators in place, we can set the values of any of those, as well as access them. And that makes sense for leftVal, rightVal, and opCode, but result's a little different. Result is the result of this class doing what it does, executing an operation. So it doesn't really make sense for anyone to be able to modify result from the outside. They certainly should be able to see it, but not modify it. So this is a case where we may want to have an accessor, but not a mutator. What it does is, in effect, make our result a read‑only value. So what we'll do is for our result, we'll go ahead and create that accessor, but we're not going to have a mutator. And so with that, we can now just go ahead and update our application and go ahead and use the accessors and mutators we've created. So down here where we create each MathEquation instance, we'll just update these to use the mutator. So I'll say setLeftVal. We pass the leftVal as a parameter, close those parentheses, and do the same thing for rightVal and opCode. So that now creates the instance of the MathEquation, setting each of the values. Then we head over here where we access the result, we'll change that to use the accessor for result. So we'll just make this getResult. Alright, so let's go ahead and run it and make sure everything works. And there we have our output values. So we've now updated our MathEquation class, so we're properly hiding the data inside of it, which will allow us to evolve it more effectively over time without impacting code that uses our class.

Summary
In this module, we started introducing the object‑oriented aspects of Java. That means that we started talking about classes because classes are the way we describe our object. They're the template for creating an object. We used the class keyword to declare them. We used the new keyword to create instances of them. Remember that classes create reference types, meaning that if we have a variable that's a type of a class, the variable doesn't actually hold the class instance itself. It holds a reference to the class instance. That's really important because when we assign between two variables, we don't copy the object. We copy the reference, causing the two variables to point to the same object instance, a really important difference from primitive types. Encapsulation is an important part of objects when we're programming. We don't want to have our details exposed to the users of our objects. We use access modifiers to control encapsulation. We use methods to manipulate the state and perform operations on our objects. If we want to exit a method early or if our method has a return type, we use the return keyword to control that. And objects have not just operations, but they also have state where we use fields to store the object state. Fields are generally considered a kind of a low‑level detail of our objects. So we generally don't want to expose those directly to users of the objects. So what we normally do, or at least most commonly do, is use accessors and mutators to control interaction with our fields. Basically, we use methods so that we can change the implementation detail of the data without affecting the usage of our class.

Class Initializers and Constructors
Introduction
Welcome to the next module in our Java Fundamentals course on the Java language. In this module, we're going to look at class initializers and constructors. My name is Jim Wilson. In this module, we're going to first look at the idea of establishing the initial state of our objects. We'll look at how we can set the value of class fields as part of the class declarations. We touched on constructors in the last module. We're going to look a lot more of how we work with constructors and the idea of having multiple constructors. We'll then look at how we can chain multiple constructors together and even use constructor visibility to control how and where our class instances are created. We'll talk about a way to share code across constructors called initialization blocks. And then with all these different ways to construct and initialize are objects, we'll talk about how the order of those things occur.

Establishing Initial State
Remember that we talked about the fact that classes are made up of both state and executable code, so it's reasonable to expect that when an object is first created that it's going to be in some useful state. Java will provide a default state when the object is first created, but that may sometimes not be enough. You may need to actually set this value yourself or even execute some code. Java gives the ability to set the initial state of an object. It actually provides three separate mechanisms for doing so. One is what are called field initializers, where we assign a specific value to a field. Another is called constructors, where we actually can potentially pass in parameters and run code to set the state. Another one is called initialization blocks that allows us to run code that can be shared potentially across constructors.

Field Initial State and Initializers
You'll recall that when we talked about variable declarations, we said that variables always had to have an explicit value assigned to them. That's not true for fields. Fields will get a default value automatically as part of the object construction. Now that default value will always be what I call the field's zero value. And what I mean by that is it's kind of whatever the kind of empty state of that field is based on this data type. If we take a look here, like, for example, all of the integer fields, byte, short, int, and long, the value is actually 0. Same with the floating point. The value is 0. For the char type, the 0 value is basically, again, all zeros, kind of the null character. For Boolean, it defaults to false. And for reference types, they default to null. So we have all these kind of default values that they get, and those are reasonable defaults. But as your objects get more sophisticated, those default values may not be the right thing for your object's initial state. Now, the good news is we don't have to accept those default values. Java provides what are called field initializers. And a field initializer allows you to specify the field's initial value as part of its declaration. Imagine we have this class. We're going to call the class Earth, and it has a field called circumferenceInMiles. So we want to go ahead and set that to an initial value, right? Initial value of 0 doesn't make sense. We know the Earth actually has a circumference. So what we can do is just do a simple assignment to set its initial value. So we can just simply say circumferenceInMiles = 24901. By creating an instance of the Earth class, that field will have the value 24,901. Now, simple assignments are a good start, but that may not be enough. You can also use an actual equation. So if we had circumferenceInKilometers, well, we could calculate that out by hand, or we can simply say that, well, I know if I take 24,901 and multiply it by 1.6, that'll give me the circumference in kilometers, so we can actually have that equation. Remember though that the equation has to be a valid equation. So right now, this wouldn't compile because although 24,901 is an integer type, when I multiply it by 1.6, which is a double, that result will be a double that I can't assign directly into the long, circumference and kilometers. So we just go ahead and put a cast in place, and that now becomes a legal assignment. But if we look here, you see that we're duplicating that 24901 in two places. It would be nice to only use it once. Well, we can actually reference other fields in our field initializers. So we can take that 24901 and replace it with the field circumferenceInMiles. So the equation would then use the value of circumferenceInMiles when it does the calculation. So things are kind of getting better and better as we go along here. Now, one thing interesting to note though. If we calculate out 24,901 times 1.6, the value that that calculates to is 39,841.6. Now, when we cast that to a long, the cast is just going to truncate it. So the value of circumferenceInKilometers would end up being 39,841, less than ideally accurate. The better answer for that would be 39,842. Well, the good news is we can make any method calls that we need to in here. So one of the things we could do is there's a built‑in method called Math.round. So if we call Math.round, that'll take the result of that equation to 39,841.6 and actually round it so that we then would get 39,842 into our circumferenceInKilometers. So you notice these field initializers are really powerful because you can do as much as you need to, anything from a simple assignment to equations, all way up through method calls.

Constructor and Adding Multiple Constructors
We talked about constructors briefly in the last module, and from that we know that a constructor is executable code that's used during the creation of our object to set up that initial state. Remember that we worked with our flight class in the last module, and we saw that that flight class had a constructor in it. Now one other thing that's interesting to note is that a constructor is not a method, it is like executable code, but it's not a method. You'll notice that constructors don't have return type, it's just the code we want to run during the construction of our object and every class has at least one constructor, but it's interesting to note, though, if we looked our Flight class, what's going on inside of our constructor isn't really necessary. We see setting passengers equal to 0. Well, that's not necessary because we know that ints are automatically set to 0 when their field is in a class and the set seats equals 150, well we could have actually put that up in the declaration of seats. So we didn't really need to have an explicit constructor here. So what happens in the case where we don't really need to have an explicit constructor? Let's take a look here at how to deal with that. Let's choose to use another class. I'm going to call our Passenger class and our Passenger class is going to have three fields, and these are all related to checking bags when we get on a flight. So we have the checkedBags field, which is how many bags a passenger has checked, freeBags indicates how many bags are allowed to have for free, and then the perBagFee is what is the cost of each bag beyond the number of free bags. And let's assume that we've provided accessors and mutators for checked bags and free bags so that we can interact with that data. Well, as we can see, this class does not have a constructor, yet if I write code to go ahead and create a new passenger assign it to Bob, that code will run. Well, how is that possible if we said that every class has to have at least one constructor? Well, it turns out that if you don't have an explicit constructor, Java actually provides one. You wouldn't see it in your source code, but when the class is built, Java generates a constructor that doesn't do anything, therefore, it makes it possible to create an instance of your class without explicitly running a constructor. And there is nothing special about that class, it'll behave normally so you can interact with all of its methods and so forth, but classes can actually have multiple constructors. Now the parameter list has to differ for each constructor, that's an idea we call the signature. We'll talk a lot more about how signatures work later in the course when we talk about methods in more detail. The key thing is that just the number and types of the parameters have to differ across the various constructors. So let's say that we have an issue here where we want to be able to create passengers, and as part of the creation, indicate how many free bags they're allowed to have. So all that constructor would do is accept the parameters that number free bags and assign that to the field. Now what that would allow us to do is to write code like this where our passenger jane = new Passenger 2 that calls our constructor that accepts the integer and that sets number of free bags for Jane to two. So then, of course, we can then set the number of check bags for her from there. The thing is that once we introduced this new constructor where it accepts the integer free bags, the line above there where we actually could create Bob as a passenger, would no longer compile because what happens is that once you write any constructor, you're now responsible for all the constructors, so that constructor that was created by Java is no longer there. The point there is that Java doesn't assume that your class needs a constructor with no arguments. Once you write any constructors, you're now responsible for all the constructors. So if we still want to allow users of our class to create instances that don't provide any arguments, we're responsible to go ahead and write a constructor that doesn't take any arguments, it doesn't have to do anything, but just by putting that there were saying that that code that creates an instance without providing any parameters is now valid again.

Chaining Constructors and Constructor Visibility
Looking at our Passenger class, what I want to focus here on is just the constructors for a second. So we'll assume that we have any fields and methods we saw on the earlier slides. And remember that we have a constructor that takes no arguments. We also have our constructor that accepts an integer, which is the number of free bags that we set. And of course, that allows us to go out here and do something like create a reference called Jane to a new passenger. When we create, we say that Jane's allowed to have two free bags. And then we can call that method setCheckedBags to set how many bags she's checked. Now if we find this is a scenario that comes up a lot where we create a passenger who has a number of free bags and a number of check bags, it might make sense to introduce another constructor that allows us to combine those operations. So we can go ahead and create the passenger and in one call say that they can have two free bags and they've checked three bags. So to write a constructor like that is really straightforward. We just introduce another public passenger with two integer arguments, one for free bags and one for checked bags. Now one way we could write this is again we just make the assignments. We assign free bags into the field freeBags. We assign checked bags into the field checkedBags. And that would work. The thing is that we're now getting some duplicate logic. That assignment of free bags is now happening in two separate constructors. Now, in this case, that logic is really simple. But if time goes on and the logic around the management of free bags gets more sophisticated, we would actually have to change it in every place that we currently assign free bags. So it would be nice to be able to chain these constructors together, and it turns out we can do that. One constructor is allowed to call another constructor. And all we do is use the this keyword followed by the parameter list. So if we look in the constructor that takes freeBags and checkedBags, that line will reassign freeBags. We can replace that with this and then our freeBags parameter. What that'll do is then call in to the constructor that accepts the single integer freeBags and run that constructor. The one qualifier is the call to the other constructor has to be the first line in our constructor. So now when we create this passenger Jane, it calls into the constructor that takes two arguments, as part of that calls up to the constructor that takes one argument, which sets the freeBags. And then when that returns, we assign checked bags into our checkedBags field. With multiple constructors, we may want to start thinking about the visibility of our constructors because just like any other members with constructors, we can use access modifiers to control the visibility of those constructors. What that allows us to do is limit what code can perform specific creations. Let's think about an example here. Let's say that we introduce a constructor that allows us to identify the per‑bag fee for a passenger. Of course, all that does inside is assign whatever that parameter is into our perBagFee field. But thinking about it is that if the logic around setting bag fees is kind of meant to be part of our class, we probably don't want a program to easily go in and change that. We don't want cheap Joe to come along and just create himself as a passenger where he pays a penny a bag. So we probably don't want that broadly accessible. So what we want to do here is that for our constructor that accepts the baggage fee, instead of being public, go ahead and make that guy private. By making it private, it can't be called from the outside. It can only be called from within our class. So maybe what we want to do here is say that well, based on the number of free bags a passenger is allowed to have, we will set the baggage fee, the idea being that a passenger is assigned a certain number of free bags based on kind of the level of customer they are. So a customer who actually is allowed more free bags may also as part of that get a lower per‑bag rate for the ones they have to pay for. So if we look at our constructor here that accepts free bags, we can make a little room in here. Maybe what we want to do is make a call down to the other constructor based on the baggage fees and pass in a different value based on the number free bags the customer has. So what we can do here is call out to that and say well, if free bags is greater than one, they pay $25 per bags beyond the free bags. Otherwise, they pay $50. Again, the idea being that a customer who gets more free bags also gets a discount rate on bags they pay for. So what that allows us to do now is have our baggage fee rate tied to the number of free bags a passenger gets. So if we have one call here where we can create a passenger Fred who gets two free bags, that goes directly to the constructor that accepts the free bags parameter. As part of that, it chains down to the constructor that sets the baggage fee. We have another passenger we create who accepts the two parameters, the freeBags and the checkedBags. We'll then call into first that constructor. That constructor will chain up to our constructor that accepts the number of free bags, which then in turn chains down to the constructor that sets the baggage fee.

Demo: CalcEngine with Field Initializers and Constructors
Let's take a look now at how we can use field initializers and constructors to improve our CalcEngine app. Before we start changing anything in our class, let's imagine what it's like for someone who's using our MathEquation class for the first time. Now if you think about it, whenever you start working with a new class or class library, something you'll often to do is just kind of write the simplest thing you can and see what happens, right. So let's imagine what that would be like with our class. So we declare a variable called TestEquation of type MathEquation. We'll go ahead and new up MathEquation. And, of course, what's the simplest thing you can do with our MathEquation? We can go our testEquation and call execute, and then what you would do from there is just print out the result. So with that, we see kind of the simplest thing you can do here, right. So let's go ahead and comment out our other code for just one second. I'm going to go ahead and take this area code and comment that out. So let's go ahead and run this now and see what the experience would be like for someone who just come to explore in our class. And you can see what happens here is that they see a message says invalid opCode. So right away, they've had this negative experience because what's happening is that we're allowing them to create our class in a way where our class has an invalid initial state. Basically, what's happening is that if I go into the MathEquation class, well, the value of opCode is that the null character, right, the all zeros character, if we go down here to our execute method, since it's not one of the valid opCodes, we right away print an error message. So I think kind of one of the best ways to kind of deal with this is actually allow the object to be initially created in a valid state, alright, and there is a couple ways we could do this. One way to do that is to go to the opCode to something that's valid like an a, alright, that way, when they run it, what we'll do is we'll add two zeros together. You know, it'll print out 0, it won't do something useful, but it won't give them a negative experience, right. So now when we run that code, it just prints out 0, and that's a reasonable experience for someone who is exploring our class. So we always want to make sure that our classes are being created in some kind of reasonable state. Okay, let's head back over here to Main and let's go ahead and comment out that test code. Now let's bring back our original code, so again, I'll uncomment that stuff. So now remember what happens here is that the way we do is we create this array for math equations, and then we go through and we call create to create a math equation into each one of the array instances. Now remember that we've got this create method down here, but the thing that's kind of ugly about this is that the application has had to handle all the details of setting each value, setting the opCode, we don't want to have to do that. Alright, if that's something that goes on frequently, that's a perfect chance for a constructor. So let's head back to our class here and let's think about some constructors that we could write. Now one very reasonable constructor, I think, is to have one that accepts just an opCode. It would make a lot of sense, I'm going to create an equation, and I know what kind of operation I'm going to perform on it, but I don't know the values yet. So let's go ahead and create that constructor. So make it public MathEquation, I'm going to give it a single argument, a char opCode, and then all we're going to do inside of here is assign that parameter to our field opCode. So now we support the ability to create incidents of mathEquation with specific opCode. Now the thing is that doesn't solve our current problem because we know that we want to create instances that have the opCode and both values. So let's go and create another constructor, and this constructor will accept the opCode, as well as left and right values, which we have that I'll set up. Now inside of your, let's first look at storing the left and right values, so we're going to just assign each of those to the appropriate field, so we have that in place. Now we could do the same thing with opCode, but since we already have a constructor that accepts opCode, it's a perfect time to go ahead and chain up to that constructor. We'll just say this and pass in the opCode we've received. So that way we just call up to the other constructor that already knows how to do that. Now before we go any further, let's just go ahead and run our program and make sure everything is okay. If you look at what's happened here, we've broken the existing code. You see, we're back here in Main and right there where we actually tried to create just MathEquation, we're not able to anymore because remember that we were getting a default constructor before when we didn't provide any constructors. Once we provided the constructor, we're now responsible to provide all the constructors. So what we want to do is head back to our MathEquation class and go ahead and create that constructor that doesn't take any arguments. And so with that, we should be able to run our code now. Let's go ahead and run it, and now the code works again. So we've now kept our old code working, and that's something we want to do. But now let's look at how we can improve the code. And now that we actually have a constructor that accepts the opCode in both values, if we go back to our Main app here, we shouldn't need this create method anymore, alright, we should be able to do all that with constructors. So if I head up here and where each of these places where I call create, I can instead call the constructor. Alright, so I can simply new up MathEquation, and when I new it up, we have to make sure the param order matches. So in our constructor, we have the opCode first, then the values, so we'll cut that away, put that in the beginning, and now we're using the constructor to create that 0 instance of the array. Go ahead and do the same thing for the other three elements. Now we're using a constructor to create all the array elements. So we can actually scroll down here and just get rid of this create method, and with that, let's go ahead and run it. And we get the same results we have been getting, which is good, but now the key thing is that we're using a constructor to set up the object and get the object to the appropriate state so that we take that burden off of the program that's using the object and keep those kind of details and housekeeping inside the object itself.

Initialization Blocks
Constructors are not the only way to run code as part of the initialization of our classes. We have another mechanism called initialization blocks. What they allow us to do is create code that's shared across all our constructors. And what they do is they run the code as if that code were placed at the very beginning of each constructor. Let's revisit our Flight class for a second. Remember that our Flight class has some fields in it. Alright, we know we have that passenger fields. We're going to get a look at another field here called flightNumber, that we'll talk about in a second, that I've added. And of course, we have our seats field. We're going to choose another new field here called flightClass. And the idea here is that flightNumber and flighClass are two different ways to identify a flight, so a flight's either created with an individual number, or it's created with an individual character as a Flight class to kind of group it somehow. Now remember that constructor that we wrote earlier, alright, it took no arguments, and it set seats to 150 and our passengers were set to 0. Now we've learned a lot since we originally wrote this constructor. We know that passengers will automatically be set to 0, so we don't need to have that code here. We also know that we can initialize by the seats field right up there in the declaration. Alright, so we'll go ahead and move that up there, and we no longer need it inside of our constructor. So now let's add two more constructors, one that accepts our flightNumber, so we'll go ahead and initialize that, and another one that accepts our flightClass, and that initializes the flightClass field. Now as we're enhancing our class, let's go one step further. In addition to having these different ways to identify our flights, let's keep track of the seats a little more closely, alright? Right now, all we have is this ability to have the number of seats. You know, and earlier we kind of just kept count of how many passengers we had. Let's kind of advance this a little bit and say, let's keep track of if each individual seat is available, and we've got this new array here, isSeatAvailable, that's an array of boolean. Alright, now if we just declare this array of boolean, all the values are going to default to false. We, of course, don't want to have all the seats available set the false, that would imply that they were unavailable. Alright, we want them to be available or set to true. So now, based on what we know so far, the way we would do that is we would go to our no argument instructor here, we would go ahead and allocate the array for isSeatAvailable, and then what we would do is loop through each one, and then set each one to true. Alright, and that's a reasonable thing to do. What we do, of course, is that in each of the other constructors, we would call up to that constructor, alright, so our constructor based on flightNumber and our constructor based on flightClass, would both call up to the no argument constructor, alright, and that's a reasonable thing to do. But in cases like this where we have code that we want to share across all the constructors, that's a perfect place to use initialization blocks, and all we have to do is take that code that we want to share and place it within brackets outside of any method or constructor. Let's take our no argument constructor, and take all the code out of it, and we'll move it down. So now it has no actual queued code inside of it, and then we'll take that code that we want to run, and wrap that in brackets. Notice there's no constructor name here, there's no method name. It's just the brackets and the code. That turns that code into an initialization block, and it will automatically be executed as if it's at the beginning of each one of our constructors. So our flightNumber‑based constructor no longer needs to chain up to another constructor, as well as our flightClass constructor. No matter how someone creates this class now, the code to set up our isSeatAvailable will always run because it's in that initialization block. So it's a great way to share that code across constructors. It's really useful in something we're going to talk about later called anonymous classes. Another thing just to note is if you do put multiple initialization blocks in the class, they're executed in the order they're encountered from the top. I would be really careful about that because that's really easy to get out of hand, but just something to be aware of.

Initialization and Construction Order
Throughout this module, we talked about a number of different ways we can set our field values as part of the creation of our objects. What we want to understand is the order that those values get set or the order that these operations occur. As you would expect, object creation occurs in a predictable pattern, or predictable path. So let's imagine we have this class here to just, we'll call it our OverInitializedClass. We'll put a field in here called theField, and let's go ahead and give it a getter. One of the first ways we learned about how we could initialize a field is through field initializers, and that is actually the first step in the creation of an object. So if we take our field here called theField, set it equal to 1, if I then in a program create an instance of this class and then print out the value of the field, I'll print out the value 1. The next phase is to run the initialization blocks. So if we take the same class and now we add an initialization block that sets the value of the field to 2, even though we still have a field initializer that sets it to 1, when we run the code that prints this out, it's now going to print out 2 because the initialization block ran after the field initializers ran, so it would overwrite that value. And then the final phase is construction. So again we take our same class, and now we add a constructor that sets the field to 3. When we run the code to print this out, it'll now print out the value 3. Now, you're looking at this. You obviously wouldn't want to do what we do here where we actually, you know, set a field to something in a field initializer, then change it an initialization block, then change it in a constructor. You're not going to do that. But as your classes get more sophisticated, you'll find that your fields start to depend on the values in one another, so it's important to understand this order as you use the fields and set up the field inside your class. The most common mistake I see people make is that they'll do work in an initialization block that gets invalidated by work that occurs later in a constructor. So just keep this order in mind as you're setting up your classes.

Summary
Some of the key things we want to remember from this module. Keep in mind that we want to make sure that our objects are always created initially in some useful state. We don't want to allow a user to just new up an object and have it in an erroneous state. Now they may not be able to do something meaningful with it, but it should at least not be error‑based when they first create it. In terms of how we can initialize our objects, we saw there's a number of ways. The simplest way is field initializers that allows you to just associate a value with a field as part of its declaration. As we associate code with our object creation, that we have constructors. And every class has at least one constructor. If we don't provide a constructor, Java will provide one that has no arguments on it. We can provide multiple constructors, and remember that once we provide one constructor, we're now responsible to provide all of them. So if we provide a constructor that has arguments, if we still want to allow people to create an instance of our object using a constructor with no arguments, we then have to provide that constructor as well. We can chain our constructors together, which allows us to unify coding constructors so that we can pass parameters from one constructor back to another constructor to use that code. Remember though that when we do chain constructors together, the call from one constructor to another has to be the first line of that constructor. To have code that gets executed no matter which constructor is called, we have initialization blocks. Remember that syntax, and that's kind of weird, it's just a set of brackets with code inside of it, not part of any constructor or method. And given all these different ways to initialize our objects and get them constructed up, we want to make sure we always keep the order in mind. Remember that field initializers are first, then initialization blocks, and then finally, our constructors.

A Closer Look at Parameters
Introduction
Welcome to the next module of our Java Fundamentals course on the Java language. In this module, we take a closer look at parameters. My name is Jim Wilson. In this module, we'll first look at the idea of parameter immutability, the idea that changes made to a parameter and method are not reflected once we exit the method, but members of a class can be affected inside of a method. Then we'll look at the idea of constructor and method overloading, the idea of having a constructor or method with differing parameters. And then finally, the idea of supporting a variable number of parameters.

Parameter Immutability
In Java, when you call a method and you pass parameters into it, those parameter values are actually copied down into the parameter. This something we call passing by value. And what that means is that because a copy is actually passed down there, any changes you make to the value of the parameter inside the method are not visible outside of the method itself. Let's see how that affects us when we're working with primitive types. So let's imagine we have a method here we're going to call swap. Swap accepts two integer parameters, i and j. And we'll set up some code to call it, so in our code that calls it will first have a variable declared called val1 that we set to 10, which, of course, allocates out some memory, the value of 10 inside of it, to another one, val2, set to 20, which again allocates memory with a value 20 in it. Of course, if we print those values out, the value of val1 will be 10 and the value of val2 will be 20. So now, if we call that method swap, passing in val1 and val2, when control gets passed down to the swap method, memory for the parameter i is allocated, and the value of val1 is copied down into that memory for i. Same thing for j. The value for val2 gets copied down into the memory allocated for j. So now if inside a swap we do something like allocate a local variable called k and assign it the value of i, well, k will then get the value of 10, right, the value currently held in i. If we then say i = j, that means take the value that's in j, 20, put that in the i, so i becomes 20, we then say j = k, the value that is in k10 goes into j, which is now becomes 10. So down inside the method swap, if we print these values out, the value printed out for i will be 20, the value that's currently there. Same thing as we print out j. The value printed out is 10, the value that's currently there. Notice that all the changes that occur within the method are occurring inside the copies associated with the parameters, not the original values. So when we exit out of this method and pass control back, all those copies are cleaned up, so val1 and val2 still have the original values. So if I print this out, val1 still has 10, val2 still has 20. Because again, things were passed into the method as copies. Now what about classes? We know classes behave a little bit differently than primitive types because remember that classes work with references. So let's say we have a class here that we've been working with, Flight, and let's just focus in on its field flightNumber. And we'll assume we've got an accessor and mutator set up for that. And we've got that constructor that accepts a flight number and, of course, sets the field with it. Now we're not going to worry about any of the other members in Flight right now, so we're really focused on Flight and flightNumber here. So now let's again say we have a method called swap, but now our method swap accepts Flight references, right? A Flight, first one is i, second one is j. So now if we want to call it from our code, we'll allocate out val1, which is a new Flight with the flightNumber set to 10. All right, so what's that going to do? Well, it's going to allocate out memory. That's our variable. But then we remember that we allocate out the class instance itself separately and then assign a reference into the variable. So we have another Flight instance here, val2. Again, it allocates out to a place to hold the reference, the actual Flight object itself, and then associates that reference. So now val1 and val2 are not the flights themselves. They're references to the flights. So, of course, if I print those out, things are what we expect. Val1's flight number is 10. Val2's flight number is 20. But now when we call in the swap, we pass val1 and val2, what's going to happen is actually the same as what happened with our primitive types. We're going to have that memory called i that's allocated. We're going to copy what's in val1. Well, what's in val1 is the reference. So it's going to point to that same object, flightNumber. For val2, we'll copy that into j. Again, we're copying the reference which points to the other flight, which is flightNumber 20. If we look at our code now, if we do the same sort of thing, we allocate a local variable called k, and we assign what's inside of i. Well, what's inside of i is a reference to that first Flight object, the one with the value 10. If we then say i = j, well, i now stop pointing at the original flight and points to the same one that j points to, the one with the flightNumber of 2. We say j = k. Well, j stops pointing to the one with 20, points to the one that k points to, which is the one with 10. So inside of our method here we print out the flight number of the one pointed to by i. That's 20. The one pointed to by j is 10. But notice that we're swapping the references around. We still haven't affected the original val1 and val2. So when we exit out of swap, val1 still points to the one with a flightNumber of 10. Val2 still points the one with a flightNumber of 20. So when we print those out, nothing has changed. Val1 has 10. Val2 has 20. So we're copying these values into the parameters, causing us not be able to change them inside the methods. So that tells us that changes to the values of parameters inside of a method don't affect the original values because it doesn't matter whether it's a primitive type or a class instance. But what's important to realize is that although we can't change the actual parameters themselves, when we pass classes in, any changes we make to the members of classes inside of method do stick. Those do take hold. Those are visible outside of the method. Let's take a look at why. If we look here, that same thing we were doing before, we're going to create an instance of our Flight class with a value of 10. Sets up things just like before. Val1 is a reference pointing into an instance of Flight with a flightNumber of 10. Val2 points to another one, so val2 is a reference point to an instance with a flightNumber of 20. We print them out. Everything's the same as before. Val1 is 10. Val2 is 20. Our method this time, we're going to change its name to swapNumbers. And what we want to do inside of here is swap the flight numbers between the flight instances. So when we call into this guy, again, we're still copying the values of the parameters. So i still gets a copy of the reference that was inside of val1. J still gets a copy of the reference that's inside of val2. But now in our code here, we're going to change the members. So if I have an integer called k this time and we call i.getFlightNumber, well, that takes the reference held by i, goes up to the object instance that it points to, and that gets back the number 10 and puts that inside of k. So now if I say i.setFlightNumber and I pass as a parameter j.getFlightNumber, well, let's look at that from the inside out. When we call j.getFlightNumber, that takes the reference that's stored in j, follows it up to the object instance, gets that number that's in there, which is 20, and then we work to the outside. I.setFlightNumber takes the reference that's held in i, goes up to the object instance it point to, though I'm currently with 10, but when we call setFlightNumber, it becomes 20. So you see that we didn't change the parameter. The parameter is still a copy. But because we're following the reference that's in the parameter, we can change the object that it's pointing to. So if we now say that j.setFlightNumber of k, well, we get the value that's in k, which is 10. We take the reference that stored in j, follow it up to the object that it points to, and we set its flightNumber, it now becomes 10. So inside of the method, if we print these out, things are changes they've always been. The flight number of the flight instance pointed to by I is 20, the one pointed to by j is 10, but the key is because we found the references and then changed the actual objects, as we exit out of here, even up where we called the method, those changes now stick. So the flight pointed to by val1 has the value 20, the change that occurred down inside the method. The flight pointed to by val2 also has the change, the value of 10. The changes occurred down inside the method.

Overloading
As we've been working in different classes throughout this course, we've seen that a given class can have multiple constructors, and that same idea can be extended to methods where a class can have the same method name appear multiple times. And this is a concept called overloading, the ability to use different parameter lists with a given method name or the constructor. Now the system has to have some way of identifying what constructor or what method you want to use. And what it uses is a concept called a signature, is that each constructor or method must have a unique signature, and the signature is made up of three parts. Now one part is the number of parameters, and we saw this previously when we were working with our Passenger class. Our Passenger class had multiple constructors. The first constructor here has no parameters at all. We had another constructor that accepted the number of free bags, so it had just one parameter, and then we had another version of the constructor that accepted free bags and checked bags, so it had two parameters. So the system was able to figure out which constructor we wanted to use based on the number of parameters we passed to the constructor. Now we're not limited to just a number of parameters. The signature is also affected by the type of each parameter, and we got to see this earlier when we were working with our Flight class. And our Flight class had, again, a constructor that took no parameters, a constructor that took just the flight number, so that was an integer parameter, but only one parameter, and another constructor that also has only one parameter, but this was a char for the Flight class. So it's not just a number of parameters, but also the type of the parameters. And the final part to identifying the signature is the name. Now when it comes to constructors, the name doesn't really matter so much because it always has to match the class name. But when it comes to methods, the name is actually a really important part of that because a given class can have multiple methods, each with their own unique name, but that one method name can also have different numbers of parameters and parameters of varying types, and we'll see some examples of that in our next clip.

Overloading Walkthrough
Let's take a look at our flight class and see how we might be able to use overloading to improve this class. Now remember that we have the idea of our seats are 150, and we keep track of the number of passengers, and we've had that method we wrote much earlier in the course called add1Passenger. We're going to just make sure that there's enough seats for one more passenger. If so, we add them, and if not, we go ahead and just handle that, which is just going to report an error. Well as we look ahead to maybe making this flight class a bit more sophisticated, this idea of checking whether there's enough seats to add another passenger is something that we may have to reuse a lot. So why don't we go ahead and make that its own method? So we'll have a method called hasSeating, and inside of there, we'll just put that check in for is the number of passengers less than the number of seats available. And what we'll do is we'll update our add1Passenger to go ahead and use that hasSeating method. So now as we're keeping track of what's going on with our flight, one of thing we might want to keep track of is the number of total checked bags. Now we're not going to limit the number of checked bags, but we are going to keep track of it. But something that we might want to limit is the idea of carry‑ons. So what we're going to do is we're going to set the maximum of carry‑ons to whatever twice the number of seats are. Right, no one is supposed to have more than two carry‑ons, and then we'll go ahead and keep track of that total carry‑ons. And let's go ahead and add a method that just allows us to check to see that based on the number of carry‑ons someone has, is there space for them? So all we'll do is just take how many total carry‑ons we already have, how many carry‑ons they're trying to bring on, as long as it doesn't exceed our maximum carry‑ons, we'll go ahead and let them do it. Then, of course, we have all the other members we've seen previously. I want to focus in on the idea of add one passenger, right, because now that we're keeping track of things like total check bags and carry‑on, the idea of adding a passenger is going to be a bit more sophisticated. Let's go ahead and move this off to the side. Now we're still the same add1Passenger we were just looking at, nothing has changed there. But let's add a little bit more space to work here. So now if we think about overloading add1Passenger, well, keeping track of checked bags is going to be important, s let's add an overload that accepts one integer, and that's the number of bags, and the logic inside there would be, well we'll call our existing add1Passenger, all right do that work, and then we'll add how many bags they've checked to the total checked bags. Now, one interesting thing about what we're doing here is that it's possible that we tried to add that passenger and there wasn't enough seats available, but in this case, we'd go ahead and increase the total check bags. So what we can do is go ahead and wrap our code here so that we check the hasSeating before we do any of that other work. And this shows us a couple of things. First of all, notice that when we wanted to access the overloaded add1Passenger that took no arguments, there was no special syntax for that, right, it wasn't like the constructors where we had a special key word. Here we just call the method name with the right number of parameters. Also notice that when you're calling from one overloaded method to another overload of that same method, there's no rules about where it has to be. Remember when we were talking about constructors, the chaining of constructors had to be the first line in the constructor. Here it's just kind of a method call. You can call it from anywhere in the body of your method you need to. So now remember that we also have the idea of a Passenger class. Well, if we're writing a method to add one passenger, it should probably accept an instance of the Passenger class. Now we're not really going to do anything special here. All we're going to do is call the add1Passenger to accept an integer for checked bags. So we just call on our passenger, getCheckedBags and pass that in. This shows us another interesting thing about method overloading. Our add1Passenger has accepted integer number of bags, right, that was adding new functionality, that was functionality that we did not have before, the idea of keeping track of the total number of checked bags. But our add1Passenger that accepts just a Passenger instance, we certainly could have required someone who's using our flight class to simply call getCheckedBags themselves on Passenger. But that's something we do very commonly is that overloads sometimes are just used to add convenience. Right, so the one that accepts the passenger reference is a convenience overload. So someone didn't have to call getCheckedBags themselves. The one that accepts the integer number of bags actually adds functionality. So as we look at adding functionality, another thing we want to keep track of is this idea of carry‑ons. All right, so we have an overload here that now takes the number of checked bags and the number of carry‑ons. So we'll check to see if we have seating, we'll go ahead and call the add1Passenger that accepts an integer number of bags, and then we'll add the functionality to increase the total number of carry‑ons. No one of the things we want to do here, of course, is that before we add the passenger, not only do we want to check for available seating, but we also want to make sure that we have space for their carry‑on, right. So, again, this is an overload that's adding new functionality, validating that we have space for the carry‑on, and then keeping track of that total number of carry‑ons. And then we'll have another convenience overload here's that accepts passenger reference and the number of carry‑ons. And all that's going to do is call up to the implementation of add1Passenger that accepts an integer number of bags and number of carry‑ons. So our class has gotten a lot more sophisticated here now, right. The idea of adding a passenger can do a lot more things as if it was just keeping count of the number of passengers where I have to keep track of the number of checked bags, the number of carry‑ons, and even limit how many carry‑ons can get onto that flight. So let's focus in now on not just the implementation, but kind of just the signatures. Remember the signature is the thing that determines which implementation of an overload gets called. So focusing in on just the signatures of these, let's go ahead and make some room here, so I've just pushed them all together. So these the same exact methods we were just looking at it. So we have just those five overloads of add1Passenger and let's see how it might get used in a program. So let's add some code here that goes ahead and creates a flight. Let's first create a passenger, and were passing in 0 and 1 to the constructor. Reminder is the zero is how many free checked bags they get, so in this case they get zero, none, and how many bags they're checking, which is one. Create another passenger that gets zero free bags, but they are checking two bags. So we've got this all created. So now if I call on flight, add1Passenger, well, this is the one with no parameters. So it's nice and easy to know which one that chooses. It just calls the implementation of add1Passenger that accepts no parameters. I call add1Passenger, passing an integer. Okay, well there's only one parameter here, so there are two possible overloads that can handle that, right. The one that accepts integer and the one that accepts passenger. But since we're passing an integer, it will use the integer overload. Similarly, when I called the add1Passenger, passing in a reference to a passenger, it will call the overloaded accepts a passenger. But let's go another step. Let's declare a local variable of type short called threeBags that we set to 3. Now when I call, add1Passenger, passing in threeBags is the first parameter, a short, and then 2 and integer is the second parameter. Well, there are two possible overloads here that accept two parameters, right. The one that accepts two integers and one that accepts a passenger and an integer. Notice there is no overload that accepts the short. So how does this system decide which one to call? Well, it starts looking for the automatic conversions that it's able to perform. Remember, back in module three, we talked about kind of these idea of automatic type conversions? Well, very similar rules are applied here in order to determine how to find the overload. So what happens is that since the system knows now to convert a short into an int, it will go ahead and call the overload that accepts an integer as the first parameter. And then, finally, if we call add1Passenger passing in a passenger and an integer it, of course, calls the appropriate overload for that, the one that accepts a passenger and an integer.

Demo: CalcEngine with Method Overloading
In this demo, we'll take a look at how we can use method overloading to improve our CalcEngine program. Here we are in our MathEquation class, and you recall that we created with three constructors, one that accepts no parameters, one that accepts just the opCode, and one that accepts the opCode and both values we want to operate on. Now the way this works is that if when you create the MathEquation, if you know that the opCode and both values when you create it, things are nice and easy to use. But if you only know the opCode at the time you create it, and then later, when you're ready to execute, you then have the values, were a little bit cumbersome to use because you have to create with the constructor that accepts the opCode, and then you have to call setLeftVal, the left value setup, call setRightValue to set up the rightVal. Then we scroll down here a little bit. Then finally, you call execute. Well, it seems very likely that there will be a lot of situations where we may create an instance of our MathEquation with a particular opCode, and then when it's time to execute, we would have both of the values we want. So it would be nice to be able to go ahead and just pass in those two values as part of the execute. So this is a great opportunity to provide an overload of our execute method. So we have the one currently that takes no parameters. Let's add an execute method that accepts two parameters, the leftVal and the rightVal. So that's going to be really easy for us to do here. We're just going to declare public void execute, and then we're simply going to have parameters for the leftVal and the rightVal. So we have both those parameters. Let's go ahead and put the body of it here. And all we need to do inside of here is set the field leftVal to the value of the parameter leftVal, do the same thing for the rightVal, and then call the other execute implementation. So now, in this scenario where we have the opCode and construction time, but the two values at time we're going to execute, we can do that kind of all in one step. So let's go over to our Main program here, and we've got the existing code that we worked with before. What I want to first of all before we do the actual work is I'm going to put a couple of print statements in here just to print out a message in the output window so we can differentiate what we've done with the array previously with the new work we're doing with the overloads. Let's go and declare reference to our MathEquation class. We'll call this one equationOverload, and what we'll do is we'll just new up an instance of the MathEquation with the dividing opCode. So we've got that there. Now, before we use that, let's go and just declare a couple of doubles up here. So we have a variable called leftDouble set to 9.0 and a variabled called rightDouble set to 4.0. What we want to do here is that go ahead and perform the actual calculation. Now, as I said before, what we'd have to do is call setLeftValue and setRightValue each time. Now it gets really easy. You just say equationOverload, we'll say .execute, and what we're going to do is pass in the two values, leftDouble and rightDouble. And then, of course, from there, we can just go ahead and print the values out. So we simply called execute, passing in the values, and then go ahead and just get the result back as we print it out. So if we run this, it's going to work just like we would expect it. And we see there in our output window, under Using Overloads, we see result of 2.25. So that works just as we had expected. But now what happens if instead of using doubles here, I declare a couple of integers instead? So they're just basically the same values that I had before with the doubles. So if I copy these lines that we use with the doubles, and what I want to do here is where I have leftDouble and rightDouble, let's switch that the leftInt and rightInt. So now the question is, will that work? Since I've declared my execute method to accept doubles, and I'm passing an int, is that going to work? So let's go ahead and run it and see what happens. And we see that it does work, is that our result with the integers is also 2.25. And the reason being is that that's what we call a widening conversion. Remember earlier in the course when we talked about calculations, how that there were some automatic type conversions that can occur. Since a double is wider than an int, in other words, a double can hold anything that's inside of an int, the system can ahead and infer that conversion and go ahead and call the method that accepts doubles, even though we're passing in ints. Now there is one thing that's kind of curious though, right? Let me just run this again real quick. Our results of dividing the integer 9 by the integer 4 is being printed out as 2.25. We remember that in our integer arithmetic that we learned earlier in the course that should actually just be 2. When you divide two integer values, you don't get a decimal point. You only get the whole portion of that. So, to make our MathEquation class more effective, what we should really do is provide another overload of execute that accepts two integers. So I'm going to go over here. I'm going to go ahead and copy this one that we have here now that accepts the doubles. I'm going to go ahead and paste that in again. And what I want to do here is convert each of these doubles to be ints. So we now have an overload that accepts integers. But now if we were to run this right now, nothing would be any different, because even though we're passing integers in at the parameter level, when we make the assignments to the fields, they're going to convert to doubles again anyway. Well, what happens when you do division with integer values? You get a truncated value. So what we can do here is that after we call execute, the value that's going to be in result would be 2.25. Well, if we could truncate that, then our MathEquation class would provide the right answer for integer division. So what I can do here is I can take my current field result, I'm going to assign it the value of result, but what I'm going to do here is cast it to an int. And what that does is it takes that double value of 2.25, by casting it to an int, it gets truncated to becoming 2. That 2 then gets assigned back into result as 2.0, because, again, result is a double. So now what should happen is that when I go back to my program here, now when I run this second call to execute that passes in integers, I should get a proper answer for integer. And you notice now the result is 2. Now, it displays as 2.0 because it's being stored as a double, but it's giving us the right behavior for dividing two integers. So let's go one step further now. So I want to go ahead and copy these same three lines here again where I pass the integers in. So I copy that, and I'm going to go ahead and paste that in. So now in this third call, what I want to do is I'm going to go ahead and cast this first one to a double. So now what happens there is I'm now calling execute with a double as one parameter and int as another parameter. Well, which one is it going to select? If I go back to my MathEquation class, if I look at my executes, well, I can't pass a double into an int because that would be a narrowing conversion. That's not legal. But I do know I can pass an int into a double. So the system will actually choose the one that accepts two doubles because that's the only one that can accept all the parameters. So now if I go ahead and run this, we see we get 2.25 for that last one. The system had to pick the best overload of all those that were available, the one for which there was a valid way to pass all the parameters. In practice, the mechanism that Java uses to resolve method overloads, it's pretty intuitive. In most cases, it's going to pick the one that you expect. But the implementation of how that is resolved is actually quite complex because there is a lot of kind of nuances to what can go on. If you're interested in all the details of exactly how the system chooses a particular overload, I've put a URL on the screen that references the specification for Java on exactly how that works. It's really kind of interesting, and it's actually quite complex, but if you're interested in kind of learning more about it, I encourage you to check out that URL.

Variable Number of Parameters
As we've seen, overloading allows us to pass differing parameter lists to a particular method name. But what happens if we don't know exactly how many parameters we need to handle in a method? Let's take a look here at our Flight class. Now, up until now, whenever we wanted to add passengers to a flight, we always had to add them in one at a time. But what if we wanted to add a method called addPassengers that accepted however many passengers we need to add at a time? It could be one passenger, it could be two, it could be five. Well, it seems that the most logical way to handle that is an array. So we'll go ahead and have our addPassengers method accept an array of Passenger. Now, one thing we'll need to do is an extra helper method here. Up until now, we've only had to check whether one more passenger could be added, and now we need to check and see if multiple passengers can be added. So we'll create our own private overload of hasSeating that now accepts a count, and all that'll do is just make sure that there's room to add that many more passengers. So the first thing we'll do in our addPassengers method is just call hasSeating, passing in the link to that array containing the passengers. So all we'll do inside of here is that we'll increase the number of passengers on the flight by the length of that array, and then we'll just go ahead and loop through the array, adding up the checked bags for each passenger, so we have that complete list. Of course, if there wasn't room, we'll go ahead and just handle that. So now what's it like to call this method addPassengers? All rights, so we set up a code here and we create a Flight. Let's say we create Janet, who is a passenger that has one checked bag, and we have John, who is a passenger with two checked bags. I'm going to go ahead and add them together. So we'll call our flight addPassengers, but we now have to package Janet and John up into an array, so we have to add the code where we actually create a new passenger array and initialize it with Janet and John. Not a horrible thing, but notice, if you look, we've actually typed more characters to create the array than we did to actually name the two parameters janet and john. And if that carries on, let's say now we want to add a family of three people, Fred, Sarah, and her daughter, Susie. Well, again, we've got to call addPassengers and then again explicitly create an array containing Fred, Sarah, and Susie. It would be nice if we could simply just list each of the passengers we want to add. And it turns out that we can actually do that. Methods can be declared to accept a varying number of parameter values, and doing it's actually quite easy. All we have to do is when we declare the parameter, just put an ellipse after the type. So you see here we have passenger as an array, if we change that to now be Passenger. . ., right, the ellipse, that now says that list will be a varying number of passenger references. One thing to notice is that when we use this ellipse notation, it can only be used on the last parameter for a method. Now, in our case, our method only has one parameter, but if we had other parameters we wanted to accept besides this list of passengers, they'd all have to occur before the list of passengers. Now here's what's really neat, though, is that an ellipse notation, you're actually still receiving an array. So all the code that we wrote to handle the array stays in place. We don't have to change any code in this method. The value comes in is that it actually simplifies calling the method. So if we take a look at that code we created to call into addPassengers, the code as we have it written right now would actually still work. Because the variable number of parameters are actually handled as an array inside the method, we can pass them to the method as an array, but that's not where the value comes in. If we take a look at the first call to addPassengers with Janet and John, we can actually replace the array creation with simply passing janet and john. And what'll happen is that Java will take care of creating that array for us. So the same thing where we call for Fred, Sarah, and Susie, we can simply pass in fred, sarah, and susie. So this now gives us that flexibility of handling an array inside the method, which allows it to handle anywhere from 0 or more passenger references while still having the convenience of calling it by simply listing the values we want to send to the method.

Summary
The key things you want to remember from this module. Remember that parameters are immutable. What that means is that any changes made to a parameter within a method are not reflected once you exit that method, and it doesn't matter whether it's a primitive type or a reference to a class. But you can make changes to members of a class, because remember that the parameter is actually pointing off to that object instance, so those individual members can be changed. A constructor or method can actually have multiple versions of it. In other words, you can have differing parameter lists. We call that overloading. Remember though that each one needs to have a unique signature. That signature is made up of its name, the number of parameters, and the type of each parameter. And finally, remember that methods can be declared to accept a varying number of parameter values. Basically, you process it just like it's an array because it actually in an array, it's just the Java environment is taking care of creating the array instance for you. The one key restriction is that it can only be done with the last parameter received by that method or constructor.

Class Inheritance
Introduction
Welcome to the next module of the Pluralsight Java Fundamentals course on the Java language. In this module, we discuss class inheritance. My name is Jim Wilson. We have a lot of great content to talk about in this module. We're first going to take a look at the basics of class inheritance in Java, the idea of member hiding and member overriding, the Object class, the base class of all classes in Java, object equality, what happens when you compare two objects to see if they're equal, and what does equal actually mean? We look at the super keyword, a useful tool for accessing base class behaviors in a derived class. We look at how to control class inheritance and member overriding behavior using final and abstract. And then finally, we'll look at how constructors work when inheriting one class from another.

Inheritance Basics and Typed References
As an object‑oriented language, Java allows one class to inherit from another class, also known as having a class derived from another class. The way we do that is when we're declaring the new class, we use the extends keyword and identify what class we're extending, or we're inheriting from. What happens is that that derived class has the characteristics of the base class, but then can add its own specializations to create more capabilities. And let's see what this looks like. Say we have a class here, we want to call it our CargoFlight class, and what we want it to do is to have all the same basic characteristics as our Flight class, so we simply say extends and then Flight. And so now the CargoFlight class will have those characteristics that come from the Flight class, then can of course add its own. So as a cargo flight, maybe things we want to keep track of is how much cargo space we have. So we'll say our cargo flights have 1000 cubic feet of cargo space, and of course we want to keep track of how much of that we're using. And so we'll just go in and add some methods to this. So we'll say that, well, we'll have a method to make sure we have enough space for whatever the size is what we're trying to add, so we just make sure that if we add that to how much the space we've already used, make sure it doesn't exceed our max cargo space, we'll have a method for handling when we do try to exceed that, in this case we'll just display a message saying there's not enough space, and then of course we'll have a method here that says add one package, and that method will accept the dimensions of the package, the height, the width, and the depth of that package. So what we need to do then inside of this method is that when we receive a package we'll calculate the total size, simply multiply the height times the width times the depth, and then we'll call our hasCargoSpace, and then if that returns true, we'll go ahead and add the size of that package to how much space has been used. Otherwise, we'll go ahead and handle the situation of not having enough space, which again just prints out a message. To use this, we can go out here and just declare a CargoFlight reference and new up a cargo flight. Then we can, of course, add a package to it. And so in this case we're adding a package with a height of 1 foot, a width of 2.5 feet, and then a depth of 3 feet, giving us a total size of 7.5 cubic feet. We add that in to our CargoFlight, Remember that since our CargoFlight extends Flight, it's going to have access to the characteristics of the Flight class. So our Flight class has this add1Passenger method, so with a cargo flight, we can go ahead and new up an instance of Passenger, in this case Jane, and still add one passenger, Jane, to the cargo flight. So we've got these extended capabilities, as well as the base class capabilities. As we work with a derived class, instances of that derived class can be assigned to references of the base class type. So if we take a look at some code for that, remember that we still have our CargoFlight here that extends the Flight class, well, we can go ahead and create a reference of type Flight f, and then new up a CargoFlight and assign it to that reference. What that means then is that as a flight reference, it can use the flight capability, so we can new up a passenger and of course add one passenger, Jane, to that flight. The thing is that we only have access to capabilities that are visible to the Flight class. So if we try to do f.add1Package, even though CargoFlight knows how to add one package, a Flight doesn't, so that wouldn't be a valid call because we can only access methods that are visible to the reference type. The value of this capability, though, it allows us to perform flight‑based actions without being concerned about the specific type of the instance. So we can think about a situation like this, say we create an array of flights, we'll call it squadron, it makes room for five flights, well, we could have the first member of that be an instance of the Flight class, the next member be an instance of the CargoFlight class, and keep mixing that up. So we have another CargoFlight, a Flight, and another CargoFlight. And again, we can loop through this doing all the flight‑based stuff. For the CargoFlight ones, we may want to do some extended things for CargoFlights, but it allows us to very easily group these actions.

Member Hiding and Overriding
When we're adding behavior to a derived class, that derived class can of course have fields as we've seen. The thing is that if the derived class adds a field that has the same name as a field in the base class, it will actually hide the base class field. Let's see what that means. If we take a look at our code here, and remember that we have our Flight class, and as we've seen, our flight class has a method called add1Passenger, now inside of our add1Passenger. It will check to see if we have enough seating. If so, we had the add1Passenger. If not, we handled a case of too many, and away we check and see if we have enough seating is that we have a method called has seating. What has seating does is based looks and sees that as long as the number of passengers is less than the number of seats, then we'll say we have seating. So our flight class has a field called seats with a value of 150. So if we create an instance of our flight class and add it to a flight reference called f1, if we print out the value of f1.seats, we will of course get 150. Now if we take our CargoFlight class that extends the flight class or it inherits from it, if it adds its own field called seats with the value of 12, which might make sense, right if a plane is a CargoFlight, it may have fewer seats, if we then go out here and create an instance of the CargoFlight class and assign it to a reference of type CargoFlight called cf, if we printout the value of cf.seats, that gives us a value of 12. The CargoFlight seats field is hiding the flight seats field, but now something unexpected can happen by doing that. If I now create an instance of the CargoFlight class, and I assign it to a reference of type flight that we've called f2, when we print out f2.seats, what we will actually get is the value 150, because the seats value of 12 is only visible when the instance is being worked with as a CargoFlight. Because the reference here f2 is of type flight, it doesn't know anything about the seats value of 12, it only knows about the seats value of 150. That becomes really important as we start using methods from the base class. Alright so if I take f2.add1Passenger, when that calls into the method to add1Passenger which then in turn calls hasSeating, when it checks the value of seats, it's going to use the value of seats that's defined inside the flight class, which is 150, which would allow us to add 150 passengers to a plane with only 12 seats. Now, and this is not limited to the scenario where the reference is of type flight. If we were to say, cf.add1Passenger, and cf is of type CargoFlight, again because add1Passenger calls hasSeating, and hasSeating is implemented inside the flight class, it would still use the value of 150 because within that method, it only knows about the fields defined within flight. So you can see this idea of hiding fields is a very dangerous thing, so I'm going to go ahead and highlight that in red. Now when we work with methods it's a little different. Methods can override base class methods. So if you have a derived class and it has a method with the same signature as a base class method, it will override it. Remember, the signature means it has the same name and the same parameter list. Let's see how overriding differs from hiding. So we have our class here, CargoFlight deriving from flight, same exact code we saw before. What we're going to do here is that where we set seats equal to 150 as a field, what we're going to do is get rid of that field seats, and we're going to change it to a method called getSeats that returns value of 150. Of course that means that our hasSeating method has to be changed to get rid of seats, and instead call getSeats, and then our derived class, CargoFlight, will get rid of its field seats, and added a method called getSeats that returns 12. So now if we work with this, we go out here we have our flight reference f1 assigned the value of a new flight instance. Of course when we print out getSeats, it's going to print out 150. If we have a CargoFlight reference cf pointing to a new instance of CargoFlight, when it prints out getSeats, it will print out 12. Well here's where we see the difference. If I now have a flight reference called f2 assigned to a new instance of CargoFlight, when we call getSeats, because the getSeats method from CargoFlight overrides the GetSeats method from flight, we will now get the appropriate value of 12, so the method and derived class has overridden the base class method, and that's really important as we start to do further work. So if I take my f2 a reference of type flight and call add1Passenger, it calls into that add1Passenger method, inside of add1Passenger, we call into hasSeating, when we get into hasSeating, when it calls getSeats because the instances of type CargoFlight, the implementation of getSeats inside of CargoFlight is actually what gets called returning the appropriate value of 12. So it will only allow us to add 12 passengers, and that works whether we have a reference like f2 of type flight, or reference cf, which is of the appropriate type CargoFlight. The method in the base class is actually being overridden, assuring that the appropriate method implementation gets called based on the type of object created, not the type of reference used. If you come from other object‑oriented languages like C# or C++, something that may stand out to you here is that you'll notice that we didn't have to do anything special to be able to override that getSeats method. In Java, all methods are automatically overridable unless you do something special to say that you don't want them overridden. We'll talk about how to do that a little bit later in this module. Now one of the things that may come to mind now is that, well how do you make sure that you haven't accidentally made a mistake in terms of maybe not matching the signature correctly? What Java provides is the override annotation, and what this tells the compiler is that it is your intention to override a method from the base class, so the compiler will actually check and make sure that the base class has a method with that signature. So it's kind of just a sanity check to make sure that the method you're declaring really does replace a method in the base class, has no impact on runtime, it's only used at compile time.

Object Class
One of the built‑in classes that Java provides is the Object class. And the Object class is the root of the Java class hierarchy. And what that means is that every class in Java, whether it's a built‑in class or one you create, has the characteristics of the Object class. What that means is that using the Object class, we can declare references that can point to any class type. Alright, so it can be variables, fields, parameters, and because arrays are classes, Object can even point to arrays. So it's really kind of this kind of universal reference type, but it's more than that, the Object class actually has methods that are defined on it, so that means that there are specific characteristics and capabilities that are common to all classes. So if we look at the idea of inheriting from the Object class, every class inherits either directly or indirectly from the Object class. Let's look at some of the classes we've written throughout this course. Alright, we have our Flight class. Alright, so if we were diagramming this, we might just kind of a draw box representing the Flight class. And then of course we have our CargoFlight class, so we'll draw a box for that. Now remember that when we declared the CargoFlight class, we said that it extends the Flight class, alright? So the way we diagram that is that we just drawn an arrow up to Flight saying that CargoFlight inherits from the Flight class. Now looking at the Flight class, there's nothing about it extending anything, but what's implied in that class declaration is that the class Flight extends the Object class. Alright, so by not saying what it extends, it implicitly extends the Object class. So to diagram that, we would have the Object class, and Flight inherit from that. You could actually write extends Object after the Flight class, it just wouldn't change anything. Having nothing there has the same effect. So if we look at our Passenger class, alright, we don't say it extends anything, but when we diagram it, it's still extends Object. So what we see here is that whether classes are related to one another or not, they always extend the Object class, meaning that we can treat any class as an object. Alright, so put that into practice, so let's declare an array, we'll call stuff, right, it's type is Object, and we've created three spots in it. So maybe the first element holds a reference to an instance of Flight. The next one holds a reference to a Passenger instance, and we could even add another one that's a CargoFlight. To see what it's like to work with object references, let's go here and declare Object o that points on instance of Passenger. Once we do that, that same variable o can also be used to point to an array of Flights. Now to be very clear, right, on the left, we made an Object array that's pointing to lots of different class types. On the right here, we're simply saying that because arrays are classes, we can assign an array to a variable of type Object. Now we wouldn't have access to any of the array characteristics of it, but we can hold the reference. Alright, we now take that same o and point it to an instance of CargoFlight. But again to reinforce that idea, remember that when we have a reference of a given type, we can only access the capabilities that are visible to that reference. So if I was to try to take o and call add1Package, a method that's specific to CargoFlight, alright, that's not going to work because the reference o doesn't know anything about this idea of add1Package. Now, does that mean that the object we created, CargoFlight, is any less CargoFlight because the reference o can't get to the CargoFlight capabilities? Of course, the answer is no. Alright, let's see what this means in terms of what's happening here. Remember that we declared our reference o of type Object, we new‑ed up a CargoFlight, and of course o then holds the reference to CargoFlight. So even though o only knows about object capabilities, it's still pointing to a CargoFlight object. So we should be able to get back to those CargoFlight capabilities. Alright, and so we can actually do that. So we could declare a variable, and we'll call it cf, and assign it what's in o. Now, if we tried to use this code as it is here, we would actually get an error because the compiler would look at that and say, well, wait a minute, o can point to many different types, there's no way for the compiler to know that there'll actually be a CargoFlight in there. So what we can do is add an explicit cast that says now I know there's a CargoFlight in there. Now we want to make sure that it's true because it wasn't true, we'd actually get an error at runtime. Alright, so what happens now when we make this assignment, we've got our reference cf, but cf understands CargoFlight, and it ends up pointing to that same object that was in o, CargoFlight. So now using cf, we can call add1Package. And again to reinforce point here is that we want to make sure when we made that assignment that there really was a CargoFlight in o. If there's any doubt about that, we can verify it in code. We can wrap this in a condition that says, well, if o instance of CargoFlight. What that'll do at runtime is it'll actually look at the object pointed to by o, and make sure it actually is a CargoFlight. If it wasn't, we wouldn't have run the code in there that assigns it to the CargoFlight cf. Now looking at our Object class, the Object class is not just for references, it actually has characteristics, it actually has methods that are built in. Now we're not going to go into all these in detail right now, but I just want to make you aware of them. One of the built‑in methods for the Object class is the clone method, and that allows an object to create a duplicate of itself. There's some caveats to working with that we're going to talk about later on in the course. Another method that's available to the Object class, and therefore to all classes, is hashCode. It returns back a hash code that's used for working with things like hash tables and other types that rely on hash tables. The getClass method returns back type information about an instance. The finalize method is part of a resource cleanup. In most cases, you won't do very much for the finalize method. Then we have the toString method that returns back a string of characters representing a current instance. We're actually going to talk about that one more in the next module. And the last one is the equals method, which you use to compare one object instance to another. We're actually going to talk about that one in the next clip.

Equality
Let's look at the issue of equality, when we have two references to objects. What does it mean when we ask, are they equal? And the answer to that is actually, well, it depends. I'll show you what I mean. Let's have some code here. Let's first created instance of the Flight class. We'll give it a flight number of 175 and assign it to the reference f1. Then we'll create another instance of the Flight class, give that one a flight number of 175 as well. In this case, we assign it to the reference f2. So f1 and f2 point to two separate instances of the Flight class, both with the flight number 175. So if I write the code to say, if f1 == f2 using the equivalents operator, the ==, the comparison there will resolve to false because the == operator performs what's called a reference equals test. In other words, do both of these references point to the exact same object instance? So when you use this == operator, it only resolves to true with reference types if they're both pointing to the same object. Remember that we've been talking about the Object class, and we mentioned that the Object class has an equals method on there. So maybe that's the answer to how we compare these to see if they're equal. So we'll do an if f1.equals passing in f2. If we run this code, what we'll get is false again. The default implementation of the equals method, in other words the one that we get from the Object class, also performs a reference equals test. In other words, it does the same thing as the == operator. It only resolves to true if both references point to the exact same object instance. But the good news is is that because our Flight class, like all classes, inherits from the Object class, we can override the equals method. So let's bring up our Flight class here. Remember that our Flight class provides two different ways to identify a flight. A flight can have a flightNumber, or it can have a flightClass. We don't set both of those. We only set one or the other. And so the way it would work is that we would have a flightNumber with no flightClass or a flightClass with no flightNumber. So we're going to say that we're going to consider two flights to be equal if their identifying information is the same. They both have the same flightNumber without a flightClass, or they both have the same flightClass without a flightNumber. So what we're going to do is override the equals method. Now the equals method returns back a boolean. So we have a boolean return type, our equals method name. And if we look at the definition of equals in the Object class, the equals method has one parameter, which is an Object. Now what we're going to do here is go ahead and mark this with the Override annotation just so the compiler will double check us and make sure we've gotten our signature correct for the equals method. So now when we call f1.equals passing in f2, f2 will be passed into the parameter o. Now remember that because o was declared as an object, it will only have access to members that are known by object. It won't have access to the flight members. So what we need to do is take that o, cast it to a flight, and put it into a reference of type Flight. So that'll be our other variable here. So now other will have access to the flight information from f2. So what we're going to do here then is have the test is that well if the flightNumber for the current instance, which is f1, matches the flightNumber from the one passed in, which is f2, and the Flight class from both of those match, we're going to consider them equal. So the idea is that if the flightNumber was set, they'll both have the same flightNumber, but flightClass will that the default value, which is the null character. If the flightClass was set, they'll both have the same flightClass, but the flightNumber will have the default value, which would just be a 0. So we're just going to return back that value so that now when we call equals, we are now comparing the two flight instances based on their identifying information. Now this is how we've defined equals in this particular situation. In your individual programs, you're going to have to identify what equals means because we might have decided that well, for two flights to be equal, not only does their identifying information have to be the same, but maybe the number of checked bags also has to be the same. It's up to us as we define our problem space and the problem we're trying to resolve. So now, relying on this idea that as long as the identifying information is the same and they're equal, if we go back now and look at the code. First, the if f1 == f2, well that's still going to resolve to false because that's still a reference equals. It's only true if both f1 and f2 point to the exact same object. But now our if f1.equals passing in f2, that now resolves to true because both f1 and f2 have the same flightNumber. But now let's look at another situation. What if we go off and create an instance of a passenger, and then we say, well, if f1.equals passing in the Passenger. Since equals accepts an object as its parameter type, it's valid for p to be passed into that parameter o. But what's going to happen now when we try to cast o into a flight? It's going to go ahead and create an error. So one of the things we have to do is make sure that in our equals method, we don't try to compare against any type we can't validly be compared to. Well we know that we can take that o and check to see if it's an instance of the Flight class. Well what we want to do here is say that well, if it's not an instance of the Flight class, we just want to get out of here. So what we'll do is just go ahead and wrap that instance of comparison in the not operator. And then if o is not an instanceof Flight, we're just going to go ahead and return false. So our comparisons that compare two flight instances won't be changed, but this situation where we're trying compare a passenger who can't really be compared with a flight, that will now return false. The key thing to understand here is that we need to override equals to provide our definition of equal, and the specific definition of equal is going to be specific to your problem space.

Special Reference: Super
From our discussions in previous modules, we know that Java offers references that have special meaning, like null and this. Another one of those special references is the super reference. Like this, super provides access to the current object, but where super is different is that super treats that object as if it's an instance of its base class, and it allows us to access the feature of the object as if our current class has not overridden any of those features. And this comes in really handy when we're implementing something in our current class and we want to get to the features or a method exactly as they behaved in the base class. Let's take a look here at our Flight class. As you recall from the previous clip, we've overridden the equals method to compare two flight instances based on the flight identification information, the flight number and flight class. But let's look at some code here. I say we go ahead and we create an instance of flight with a flight number of 175 and assign it to f1, and then we declare another reference, f2, and assign it f1. So now f1 and f2 are pointing to the exact same flight instance. So now if we say if f1 equals passing in f2, that's going to call into our equals method, and now what's it going to do it? It's going to go through everything we've written inside of equals. It's going first make sure it's actually instance of flight, and it's then going to cast the flight passed in, and then we're going to compare the values of flightNumber and flightClass. Now, in this case, the work that we're doing there is not that substantial, but in some cases, an equals method may actually have to test a lot of things. In a complex object, there may be a number of fields to compare and other operations that you have to go on. The thing is that we know the base class object implements a version of equals that just checks to see if two references point to the same object, and reference comparisons like that are actually really inexpensive. So it would be great if inside of our equals method, maybe what we could do here is say, well, if the reference passed in points to the same object that we currently do, well, we know they must be equal because they're the same object, let's just get out of here. So let's update our equals method to do that. So let's go ahead and make a little room inside of our equals method here, and what we'll do is put an if at the very beginning, and we'll simply say, equals passing in o, and if that returns true, we'll then in turn return true. Now, of course, the problem here is that as we've written this, when we call equals inside this if statement, what are we going to do? We're going to call back into our own equals method, which will then again call back into our own equals method, and just do that repeatedly actually until we crash with an error. What we really want to do is at this point call equals as it was implemented in our base class. And that's where the super reference comes in. So we've got to move that equals over, and we put super in front of it, what will happen now is that when we call into the flight implementation of equals, the first thing that we do inside that implementation is call into our base class implementation, which compares to see if both references point to the same object. If they do, we just exit out of here. If we didn't, we would then go through and do the other tests that we've built inside of our equals implementation. So we've been able to access that base class behavior when we wanted to, but still have our overridden behavior when we needed it.

Using Final and Abstract
As we've seen, Java makes it very easy to extend classes and override methods. In fact, by default all classes can be extended, and when you inherit from a class, you have the option of using the methods as they were written in the base class or overriding them. But sometimes that may not be what you want. Maybe you want to put more controls on that. And it turns out that a class can change these defaults. It can control whether it's allowed to be extended and how overriding methods works. One way it does that is using what's called final. Final allows us to prevent inheriting of an entire class or the overriding of certain methods. Let's take a look. Let's say we have our class here, our Passenger class that we've seen before, but let's say we've decided that, you know, we don't want to allow any specialization of the Passenger class, we don't want to allow anyone to extend this class. Well, all we have to do is take the Passenger class and mark it as final. By marking it as final, simply put, you cannot inherit from it anymore. You're not allowed to extend that class. One thing to note, though, is that the order of public and final here doesn't matter. If we want to, we can switch the order of those. Still has the exact same effect. So marking a class as final is a very simple thing. It simply blocks extending that class. But very commonly, what we want to do is allow a class to be inherited from, but have certain methods we do not want to allow them to change. Let's take a look at our CargoFlight class here. Say we want to go ahead and allow people to inherit from CargoFlight and specialize CargoFlight, but we want to make sure that they don't change the way that adding a package works. So what we can do is take our add1Package method and just mark that method as final. By marking the method as final, now you can inherit from CargoFlight, but you cannot override add1Package. You can go ahead and override other methods that might be in a class if you have access to them, but in the case of CargoFlight, there are no other methods that you can override because add1Package is final and hasCargoSpace and handleNoSpace are both private, so a deriving class couldn't change those. Now, methods that are inherited from flight could be overridden. All right, so we're just very selectively blocking what can be overridden. In the case of final, you'll generally either mark the class as final or an individual method as final. Because once a class is final, there's no reason to mark individual methods as final because you can't override anything if you can't inherit from it. So final is a method or class situation. Now there may be another situation where, instead of trying to prevent inheritance, you want to go ahead and require inheritance. And that's where abstract comes in. Abstract allows you to require that a class be inherited and require that a particular method be overridden. Let's see what that looks like. Let's create a new class here, we'll call it Pilot. And so we have our Pilot class, and we'll go ahead and a pilot can fly a flight, so we'll have a currentFlight field, and we'll add a method called fly that accepts that Flight. And what we'll say is that, well, if the pilot can accept that flight, we'll go ahead and assign the flight to currentFlight. If they can't, we'll go ahead and just handle that case if they can't accept it. For handleCantAccept, we'll just do what we've been kind of doing, is simply printing out a message. But when it comes down to the idea of whether the pilot can accept the flight or not, that's going to depend on what kind of pilot it is, and we want to leave that to the classes that inherit from pilot. So what we'll do is we'll go ahead and mark something as public, and I'm going to say now abstract, and then we provide our standard method signature. So it's a public method called canAccept, returns a Boolean, but but saying it's abstract, we're saying that we're not going to provide an implementation. Now, since we're not going to provide an implementation, what we do is that rather than providing a method body, we just put a semicolon at the end. So we're simply saying that the class Pilot has a method called canAccept. We don't know what the implementation of that method is, but it has that method. And what that allows us to do is use canAccept in other methods in the class, like in this case, the fly method. Now, once you mark a method as abstract, that means the entire class must be abstract. So we'll go ahead and mark the class as abstract as well. So when it comes to abstract, if you have an abstract method, you have to mark the class as abstract. It's possible to mark a class as abstract and have no abstract methods, but that's not very common. Normally you'll have one or more abstract methods in any abstract class. So now the way we work with this, right, let's go ahead and define a pilot, we'll call our CargoOnlyPilot. That extends our Pilot class. Because it extends our Pilot class, it has to provide an implementation for canAccept, so we'll go ahead and set that up. We'll go ahead and use the override annotation, and what we'll say inside of here is that a CargoOnlyPilot is not allowed to have a passenger. So we'll take the flight, call getPassengers, and we only return true for canAccept if there are no passengers at all. And then we have another class called FullLicensePilot, and he's kind of our super pilot, where he's allowed to fly any flight. So we'll override canAccept for him, go ahead and mark it with the override annotation, and he's simply going to return true all the time, saying he's allowed to fly any flight. All right, so it allowed us to define basic characteristics and behaviors in the Pilot class, but then requires specific specializations in any derive class.

Inheritance and Constructors
An issue that's very important to understand as we look at the idea of inheriting one class from another, is that in Java constructors are not inherited. Each class is responsible for defining its own constructors. A derived class, though, must always call one of the base class constructors. So as you define the constructors inside of your derived class, there's always going to be a call back to a base class constructor. Now that call does not have to be explicit. If you don't have an explicit call to a base class constructor, then it will use the base class's no‑argument constructor, but you can call a specific constructor if you want to. You simply use the super notation, followed by the list of parameters that correspond to the base class constructor that you want to call. You do have to make that the first line in your constructor, though. Let's see what this looks like in code. Now we've looked at our Flight class, and we've done a bunch work with that until now, and I want to focus in on the no‑argument constructor and it's a constructor that accepts a flightNumber, and that allows us to create code. It creates an instance of a flight, in this case creating a new flight with flight number 175. Now our CargoFlight class that has a number of members inside of it, has no constructors defined. That, of course, means that we can create an instance of CargoFlight using a no‑argument constructor because Java provides an no‑argument constructor for us by default if we haven't specified one. But if we try to go off and create a CargoFlight with a flight number, that's not going to work, and we get an error, because even though our base class Flight has a constructor that accepts a flight number, CargoFlight does not. So if we want to be able to create CargoFlights with a flight number, we need to define a constructor in CargoFlight that accepts a flight number. Now we don't have to do that work ourself. As we said, we can delegate that to the base class by simply using that super notation and passing in flightNumber. And so now we can go ahead and construct a CargoFlight with a flightNumber, in this case 294, that calls into our CargoFlight constructor accepting a flight number, which in turn calls the implementation inside of Flight. Now we can, of course, extend behavior beyond the base class constructors. For example, our CargoFlight class keeps track of the idea of the maximum cargo space. So we could go off and define a CargoFlight constructor that accepts flightNumber and a value that we want to use for maxCargoSpace. Now, inside of the CargoFlight constructor, we can, of course, set maxCargoSpace. If we want to go ahead and call up, though, to the base class constructor, we again use the super notation, but it has to be the first line of the constructor. So this would call into the Flight constructor that accepts a flightNumber and then set maxCargoSpace. But in this situation, rather than call into the base class, we've already done work inside of our class to create a constructor that accepts a flight number, so rather than call super in this case, it would be better to go ahead and use this. So now if we go off and we create code that says I want to create a CargoFlight instance that accepts a flightNumber and MaxCargoSpace, it'll call our CargoFlight constructor that accepts those two parameters. We'll then call up to our CargoFlight constructor that accepts the flightNumber, and then that calls into the base class constructor that accepts flightNumber. Now something that has happened is that as we've added these two constructors to CargoFlight, we've broken a line of code, right? The line of code where we created a CargoFlight passing in no parameters, no longer works. If we want to have that, we need to go ahead and add that to our CargoFlight class. So now this code would build again, and when we call into our CargoFlight constructor, it will then call into our Flight class's constructor that takes no arguments, right, and that happens because we did not specify any base class constructor. Alright, so let's say we add another constructor to our CargoFlight. This one accepts only cargo space, and all we do inside of here is set maxCargoSpace. So we now create a line of code that news up a CargoFlight passing in only maxCargoSpace, what does this do? Well, it calls our constructor, but before it executes the body of our constructor, it will call up to the Flight class's constructor that has no arguments, and then run the rest of our constructor, right, so it always calls into a base class constructor even when we don't specify one.

CalcEngine with Specialized Classes
In this demo, we're going to use what we've learned in this module to see if we can make our CalcEngine program a little bit easier to manage and maintain. Here we are inside of our CalcEngine program, and what I want to focus on is this MathEquation class. If we take a look at this class, it has a number of distinct responsibilities, some that are common to all operations and some things that are specific to an individual operation. If we look here, first of all, it declares all the fields necessary to do the work. Then it has to have getters and setters for all those fields. Then it has the variety of constructors. And if we scroll down here towards the bottom, we get to this execute method which actually is doing a number of different things. And what I've found is that when you see code like this, we've got a big condition like this, and there're individual tasks inside of there, as a program gets more complex and you start to work inside this method, this is a place where very often enhancing or modifying the program will introduce errors because we've got a bunch of kind of loosely related code kind of clumped together. This is a great opportunity for us to use the class inheritance features of Java that have a better division of responsibilities. So what I want to do is go here, and I'm going to go ahead and add a new class, and we're going to call this class CalculateBase. So I'm just going to go ahead and new this guy up, and, as I mentioned, we'll call this class CalculateBase. And based on this name, you can tell that it's probably going to be a base class. So other classes are going to inherit from it. That's not a requirement. It's just something I tend to do when I know a class is going to be used only as a base class. This class will actually act as a common point of inheritance from all of our separate operations. So the thing that's going to be common to all these operations is the series of fields we need to declare, leftVal, rightVal, and result. In addition to that, we're going to have getters and setters for each of those fields. So that takes care of the fields. And now we need some constructors. Now we'll, of course, want our no argument constructor. So we'll just say public CalculateBase and then give it an empty body. Let's go ahead and create our other constructor. We'll call this one, again, public CalculateBase. And in this one, we want to get our leftVal and our rightVal. And, of course, inside of here, we're going to go ahead and set those into the fields. So now we have all of our value management, the ability to store the values we need, store the result, get and set those values and result, and then construct the instance of CalculateBase. The next thing we want to do is have this idea of performing an actual operation, we'll actually do a calculate. But the way we actually calculate will be different for each class that inherits from this. So what we're going to is go ahead and create a void method called calculate. But because there is no single definition of calculate, we're going to go ahead and make this one abstract. And, of course, as an abstract method, it has an empty body. And because there's an abstract method, we need to go ahead and make the class abstract as well. So that gives us our base class for all of our operations. Now let's go and create a class that inherits from CalculateBase that does the individual operation. Let's start with Adder. So, again, we'll add a new class. We'll call it Adder. So we'll extend CalculateBase. So inside of here, we want to have the constructors that we need. So, again, we'll have the no argument constructor, and then we'll have the constructor that accepts left and right values. And inside of here, we're just going to call up to our base class constructor that accepts those same values. So with that simple bit of code, we've now taken care of kind of linking this derived class to the base class and passing the values that we need into the base class. So now the last thing to do here is just go ahead and implement calculate for this implementation. So we'll call it again public void calculate. So we have our method there. Let's go ahead and put the @override annotation on here. So now inside of here, we'll go ahead and implement the way an Adder does its calculate, and all we're going to do is add the two values together. So we'll declare a local variable here. So now we've got to perform this operation. If I try to use leftVal and rightVal directly, it's not going to work because those are marked as private inside the base class. So what we can do, though, is go ahead and still use the getters. So we'll say getLeftVal, and we'll add that to getRightVal. Now inside of here, we'll go ahead and store that in the results. We'll simply call our setResult and pass in value. And that's our complete Adder implementation. And you see what we've done here is that the Adder class is very focused on a very specific capability, adding values together. If we go ahead and create a subtracter, it's going to be very much the same, so we'll go ahead and add that class in. Again, we'll call this Subtracter. So Subtracter will, again, extend CalculateBase. We'll have those same constructors we had before. We have the no argument constructor and then one that'll accept the left and right values. Again, we're going to go ahead and override calculate. Then inside of here, we're simply going to subtract one value from the other and store it back in result. And then we're going to do that same thing with a divider and a multiplier. So we now have the four operations, the Adder we created earlier, Subtracter, and if I look at Divider, it looks just like the other classes except calculate does division, and Multiplier, it looks just like the other classes except calculate does multiplication. So we now have our four classes that inherit from CalculateBase. So let's go to our Main method now, and let's go ahead and use these classes. So I'm just going to scroll down here to the end. The first thing we'll do is just go ahead and print out a little message in the output window so we can see where the result of our new code starts. So we simply print out that message using inheritance. And then here we'll go ahead and do the work that we can do using our new classes. So remember that all of our classes inherit from CalculateBase, so let's go ahead and declare an array of type CalculateBase. So we have our array, and its name is calculators. And let's go ahead and use the bracket style initialization syntax. So what we'll do inside of here is just new up each one of our classes. So, first, I'll new up a Divider that accepts 100 and 50, then put a comma. Now let's go ahead and new up an Adder, and we'll go ahead and new up a Subtractor and a Multiplier as well. So now we have all four operations in here. I'm just going to go ahead and move this Divider over so it lines up with the rest of them. So our CalculateBase can do all four operations, and we're using the same values here we've used earlier when we were using our MathEquation class. So now with that set up, what we can do is now loop through that array. So let's go ahead and do a for loop. We'll declare our variable CalculateBase called calculator. It's going to loop through our calculators. And then inside of here, all we're going to do is for each calculator call its calculate method, and then we'll print out the result for each one. And so now we have new complete functionality using the four basic operations. So if I go ahead and run this now, our program completes, let's just enlarge this output window a little bit so we can see, and we see we have our four results here. Dividing 100 by 50 gives us 2, adding 25 and 92, again, gives us 117, 225 minus 17 gives us 208, and multiplying 11 by 3 gives us 33. So everything works just as expected, and everything works just as it did before. The key difference here is this idea of manageability and maintainability, kind of localization of responsibility. If I go into my MathEquation, again, this execute method is reasonably complex given the simple things that we're doing. And it's this kind of code that easily breaks when you're enhancing a program or changing a program. If we compare that execute method to the Adder class's calculate, which is two very simple lines, you see that changing behaviors is going to be much simpler in this environment as a result of having used inheritance and then specialization in the derive classes.

Summary
To wrap up, our focus in this module was on inheritance. Inheritance allows us to create a class that has the characteristics of another class. In Java, we use the extend keyword to identify that one class is deriving from another. Derived classes can override base class methods. In other words, we can provide our own definition of those methods' behaviors. In Java, methods are automatically overridable, but you can optionally include the @Override annotation, which just causes the compiler to verify that there's a base class method with the signature you're trying to override. The Object class is the root of all class hierarchies. Every class in Java inherits from it either directly or indirectly. It gives us the idea of a universal reference type, and it also provides us with a set of known characteristics that all classes have. By default, when you compare two object references for equality, they're only considered equal if they both point to the exact same object instance. But this is a scenario where the Object class comes in handy. The Object class defines an equals method that we can override, providing more specific definition of equals for any given class. When we're overriding methods, we'll often need to have access to base class behaviors. Using the super keyword, we can access our current object instance as if it were an instance to the base class, and that allows us to get to those base class behaviors. We will sometimes want to have tighter control over inheritance behaviors, and that's where the final and abstract keywords come in. If a class is marked final, you're not allowed to inherit from it. If a method is marked final, it can't be overridden. If a method is marked abstract, it must be overwritten, it doesn't actually have a body, and any class that contains an abstract method is itself abstract, meaning that that class must be inherited from. And finally, remember that constructors are not inherited, every class is responsible for providing its own constructors, but constructors can call into their base class constructors, again using the super keyword, with the parameter list of the base class constructor they want to call into.

More About Data Types
Introduction
Welcome to the next module of the Pluralsight Java Fundamentals course on the Java language. In this module, we'll talk more about data types. My name is Jim Wilson. As we go through this module, we'll first look at the string class and how to work with string values. We'll then look at how we can work with strings and manipulate strings more efficiently using the StringBuilder class. We'll see how we can bring the capability of classes to primitive values using the primitive wrapper classes. We'll see how to create fields that can't be changed once set using final fields. Then we'll finish up with enumeration types, which allow us to define types that can only hold a finite list of values.

String Class
Earlier in the course, we talked about the char type, which allowed us to work with individual characters. In practice, we tend to work with sequences of characters more than individual characters, and that's where the String class comes in. It stores a sequence of Unicode characters. It stores them using the UTF‑16 encoding, which basically means that the Java String class can store pretty much any character you're likely to ever want to work with. Working with strings is really straightforward. Literal strings are enclosed in double quotes. So let's say we want to have a variable called name and assign it a literal string, we simply declare it as string and assign it the literal string Jim enclosed in quotes. We can easily combine string values using the plus or plus equal. Plus combines two strings and gives you back a new strength. Plus equals adds a string onto the value of an existing string. So if I want to do something like print out Hi Jim, I can use our println method, put the literal string Hi, and then add a plus sign and name after that, and that will print out that value, Hi Jim. Now one thing to be aware of is that string objects are immutable, and what that means is that once the string object is created, it can never be changed. So anything that changes that value requires that a new instance of the string object be created. So let's see what that looks like. Let's again declare a variable called greeting and assign it the literal Hello, so of course I've got my variable that a string is allocated out in memory holding the value Hello. Of course the variable greeting, then references it. But then if I do something as simple as greeting += space, now all I want to do is add a space onto the word Hello. In order for that to happen, a whole new string object has to be created holding all the existing values, the hello plus the space, and then greeting is repointed to that new instance. So it'll feel like just the space was added on to the end, but actually a whole lot more is going on. So if I then announce that greeting += world, again it allocates out another object holding the entire string and repoints greeting to that. So we want to be aware of this idea of strings being immutable because we can end up doing things really inefficiently. Now later in this module, we'll talk about how we can use other mechanisms to work with this string situation like this more effectively. Now the String class has a number of methods on it. We're not going to talk about all of them, but I just want to point out some of the highlights here. One of the methods we commonly use is the length method, which gives us back the length of the string, how many characters are in that string. Very often we want to convert non‑string values in the string, so like maybe we have the integer value 100, we want to get back to characters 1 0 0, the string method valueOf will do that. The String class provides methods for creating a new string from existing strings. Concat combines two string values to create a new string, basically the same as the plus operator. Replace, toLowerCase, toUpperCase, and trim create a new string based on modifying values of an existing string. The split method is useful for cases where you have a delimited string, like a list of comma delimited values. It will give you an array of strings back of the individual values inside that original string. We can do string formatting. We can extract a substring from existing string. We can check for the presence of a substring in an existing string. And, of course, we can do comparisons. CompareTo and compareToIgnoreCase check to see if one string is greater than, equal to, or less than another string based on the Unicode character sequences. IsEmpty tells us whether we have a zero length string. Then equals and equalsIgnoreCase, obviously, check for equality. Equals checks to see that we have the exact same character sequence in two strings. EqualsIgnoreCase does the same thing, but ignoring the case, of course. The thing is, equals actually raises some interesting issues that we need to talk about, which we'll talk about in the next clip. To get the full documentation on the String class, just check out that URL I have on screen.

String Equality
Let's take a look at the issue of comparing strings for equality. Let's say I have a string I'll call s1, and I assign it the value I space Love, and then I add on space Java to the end of that. Then I have another string we'll call s2, and I set it to the value of i and add on space Love space Java. So now we have two strings, s1 and s2, and both them have the value I space Love space Java. So now if I compare them for equality using the == operator, what I'll get is false. And let's see why that's the case. So if I look at s1, it contains the value, as we said, I space Love space Java, and, of course, the variable s1 references that. And if we look at s2, what it also has, I space Love space Java, and s2 references that. But remember that the == operator compares values based on whether they both point to the exact same object instance. Now what we see here is that s1 points to one instance, and s2 points to another. So they're not equals by the definition of the == operator because they don't point to the same object instance. And that's where the equals method comes in. The equals method does a character‑by‑character comparison. So as long as the character‑by‑character comparison of the two values matches, then in that case we get true. So in most scenarios of comparing strings for equality, we're going to use the equals method. Now something to consider though is that reference‑based comparisons are actually quite inexpensive, whereas character‑by‑character comparisons can be very expensive, particularly in very long strings. So it would be nice if we had situations where we're going to do a lot of comparisons of particular string value. It might be nice to take advantage of that inexpensive nature of reference‑based comparisons. And that's where the intern method comes in. The intern method gives us back a canonicalized reference of a string value. And let's see what that means. So let's say I declare another string variable, s3, and I assign it the value of s1.intern. Again, intern returns back a canonicalized value, and that's a fancy way of saying when you call the intern method on a string value, it will always return back the same exact string object for a given string value. So when we call s1.intern, we get back the canonicalized reference to I space Love space Java. S3 gets assigned a reference to that. So now if I say String s4 = s2.intern, s4 will get a reference to that exact same object instance. So the intern assures that two strings with the same value will reference the exact same object. What that allows us to do then is use that very inexpensive == operator to do the comparison, so s3 == s4 returns true. As you might expect, there is a bit of overhead to interning a string. So in general, when you're doing a series of one‑off comparisons of strings, you'll use the equals method to do that. But when you have situations where you expect to do a lot of comparisons to a given set of string values, that's where the intern method comes in. You'll often intern a series of string values you expect to search over and over again and put those into an array or some other collection. And then as you search that collection, you will then intern the incoming values and use that very inexpensive == operator to see if you can find the value in that array or collection of intern string values.

String Representation of Non-string Values
We often need to convert nonstring types into strings. Having a value as a string makes it easy to do things like build a message or display output to a user. The string class provides a helper method called valueOf that provides overrides that will handle converting many different types to strings. And using this is really straightforward. So we have something like an integer here, iVal, that we set to 100. If we say sVal = String.valueOf(iVal), sVal will get the string 100. Now valueOf is useful when you need to do those explicit conversions. But very often Java will take care of doing conversions to strings for you automatically. Let's say we have some code here where we have two integers. I has a value of 2, and j has a value of 3. If I say result = i * j, and I now want to display out to the user a full string showing the operation and the result. So I say i followed by + and the string (space) * (space). When Java sees that I'm taking an integer with a + and the other's a string, it knows that I actually want the string representation of i. So now if I go on to say + j + (space) = (space), then + results, Java will go through and convert i, j, and result to strings for us and then concatenate them all together so we get that complete string, 2 (space) * (space) 3 (space) = (space) 6. It builds that string together for us and took care of those conversions. Now, in this case, we're dealing with a very simple type, a primitive type, an integer. But what about things like more complex types, like classes where the string representation's not so easily known? Well, that's where the toString method comes in. Remember, we talked about that the object class provides some standard methods that all classes will have. ToString is the one we use to get the string representation of a class. Let's take a look at some code for that. Now remember that we have our Flight class that we've been using throughout the course. So here we created a Flight class instance with a flight number of 175. If I now say println, "My flight is " and then we simply concatenate on myFlight, what Java's going to do is call toString on the object referenced by myFlight. Now we haven't implemented toString in the Flight class, so it's going to call implementation from the object class. And what that will do is give us results that look something like this where, of course, we have that literal string, "My flight is ", but then what we get is the fully qualified class name, including the package that it's in, followed by an at symbol, followed by whatever value is returned by the hash code method. So that gives us kind of a unique representation of this instance, but it's not really very helpful. So we can improve that. So if we look at our Flight class, remember that our Flight class had two ways of identifying flights. A flight could be created to have a flightNumber, or a flight could be created to have a flightClass. So what we want to do now is have our toString method represent a given flight instance in a meaningful way. So we'll go ahead and override toString. And what we'll do here is we'll check and say, Well, if it's a flight that has a flightNumber, what we're going to do is return back the string Flight (space) # and then add on the flightNumber. If it's a flight that has a flightClass instead, we're just going to say Flight (space) Class (space) and whatever that class character is. So now if we take a look at this code over here, when we call println, what we're going to actually get out is "My flight is Flight #175." So now we're getting back a more meaningful string representation of that object instance. And that's what we want to do inside of our toString method is provide that meaningful representation of an instance as a string.

StringBuilder Class
As we've talked about, strings are immutable, and it means that any modification to a string results in the creation of a new string, and that's just not efficient. But there are, of course, times that we need to be able to efficiently manipulate strings, and that's where StringBuilder comes in. StringBuilder provides us with a mutable string buffer, providing us with an efficient way to manipulate strings. Now although you don't have to, when you create a StringBuilder instance, you'll get the best performance if you pre‑size the buffer. So if we look at some code here, I declare StringBuilder sb, say new StringBuilder(40). Well, that allocates out an instance of StringBuilder that has room for 40 characters inside of it. In fact, if we were to call the sb.capacity method on that instance, we'll get back the value 40. Now the StringBuilder will grow automatically if you exceed the capacity. But you want to minimize how often that happens because there's a fair bit of overhead each time the system has to grow a StringBuilder instance. StringBuilder has a number of methods available, but the ones we use most commonly are append, which lets us add new content to the end of StringBuilder, or insert, which gives us the ability to add new content within the body of the StringBuilder. So let's look at some code. So we have our flight we've been using here. We have flight #175. We'll have a string called location with a value of Florida in it. Let's say we want to build up a message. So we're going to go ahead and say sb.append("I flew to (space)"). Well, that adds it to the end of the StringBuilder. If we say that StringBuilders empty, that adds it to the beginning. So then when we say sb.append(location), it takes the value of location Florida, adds that on to the end. The literal string (space) on (space), that gets added on to the end. Then when we say sb.append(myFlight), well, myFlight is a class, so we'll go ahead and call toString on it. So we get Flight #175. So we've been able to build these four values together, doing it all in a single buffer. Let's say we come along a little further in our program, and we realize that we actually have access to the time of this flight as well. We want to go ahead and add that into the message, but we want to put it somewhere into the body of the message. Let's say we want to do it just before the space in the word on. Now since we know how many characters we've written into this buffer from the beginning, we could just count how many characters it takes to move over to get there. But let's say we didn't know that. Let's say that all we knew is that we've added content inside of here, and we've added the word on and then the information from our flight class, and we want to calculate where the insert point is going backwards, so from the end of the current values. Let's see how we would do that. So I'm going to declare a variable, position, and I just going to say sb.length. And that tells me how many characters are currently in the StringBuilder instance. Remember, capacity said how much space is allocated. Length says how much is in use. And we'll say that we want to go back to the length of that literal on. Now, honestly, I could have used the integer value 4 here, but I just wanted to show you that we can call string methods on string liberals, and then we'll use our myFlight.toString.length. So that now tells us how far back we have to go to get before that space before the word on. So now with that, I can now say something like sp.insert, give it the position, and then what I want to insert, which is (space) at (space). What StringBuilder will do is move over that on Flight #175 and then write the at in there. And then If I say sb.insert, pos + 4, and then I'm going to add the value of time in. The pos + 4 is just I want to get past that (space) at (space). Note that time is an integer, but insert will take care of doing that conversion. So now it'll move over the on Flight #175 and write that 9 in there. So now we've got our content built exactly as we want it, but it's not quite a string yet. The way we get the string out is the way we get the string out of any other class; we simply call the toString method. So inside of here, if we say String message = sb.toString, message will then get the actual string, I flew to Florida at 9 on Flight #175. So StringBuilder gives us a really efficient way of building and manipulating strings.

Primitive Wrapper Classes and Type Conversions
Throughout our discussions in this course, recently we've been talking about classes. And the thing we see when we talk about classes is that classes provide convenience. One of the conveniences is that all classes inherit from the Object class, so we can use Object as a standard way to interact with all class instances, so that's a good thing. Classes have fields and methods that are specific to that type, so it means that we can have values and operations directly associated with a type, so that's a good thing. One of things we need to be aware of though is that classes also have overhead. Every class instance has a certain amount of memory that's always taken up just by the fact that it's a class, and that's before it even has its own specific values inside of there. So, generally, we consider that little bit of extra overhead worthwhile to get those conveniences. The thing is that primitive types focus on efficiency where we use them a lot, so we want primitive types in general to be very lightweight. So the idea is that if you have a 4‑byte int, it simply occupies 4 bytes, nothing beyond that. So that's certainly a good thing. But now, in order to get that efficiency, we have to give some things up. We can't have fields or methods associated with primitive types. And primitive types cannot be treated as objects. And most of time, this division between classes and primitive types gives us kind of a really effective way to work. But there are times when we're working with primitive values that we're willing to give up these efficiencies in order to get the convenience that we have with classes. And that's where the primitive wrapper classes come in. The primitive wrapper classes give us the capability of classes, but they do also incur that overhead, but they allow us to have those capabilities when interacting with primitive values. Now, the primitive classes are indeed classes. As with all classes, they inherit from the Object class, and each of the primitive types has a corresponding wrapper class. So the boolean primitive type has a wrapper class called Boolean. The only difference is capital B for the class, lowercase b for the primitive type. The char primitive type has a class called Character. And when it comes to the numeric classes, they all have a common base class called Number. Number is an abstract class that all of the numeric primitive wrapper classes inherit from. So we have four classes, one for each of the integer types, and we have two, one for each of the floating‑point types. Again, these are all real classes. So they can be treated as Object, and they have fields and methods associated with them that are particular to that type. One thing to be aware of, all the primitive wrapper classes are immutable, so a given instance always has the same value inside of it. So if you have a reference to an instance of one of the primitive wrapper classes and you do something that changes the value, you will get a reference to a different instance of that class. Very much like working with strings, so you just want to be aware of that. And as you would expect, you often have to convert between the wrapper classes and the primitives, and Java provides a number of ways to handle that. But the good news is, is that the most common scenarios are handled automatically by Java. If we take a look at some code, so we go out here and we declare Integer a = 100, well, Integer a means that a is a reference to an instance of the integer wrapper class, but 100 is the primitive value 100. Java will take care of getting a reference to an instance of the Integer class that has the value 100 inside of it. Now if we say int b = a, well, b is a primitive type, a is a reference to a wrapper class. Java will take care of getting the value out of a. And just to note that the idea of conversions happens with both variables and literals. So just like we had an Integer a = 100, we can have Integer c = b. Well, b is a primitive variable. C is a reference to the Integer class. Java will take care of getting a reference to the Integer class that has the same value that b has inside of it. When it comes to making these conversions, Java also provides methods for doing explicit conversions. If you want to convert from a primitive type to a wrapper class, the wrapper classes all have a valueOf method on them. That process is known as boxing. The idea of boxing is that you take a primitive value, and you wrap it up in a box, which is now the class. If you want to convert from a wrapper class to the primitive type, each of the wrapper classes has a, what I call xxxValue method. And basically the xxx is the name of the primitive type. So integer has integer.intValue, double has double.doubleValue. As you might expect, this is what's called unboxing. To see this in practice, a little more code here. We'll say Integer d = Integer.valueOf(100). It takes that primitive 100 and gives us back a reference to the integer class with that same value. Int e = d.intValue. D is a reference to one of wrapper classes. That int value methods gives us the value out of it. And again, Integer f = Integer.valueOf(e). Again, it gives us a wrapper class reference that corresponds to the value of e. If you take a look at the code at the top there where we say Integer a = 100 and then we look at Integer d = Integer.valueOf 100, you notice that we're doing very much the same thing there. And it turns out we're actually doing exactly the same thing. In a situation like that, the compiler actually injects that Integer.valueOf call for us. And in fact, we don't really have to use these valueOfs and int values that often anymore. Prior to Java 5, you always had to use them. Starting at Java 5, the compiler started inferring their usage, so a good deal of the time you can rely on the compiler to do the conversion for you, but know that those methods are there if you need them. And just to be clear, they're not limited to integers, right? These are there for all of the wrapper classes. So if I look here, like Float g = Float.valueOf, that returns back a reference to the Float class with a value 18.125 inside of it. If I say float h = g.floatValue, that gives me the primitive value back out of that instance referenced by g. Now there's one other type conversion we need to think about, and that's strings. And Java provides mechanisms for that as well. If we want to convert a string to a primitive value, each of the wrapper classes has a parse method on it, so like integer has parseInt. That will parse a string value and give you back the primitive value corresponding to it. We also have an overloaded valueOf that accepts a string, and this gives you back a reference to a wrapper class. So we'll just look at that in code. If I say I have a String here, s, with a value of 87.44, if I say double s1 = Double.parseDouble(s), notice that even though I'm calling parseDouble on the wrapper class Double, it returns back a primitive type. It actually returns back the primitive 87.44. Whereas if I say Double s2 = Double.valueOf(s), valueOf returns back a reference to a wrapper class that has that value 87.44 inside of it.

Using Primitive Wrapper Classes
Now that we have the primitive wrapper classes, we can take advantage of the capabilities that all classes have when working with our primitive types. For example, we can now treat the primitive types as object. So if we have a situation where we have maybe an object array or any other type that expects object references, in addition to putting in things like a reference to a Flight class or a Passenger class, we could even drop in a value like 100. And what happens in this case is that Java will go ahead and get a reference to an instance of the integer wrapper class with a value of 100 and assign that reference into stuff [2]. We also have the benefit of null references. So we have a distinct idea of a value not being set. Let's take a look at our Flight class here. Our Flight class, as you recall, has an int for flightNumber and a char for flightClass. So inside of our toString method, we said, well, if flightNumber's greater than 0, we go ahead and return back a string containing the flightNumber. Of course, the idea there is that we're saying that, well, if the flightNumber's greater than 0, we know it's been set. But we make the assumption that if it's not greater than 0, it must not have been set, even though it's potentially possible to have a flight with a flight number of 0. And then we also make the assumption that, well, if flightNumber's not greater than 0, well, you must have set flightClass because we don't really have a distinct way of knowing that the values haven't been set. But if we now convert our int and our char to the wrapper class equivalent, so we take flightNumber, and we make that an integer instead, and we take our flightClass and make that a character instead, now we go inside of our toString method; we want to check and see if flightNumber has been set. Rather than checking to see if it's greater than 0, we can check to see if it's not equal to null. If it's not equal to null, we know it's been set, no matter what value's inside of there. When it comes to checking the flightClass, rather just assuming that, well, if flightNumber wasn't set, they might have set flightClass, we can actually check and see if flightClass is not equal to null. So that now gives us instead of just two states, you've set one or the other, we have three states. You could have set one, you could have set the other, or maybe you didn't set anything at all. So we're getting that benefit that we've had with our classes all along now with our primitive values. Now, as we mentioned, the wrapper classes provide members as well. Let's take a look at just a few of those. So I have here on screen a list of just a few of the members in each of the classes. If you look at the integer classes, byte, short, integer, and long, you see that we have things like MIN_VALUE and MAX_VALUE, which are fields that tell us the bottom range and the top range of each type, a method like bitCount that lets us see the individual bit values in an instance, or things like toBinaryString that let's us get a string back with the binary representation of an instance. On our floating points, we have MIN_VALUE and MAX_VALUE, again, for the bottom end range and top end range. But those introduce concepts like infinite or Not a number (NaN). On character, once again, we have a minimum value in a maximum value. But then we also have things like isDigit and isLetter to see what kind of character is inside of a given instance. And then on Boolean, we even have fields for representing a reference to a true instance or a false instance. Now these members I have on screen here are just a tiny, tiny sampling. To see the complete list of members, over there on the right‑hand column, I have a shortcut link to the documentation on each individual class. Check this out when you have a chance, and you'll see there's actually a lot going on with each of these individual wrapper classes.

Wrapper Class Equality
Let's take a look at how the wrapper classes affect the idea of comparing for equality. So we have some code here. We have a variable i1000A whose type is Integer, and we assign it 10 * 10 * 10. So we have the value 1000 stored into the Integer wrapper class. And I say Integer i1000b = 100 * 10. So that also has the value 1000 stored into an instance of the Integer wrapper class. Now I compare them using the == operator. Now if these were two primitive variables, == would compare just fine. But because these are references to classes, this will actually test for false because, remember, == only returns true if both references point to the same exact object. So when we're working with these wrapper classes, we generally want to use the equals method to check for equality. So if we say i1000A.equals(i1000B), we get back the value true because it actually checks the value stored inside each one. But let's look at another example. I have a variable i8A, which, again, is a reference of type Integer, = 4 * 2, so it has the value of 8 in that Integer wrapper class, then I have Integer i8B = 2 * 2 * 2. So, again, it has a value 8 stored inside of an Integer wrapper class. But now when I do i8A == i8B, I get back true. Now remember that that can only return true if both those references point to the same exact object. And that turns out to be true because in Java certain boxing conversions are defined to always return back a reference to the exact same instance, and there are five types when that happens. You have an int, a short, or a byte in the range of ‑128 to 127. When that is converted into the corresponding wrapper class, you will always get a reference to the same exact object for the same exact value. So an int of value 5, when it's converted to an integer, it will always be a reference to the same exact integer instance. On the char type, it's any character value from the range of the character 0 all the way up to the character 00ff. And for boolean, it's all of its values because, remember, boolean only has two, true or false. So any time you convert the boolean value true to the class capital B Boolean, all the trues will point to the same object instance, and all the falses will point to the same object instance.

Final Fields and Enumeration Types
Oftentimes in our programs, we'll have fields that we don't allow to be set once they've been initialized. That's where final fields come in. Now there are two kinds of final fields. A simple final field must be set during the creation of an object instance. That means it must be set using either a field initializer, an initialization block, or a constructor. Let's look at some code that uses that. Remember, we have our Passenger class. Remember, in our Passenger class, we had this idea that a passenger could be created with a number of freeBags that they received. We set that, of course, inside of our constructor. Now we may define in our business model the fact that the number of freeBags is considered an aspect of the passenger, so it can only be set during the creation of that passenger. So we can do that by taking our freeBags declaration and simply including the word final there. By including that word final, any attempt to set freeBags after it's been set in the constructor will actually result in a compile error. So a compile error forces that rule that it can't be assigned once it's been set. Now there's also what's known as a static final field. Static final fields create basically named constants, and a static final field cannot be changed in any object instance. It's value is actually tied to the class itself. So if we look at that in code, look at our Flight class, remember that our Flight class has this concept of the number of seats on a flight. So an instance of our Flight class can set the number of seats. So we simply have a setter to do that. But let's say that the Federal Aviation Administration, that's the organization in the United States that sets the rules for planes. Let's say that they set a rule that there is a maximum number of seats that a flight is allowed to have, and we'll say that that's 550. So we can declare a static final field called MAX_FAA_SEATS has a value of 550. Now the convention is that whenever you have a static final, you use all caps for the name of the field, and what we can do here is down inside of our set seats, we can actually use that MAX_FAA_SEATS just like it's a value. So inside of here, let's make some room, and we can actually put a check in to say, well, if(seats <= MAX_FAA_SEATS), we set it. Otherwise, we handle the error. The key here is that no object instance can create this. MAX_FAA_SEATS will have a value of 550 in all flight instances. We use this most commonly when we're trying to avoid what we often call magic numbers, where we don't like to put literal numbers inside of our code because when we look at this code, we know that the reason we're checking the value of seats is that the FAA has a rule on the max. If we just dropped a 550 in there, that wouldn't necessarily make sense. Now we often have times where we want to limit a type to a finite number of values, and that's where the enumeration types come in. Enumeration types allow us to define a type that has a list of valid values. We declare those using the enum keyword. So let's go ahead and declare an enum for the jobs that the flight crew is allowed to have. So you'll notice we use the word enum there instead of the word class, and then inside there, we can simply provide a comma‑separated list of the valid values. Let's say the flight crew jobs could be a Pilot, a CoPilot, a FlightAttendant or an AirMarshal. So now we can use FlightCrewJob as a type. So let's say we introduce a new class here called CrewMember. CrewMembers have a job of type FlightCrewJob. So we can go ahead and set that as part of the constructor of CrewMember, as well as we have a setter to change the job of a crew member. So now, if we go off and create an instance of CrewMember called Judy, one of our new crew members, we can give her a job, so we'll say she's a CoPilot. So notice the way we do this is we use the name of the enumeration, dot, one of the values. So we've created Judy to be a CoPilot. Let's say some time goes by and Judy gets a promotion. We can now make Judy the Pilot. So we can simply say Judy.setJob. Again we use the enumeration name, FlightCrewJob, dot, and the value, Pilot. Enumerations are most commonly used in this way defining this finite list of values. But enumeration types actually have a number of much more advanced capabilities beyond this that we'll talk about later in the course.

CalcEngine with More Data Type Capabilities Part 1
In this demo, we'll enhance our CalcEngine program to take advantage of the data type capabilities we've talked about throughout this module. What we'll do is add in some string processing capability so we can take a string like add (space) 1.0 (space) 2.0. We'll calculate the answer and then write it back out in a more traditional format like 1.0 + 2.0 = 3.0. Here we are in our CalcEngine program, and it's basically just like it was when we left at the end of the last module with just a few small changes. One thing I've done is all the code that was in our Main method, I've moved into other methods so that it's kind of not in our way here as we're writing our new code. I actually have the code in place here to call those methods, and I've just commented them out because we're not going to focus on those right now. The other thing I've done is I've created a String array here that actually has four strings in it, and these strings all have the operations we want to perform in the syntax that we want to use. This first one says divide 100.0 50.0 with each one of those separated by a space. Then what we want the program to do is to be able to print out something like 100.0 / 50.0 = 2.0 and do that for all four math operations. So to get started, the first thing we want to do, let's go ahead and add an enumeration that contains values for each of the four operations we want to perform. I'll go ahead and create our enumeration just like I create a class. Now the way most of the IDEs let you do it is that when you want to create something that is not a class, you can just say what you want to create. So I'm going to go ahead and say Enum. And let's go ahead and call my enum MathCommand. We'll create that. And so we want to put our four operations in here. So our operations are going to be Add, Subtract, Multiply, and Divide. So we have our enumeration with each of the command values separated by a comma. And that's all we need to do with that for right now. Let's go ahead now and let's create a class that we'll use to do the string processing for us. So it will do the work to process a string value and get us those results back as the other string format. So I'll go ahead and create a new class again. And we'll go ahead and call this one our CalculateHelper. So we have that, create it. So inside of here, what we're going to need are four fields. Basically, we'll need one field to hold the command, so we'll declare that as our MathCommand. So our command field's of type MathCommand. Now I'll declare one for the leftValue, and then we'll do the same thing for rightValue and result. So we have all the fields we need now. Let's go down to a method we'll call process that will accept the input string and do the work to process the contents of that string. So we'll make it a public void method, and its only parameter is the string that'll be the statement that we receive. So we have that there. Now remember that what we want to do is receive a string that looks something like this, add (space) 1.0 (space) 2.0. So we have to go ahead and process each of those parts. Remember that when we were looking at the methods that the String class offers, there was one called Split that handles this scenario of breaking a string up into its parts based on some separating character. So let's go ahead and deal with that. So I want to create a string array called parts, and all we have to do here is set it equal to statement.split, and then we specify the separating character, which is just that space. Split will return the values inside of statement based on the space separator. So the first value inside of there is going to be the command, and commandString is going to be set equal to the value of parts[0]. And what we expect to find in there is the value like add. Now the next thing we want to do is get the left value out of there, so let's go ahead and put the left value right into our field called leftValue, and that value is going to be in parts[1]. Now parts[1], though, is a string, so we want to go ahead and convert that string into a double. So we'll use Double.parseDouble to convert that string into the primitive type Double, so that will give us back the 1.0 as a double. We'll then do the same thing for the right value from Parts[2]. So that will have the value on the right‑hand side, something like 2.0. So now we have our command as a String and then the leftValue and the rightValue. Now what we want to do is convert our command from being a string into our MathCommand enumeration. So let's go ahead and create another method here. It will be a private method, and we'll call it setCommandFromString. And it's only parameter will be the commandString. So we have that there. Now remember that what we want this guy to do is take that string value like add and convert that into our MathCommand.Add. So what we'll do now is we'll take our commandString, and we want to do a comparison with that. So we want to say if, let's say commandString, and I'm going to use equalsIgnoreCase. So now the question is, What do we compare that to because all we have is our enumeration? So let's take our enumeration value for add. Remember that I mentioned that if you want to convert a type to a string, you can call this toString method. That's also true for enumerations. So I'm going to say .toString. And what that will do is it will actually take those characters, capital Add, and convert them into the string, add. So we're actually taking our enumeration value and making it a string. So if we get a match on that, what we can do is we can take our command member variable, which is of type MathCommand, and assign it the value of MathCommand.Add. Then we can do that same thing on an else‑if, but we'll do it for subtract this time. And if that matches, we'll set command to be MathCommand.Subtract, and then we'll do the same things for Multiply and Divide. So now we have all four cases handled. I'll just scroll down here so we can see a little better. As we bring in that commandString coming in, we can now translate it into the enumeration MathCommand and store that in the command. If I scroll back up here a little bit, in our process method now, what we'll do is we'll call that setCommandFromString passing in the command string. So when we return back from setCommandFromString, we will now have our command with the appropriate enumeration value inside of it. So what we want to do inside of here is take advantage of those CalculateBase‑derived classes we created in the previous module to do the actual work. So what I'm going to do is create a local variable of type CalculateBase called calculator, and with that variable, I can reference any of the classes that derive from CalculateBase. So what I'll do is put a switch statement in on command, and then based on the value of my field command, I will go and create the appropriate instance. So we'll start by creating our switch statement. It's going to be on command. So we have that in there, and what we'll do is do a case on each of the possible values. So I'm going to say case, and I'm going to say Add. Notice here inside of this switch statement, when we access the value of our enumeration, all we need is the value itself. Normally, when we work with an enumeration, we often have to have to include the enumeration name, but we don't have to do when we're inside of a switch statement. So we're checking our case Add. If our command was an add, what we're going to do is take our calculator and assign it a new instance of Adder because our Adder knows how to do addition. And what we'll do is we'll create it with our leftValue and rightValue. So at this point, calculator references an instance of Adder that has the values that have to be operated on. So let's go ahead and put a break here. We'll then do case Subtract. We'll then set our calculator to a new instance of Subtracter. Again, we need a break, and then we'll do that same thing again, but for Multiply and Divide. So now our switch statement will take care of creating either an Adder, a Subtracter, a Multiplier, or a Divider based on whichever command was typed in. So now we know that we can just use our calculator to do the actual work. So what I'll do is I'll get my calculator and just call our calculate method. So that'll do the actual operation. And then we will get the result from the calculator and store that into our result field. And so with that, our process method is complete. I'll scroll back to the top here. Inside our process method, we receive the complete string. We then break it into its individual parts. We translate the string command into our MathCommand enumeration. And then if I scroll down here a little bit, we then look at that command and create the appropriate CalculateBase‑derived class to do the work and then actually perform the work itself. So this guy's all set here. So let's go back to our Main program now. And so what we can do here is inside of our Main program, we can go ahead and create an instance of our CalculateHelper. Let's just go ahead and call it helper. So we have that. So what we can do is just do a for each for each statement in our statements array. And then inside of there, we'll take our helper, we'll say process, and we'll give it a statement. So that will then go through, do all the work to take apart the string and perform the operation. So the question is, How do we get the output out? Now it'd be really nice if we could just simply write out the helper at this point. In fact, let's go ahead and do that. So we'll use our System.out.println. And let's go ahead and just put our helper inside of there. And so the idea here then is we'll just loop through each of those statements, tell the helper to process them, and just ask the helper to write it out. So let's go ahead and run this, and let's see what we get. And if you take a look at our output, it's not really what we're looking for. But if we notice this, we actually can recognize this from something we talked about earlier in this module. Notice that we're seeing the class name, the @ symbol, and then what looks like a hash code. Well, that tells us that it's actually calling the helper's toString method. Now we haven't overridden the toString method because we're seeing the results of toString as it's implemented in the object class. But that does tell us that if we implement toString appropriately, we should be able to control what gets written out here, and that's what we'll talk about in the next clip.

CalcEngine with More Data Type Capabilities Part 2
So let's look at how we can update our CalculatedHelper to have an appropriate toString method so we can actually see the right results coming out from each helper instance. So let's get this bottom window out of the way. Let's head back to CalculateHelper. I'm going to scroll down here towards the bottom, and what we'll do is we'll go ahead and override the toString method. That's a public string. So we have that there. Let's go ahead and mark it as an override. Let's scroll down here so we can see a little better. So now what we want to do in here, remember, is we want to write out something like this. So that's the output that we want to produce. So now one of things we'll need to do is identify the appropriate symbol. Is it a plus sign or a slash for dividing or a minus sign? So what we want to do here is go ahead and declare a local variable. We'll call it symbol and make it of type char, and I've just initialized it to a space because variables have to be initialized. And what we'll do here is we'll, again, use our switch statement to test the values of our command field. So we'll first do a case for Add. And, of course, what we want to do here is set our symbol to the plus sign, so we'll do that. Now one thing to note here is that we're putting this literal right in the middle of our code, and this would actually be a pretty cool place to use a named constant. So we could actually say something like Add symbol, as opposed to just a character, the +. So why don't we go ahead and declare named constants for each of the four operation symbols. So let's scroll up to the top of the class. What we'll do up here is we'll make them private. Remember that we can use final because once a field's assigned, it can't be changed. But for named constants, we like to go ahead and make them static. That way no class instance can be set then at null. The values are the same for every instance of the class. So we'll make this guy a char, and we'll call it ADD_SYMBOL. Remember that name constants are all capitalized. And we'll simply set it to the character +, So that's our ADD_SYMBOL. Let's go and do the same thing for Subtract, Multiply, and Divide. So we now have the symbols for all four operations. So let's scroll back down here to our toString method. And we'll change this from that literal + character to ADD_SYMBOL. So that's much more readable, just kind of really showing what we're trying to do here. Let's go ahead and put a break in there. And then what we'll do is do that same thing for the other three operations. And so now we can set the symbol for all four operations, Add, Subtract, Multiply, and Divide. Let's get these extra spaces out of here, clean that up a little bit. And so now we have everything we need to build the output string. We know the two values, the result, and what symbol to use. Let's add a little space down here at the bottom so we can work. So the most efficient way to build that output string is use the StringBuilder class. So let's declare a local variable of type StringBuilder. We'll call it sb. And we'll new up an instance of StringBuilder. And, remember, we talked about things perform best if we pre‑allocate the size, so let's make room for, say, 20 characters inside of there. So we've got that guy in place. And now we can just start adding the values into the StringBuilder. So we want to go ahead and add the leftValue in, so we'll say sb.append, put leftValue in there. So that puts that value in. Let's put a space after that. Next, we want to get the symbol, so we'll use our symbol variable. So we've got that there. Let me just scroll down a little bit so we can see better. We'll put another space after the symbol. Then we need our rightValue. And then we can append a (space) = (space) followed by the result. And with that, now we have our complete string built, but it's inside of the StringBuilder. Remember, the way we get the string back is by simply calling toString on the StringBuilder instance. So that's what we'll return back, sp.toString, and that gives us a complete implementation of our toString method. Now one thing to note, we're using the StringBuilder here, which is a really efficient way to build this string up. There's another mechanism you can use that I mentioned briefly inside the module, which is the string class has a method called Format. I've got the URL onscreen for where you can find the documentation on the Format method. When you have a chance, you might want to check that out as just an alternate way you could have actually built this output string. But we've got our implementation here complete. So let's head back to our Main now. Now we haven't changed anything in Main. And, remember, what we're doing is that after we process each instance of of helper, we're just writing out helper. And we know that that'll actually call our toString method. So let's just go ahead and run this now. And there you see in our output window, we've now got the appropriate output. So our input string like divide (space) 100.0 (space) 50.0 now writes out 100.0 (space) / (space) 50.0 (space) = (space) 2.0. And the same thing for each of the four operations. So by using these things we've talked about throughout this module, we've been able to add some really nice functionality to our program.

Summary
To wrap up, remember, the key things you want to remember from this module are, first, we have the String class, which allows us to store a sequence of Unicode characters, and any class that you create, you can override the toString method to define how your class behaves when converted to a string. Remember that because strings are immutable, meaning that they can't be changed directly, we don't want to manipulate strings themselves directly. Instead, we use the StringBuilder class, which provides an efficient way for us to manipulate strings. Primitive types provide a very efficient way to manage primitive values, but they lack the capability of classes. So the primitive wrapper classes give us the ability to get the class features when working with primitive values. Remember, though, that the primitive wrapper classes are much less efficient than the primitive types themselves, so only use the primitive wrapper classes when you need the capabilities they provide. Final fields allow us to define a field that cannot be changed once set. Remember that there are two kinds of final fields. A simple final field is set during the creation of an object instance, whereas a static final field serves more as a named constant. It can't be changed by any object instance. Its value is associated instead with the class itself. And, finally, we have enumeration types, which allow us to define a type that can only hold a finite list of values.

Exceptions and Error Handling
Introduction
Welcome to the next module, the Pluralsight Java Fundamentals course on the Java language. In this module, we cover exceptions and error handling. My name is Jim Wilson, and this module will cover a number of things related to exceptions. We'll first take a look at the role of exceptions. Then we'll talk about the try/catch/finally statement that allows us to handle exceptions. We'll talk about our responsibilities when we have exceptions that cross method boundaries, we'll look at how to throw exceptions, and finally, how to create our own and custom exception types.

Error Handling with Exceptions
A critical aspect of building a successful application is good error handling. If you build a program that doesn't have good error handling, it doesn't matter how cool it is. If it crashes all the time, no one's going to want to use it. So we need to make sure that handling errors appropriately is really kind of implicit in our application development. Now traditional mechanisms would use things like error codes that had to be checked or flags that had to be checked. And that's really intrusive, right? Having to put if statements all over the place to deal with potential errors really kind of clutters up your code. It's really kind of awkward. And very often, as developers, we just kind of never get around to doing it. So we need a way that makes it really easy to manage errors. And that's where exceptions come in. Exceptions provide a non‑intrusive way to signal errors. So with exceptions, rather than actually have to check for errors all the time, we can write our code so that we expect things to go well. But if an error occurs, an exception is what we call thrown. So when an exception is thrown, we can handle it. And that's where try/catch/finally statements come. Try/catch/finally provides a structured way for us to handle exceptions. The try portion of the statement contains all of the normal code. It's the thing we expect to go well. And if all goes well, the try block will simply run to completion, and nothing special will happen. But if there is an exception, control is then handed off from the try block into a catch block. So our error code is all inside of a catch block, and the catch block is only called in the event of an exception being thrown. And then we have what's called a finally block. And a finally block is for those scenarios where you need clean up. The finally block runs after your try block finishes or after a catch block finishes. So if there's anything you want to have done after the process is over, you put that in the finally block because it's assured to run whether the try block finishes completely or the catch block had to step in and deal with an error. So let's see what this looks like. Let's look at a really simple case here. So we'll have a couple of integers declared here, i has a value of 12 and j has a value of 5. And all we want to do is we're going to take the value of j, subtract 2 from it, then divide that into i. We'll store that int result and simply print it out. Alright, so in a real simple case like we have here, if j has a value of 5, and I subtract 2 from it, of course I have 3. So if I divide 12 by 3, I'll print out the value 4. Very simple. But let's make a really small change here. Let's change j from value of 5 to a value of 2. Well now if I subtract 2 from 2, I end up with a value 0. It's not legal to divide by 0. So what would happen in this code is that as soon as I try to divide by 0, my program would just crash. What we want to do is code our programs up so that we can recover from scenarios like this, and that's where exceptions come in. We can wrap this code up so that we can handle the exception that occurs when we try to divide by 0. So we take our core code here, which is where we do the math and print it out. We wrap that in our try block, and then we add a catch block to it. And notice that the catch block receives an exception. In the case of an error, that variable e will receive a reference to the exception that describes the error that occurred. We can do a number of different things with the exception. The simplest thing we can do is simply print out a message that goes with it. The getMessage method gives us back the appropriate message for that exception. And if we wanted to, we can even print out a stack trace showing exactly what went wrong. Now our program will continue running just fine from here. But if we didn't handle this exception when that divide by 0 happened, again, we would have crashed, and the user would've just been left kind of wondering what happened. But in this case, because we have proper error handling in place, when we try to take that 0 and divide it into i, that raises an exception. So control was immediately passed from where we try to do the arithmetic that failed to our exception block. And then we can simply print out the value of that exception, the message for it, which says Error: / by zero And then we would see the stack trace underneath of it. So that's really kind of our simplest kind of try/catch scenario. Let's look at a little bit more involved one. Let's say we have a text file, it has a series of numbers inside of it, and we want to go through and just total them up. So this text file, Numbers.txt has the set of numbers we want to go ahead and add up. So let's write some code to do that. So we're going to take advantage of one of the built‑in Java classes called BufferedReader. And BufferedReader provides an efficient way to read content. We'll also have a variable called total that'll hold the total of the numbers that we add up. So we'll go ahead and create an instance of our BufferedReader. And notice our BufferedReader uses a FileReader. Now FileReader is a built‑in class that takes care of the details of reading content from a file. BufferedReader is something that adds some buffering on top of that to make reading the file more efficient. It also provides some helper methods. Another thing to notice here is that when we identify the name of the file, notice we're putting slash slash in there. In Java, backslash is used to identify special characters. So slash slash says no, I really want a slash. Now when this is done, we have an instance of our BufferedReader with a reference to it assigned into variable reader. And then from there, we're going to declare a local variable called line. It will hold a string. And then we'll put a while statement in place here that actually reads from the BufferedReader. So a couple interesting things are going on here. Notice that we're actually assigning to line directly inside the while statement. Alright, so reader.readLine is defined to say that it will return back a null when you hit the end of file. So we take whatever we get back from readLine, assign that into line, and then we check line against null. So as long as line does not contain the value null, we know we still have content. So here we'll just go ahead and say total +=, and then we'll use one of the primitive‑type wrapper classes, Integer, and call its valueOf method to convert the string contained in line into a number. So for the first line in our file, we would then be adding in the number 5 into our total. When the while loop completes, we'll go ahead and print out our content. And so that's our core effort. That's what we're doing now. We're reading from a file, getting each line from it, converting it into its integer value, adding it to a total, and printing it out. Now there's a lot of things that could go wrong here. Maybe the file doesn't exist. Maybe just some kind of system error occurs when we try to read from the file. Maybe there's bad data in the file. Somebody put the letters X, Y, Z in there instead of numbers. So that could go wrong. So there's a lot of things could happen here. So we certainly want to wrap this into a try block. We'll go ahead and put our catch block in here as well, handle the exception, and we'll print out the error message. But now something to note here, we've explicitly opened our file. When you open up a file, you need to make sure you close it when you're done. And we want to close the file whether the try block completes without any problems or if an error occurs and we have to go to the catch block. So that's where it finally comes in. So we put a finally here at the end, and what we're going to put inside of there is reader.close. So we'll be sure to close the file whether we have a problem or if everything completes fine. Now something to note here, notice that when we declare BufferedReader, we declared that before the try block rather than declaring it inside the try block. The reason we did that is because we need to have access to the variable reader down in our finally block. Had we declared reader inside of the try block, we wouldn't be able to see in the finally block. Remember, we talked about earlier in the course, that when a variable is declared inside of a block, it's not visible outside of that block. So that's why we declared that before the try block. Now another thing to note. As we mentioned, there can be different kinds of errors here. So if we run into a problem reading the file, if there's bad data there or some error occurs in the process of reading the file, our reader would still have a valid reference to the BufferedReader. But what if the file we identify there, Numbers.txt, if it didn't exist? Well, the instance of BufferedReader would've never been created. Therefore, reader would still be null. So one of things we generally want to do inside of a finally block is anytime we're going to clean up a resource, make sure it actually has a valid reference. So we check reader and make sure it's not equal to null before we close it. Now another thing we have to think about, the method reader.close is defined that it itself can throw an exception. Something could go wrong in the process of trying to close that file. So we actually need to protect the close with a try catch. So we can go ahead and wrap that up with a try block and then have a catch, which will print out that error message. Now chances are you're probably not going to run into a problem closing the file, but it could've happened. So you see here that this idea of try, catch, and finally can actually become pretty sophisticated, taking care of a lot of different scenarios for us, but still allowing us to keep our code very structured in how we deal with each aspect of it.

Handling Exceptions by Type
As we introduced in the last clip, errors are represented by exceptions. Well, each exception is actually an object, so each exception type is described with a class. Now, as with all classes, the root of the class hierarchy for exceptions is the Object class. When an exception occurs, it is thrown and, of course, we use catch to handle it. Well, in order for a class to be able to be thrown, it has to inherit from the base class Throwable. Now one of the classes that inherits from Throwable is the class Error, and there are a number of classes that in turn inherit from Error. But any error that occurs that inherits from this class Error is generally one we don't have to think about too much in our code because it generally represents some kind of problem directly inside the Java virtual machine. So because of that, we don't really handle those very often. An example of one of these might be like a linkage error. A linkage error occurs when you try to load a class, and it's not able to load that class up for some reason. Now the errors that we tend to interact with much more inherit from a class Exception. Now one key class that inherits from Exception is the class RuntimeException. And there are many other classes that in turn inherit from RuntimeException. Generally speaking, those classes that inherent from RuntimeException represent errors in your program, not always, but very commonly. An example of one of those might be a NullPointerException. So you're actually trying to use a reference variable that you've never assigned to. So that's kind of a programming error. We'll see, though, that there are times that you do want to handle certain RuntimeExceptions. Now the area where we work most commonly are the classes that inherit more directly from the Exception class. And these are the things we want to actually watch out for in our programs. An example here might be something like an IOException where you're trying to interact with a file, and you're not able to, something like that. Now these exceptions on this side here are so important that we actually handle them correctly, they're considered checked exceptions. Now a checked exception means that the compiler actually looks, and any time one of these exceptions is thrown, the compiler looks to see if you actually handle it. If you do not handle a checked exception, the compiler will raise an error. In other words, it won't let you build your program. So you have to handle all checked exceptions. Now the exceptions here under a RuntimeException are considered unchecked exceptions, meaning that you can handle them, but the compiler doesn't require that you do. So even if the compiler knows that it's possible for that exception to be thrown, if you don't handle it, it's not going to raise an error. The way you can tell an unchecked exception from a checked exception, any Exception class that inherits from RuntimeException is considered an unchecked exception. Any class that inherits from Exception but not RuntimeException is considered a checked exception. Now the virtual machine‑related errors, those are treated as unchecked exceptions. In other words, the compiler does not require that you handle those. Now with exceptions being typed, what that means is that in our code we can actually handle exceptions by type. So when we have our try statement, we can have multiple catch blocks with each catch block handling a different type of exception. When an exception occurs, the Java environment will start testing your catch block starting at the top and walking down each one. The first catch block that it encounters that is assignable for this exception is used. And what we mean by assignable is that the catch block handles an exception that is either the type of the exception thrown or the base class of the type of exception thrown. Now because a base class can satisfy the catch statement, we want to make sure our catch blocks start with the most specific exception types first and get more general as we go down. Now to see this in action, let's take a look at the code we wrote in the last clip. Now remember that what we do here is that we're reading data from a file, and then we're simply totaling it up. But in order to do that, we have to open the file. We have to read each line in the file. We have to convert each line from a string into a numeric value. So there're a number of things that can go on there. Let's focus in on the catch statement itself here. So let's go ahead and just kind of move the constants to the try and the finally out of our way so we can see the catch statement. Now right here, we catch Exception, but that's a very general handling. Remember, we said that one of things that might happen is that if there's bad data in the file, and we try to convert it to a number, that could throw an exception. It actually throws a NumberFormatException. So say we want to handle that guy. So I'll go ahead and add a catch in for NumberFormatException. Now, of course, the problem here is that because NumberFormatException inherits from Exception, we'll never reach the catch block for NumberFormatException. Now there are times in my code where I handled Exception directly, but that's not very common. So let's go ahead and just get that guy out of the way there. So now we have our NumberFormatException, so if that happens, we will catch it. But, of course, we won't catch any other exceptions. So let's go ahead and just move that up a little bit. We've got some room here now to handle some other exceptions, but let's look at the tree hierarchy of the exceptions that might happen here. Now we're looking now at the NumberFormatException. Now that's going to inherit up through some other classes up to RuntimeException, which, of course, inherits from Exception. Now notice that NumberFormatException inherits from RuntimeException, meaning that it is an unchecked exception. So the compiler doesn't require that I handle this one. But even though the compiler doesn't require it, I know it might actually happen in my code. So I'm going to go ahead and catch it anyway. Now other exceptions that might happen are things like IOException, a problem interacting with a file. And there might even be a FileNotFoundException if I try to open a file that doesn't exist. So the deal with these exceptions, I can add in a catch block for the IOException, I'll just write out the error message there, and that would satisfy any problems interacting with the file, as well as the inability to open the file. But you know, not finding a file is a pretty specific issue, much more so than just some kind of general error interacting with the file. So in this case, I want to go ahead and handle FileNotFoundException in addition to IOException. Now the important thing is that I put that before the IOException. So in that case, when I encounter a FileNotFound, I can just write out the fact that, hey, that file wasn't there, as opposed to a general file issue message. And so as we set up our exception handling, again, the key thing is to understand that we use a type hierarchy as we do this, and you want to handle your most specific exceptions first, getting more general from there.

Exceptions and Methods
So far we've been looking at how exceptions work within a specific block of code. Let's look now at how they work when we call down through multiple methods. Let's say we have a method here, we'll call it methodA, and methodA does some work. And as we know, whenever we use methods in a computer program, it works with a stack. So methodA gets a spot on the stack. It takes up some space in that stack. Let's say methodA calls methodB. So let's go ahead and wrap up that call to methodB in a try‑catch block. So now, of course, we're going to have methodB's implementation, which does some work. So, again. it's going to get a spot on the stack and take up some space there. So then methodB calls methodC. MethodC, again, does some work, gets a spot on the stack, takes up some space. Again D does the same thing, So let's say now we're down here inside of D, and D does something that throws an exception. So now that exception occurs, and now something has to try to handle that exception. So what happens is the system starts trying to see if it could be handled. Since Method D doesn't handle it, it will start looking up the call stack to find some code that can actually handle this exception. Well, remember, here in methodA, we put that try‑catch in place. Well, that catch puts a marker on the stack. So what happens now is that Java looks up the call stack, and when it finds that marker, it says, Oh, you you can handle this exception? The call stack is cleaned up, and then control is passed to that catch block. So that means then, of course, that exceptions propagate up the call stack, meaning that they can actually cross method boundaries. So the question is that how could methodA know it had to be responsible to catch an exception that occurred all the way down in methodD? Well, in Java, the exceptions that a method throws are actually part of that method's contract, just like its return type would be or the list of parameters that it accepts. So in Java, a method is responsible for any checked exceptions that might occur, and it basically has two choices for dealing with them. One is it can catch the exception, but it doesn't have to catch the exception. But if it doesn't catch the exception, then it must document that that exception might occur. The way that's documented is that a method can have a throws clause on it, and that throws clause needs to list any checked exceptions that might occur within that method that it doesn't handle. Let's look at some code and get a sense of how that works. So let's think about our Flight class. Let's say we want to add some functionality to our Flight class that allows passengers to be added from a text file. So the format of our text file will be that the first thing on each line is the number of people in a given party, a space, and then the name associated with that party. So we'll have our Flight class here. And, remember, we have our Passengers field. I'm going to add a method on here called addPassengers. This implementation of addPassengers accepts a string parameter, which is the file name to read the passenger information from. So whoever calls this method is going to pass in the name of the file they want us to read the passenger information from. The code we use to deal with this passenger information is going to be very similar to the code we used earlier to total up the numbers from inside of a file. So we're going to need a buffered reader. So we'll go ahead and create an instance of that buffered reader that wraps a file reader that uses the file name that was passed in. We'll need a variable to hold each line that's read in. Then all we have to do is read in each line. Now since there're two values on each line, and we want the number of people in the party, we're going to use the split method on the string to go ahead and get that first field. And then we use our Integer.valueOf to convert that initial value from a string into an integer, and simply add it to our number of passengers. Now we know from the work we did earlier totaling up values inside of a file that exceptions can be thrown in this code. Now, in this case, we don't want to catch them. We certainly could catch them here, but it probably makes sense that those exceptions propagate up to the caller because that file name came from the caller. So if there's anything wrong with it, they might know what to do with it based on the exception. So rather than catch the exception here, we're going to document that it gets thrown. So on our method declaration here, we're going to add a throws clause, and we're going to say throws IOException. Now the reason we know that we throw an IOException is because if we were to look, the file reader constructor is documented to throw a FileNotFoundException, and the buffered reader readLine method has a throws that says it throws an IOException. And since a FileNotFoundException is also an IOException, we can simply say, throws IOException. Again, the key thing here is that if we didn't catch it and we didn't put the throws on, the compiler would actually complain that we weren't dealing with the exception. So by saying that we throw it, that's our responsibility in dealing with it. Now we have another thing we have to think about. We processed this file, but we've opened it up. There's nothing to close it. Now we want to make sure that file gets closed whether we succeed or not, but we don't want to actually handle any errors, but we can still use try to make sure the file gets closed. We can wrap this code up in a try and then put the finally afterwards, which closes the file now. Now this way, if we go through and process everything and we succeed, then the finally will run and it'll close. Also, if we go through and we process things and an exception occurs, the finally will still run, close the file, and then let the exception call up the call stack. Now, since exceptions are part of a method's contract, how does that work when one class overrides a method from another class? Well, when you override a method, the throws clause of the overriding method must be compatible with the throws clause of the method being overwritten. So say, for example, we have our CargoFlight class that extends Flight, and it wants to override that new addPassengers method we just put in there. Well, it needs to be compatible with the throws clause of voice implementation of addPassengers. Now there are three ways to be compatible. One is to simply not throw the exceptions. And so our method as it's written right now with addPassengers is considered compatible because we're not generating any exception that wasn't already defined in the base class. And we can also have a throws clause that throws the same exception. So if we say on the end here throws IOException, that's compatible as well because it's the same thing that the base class had. But we can also indicate that we throw a derived exception. So, for example, FileNotFoundException derives from IOException. Therefore, it's okay for us to say throws FileNotFoundException. And the reason this makes sense is because we have to be compatible with our base class because remember that somewhere there might be code that has a reference to an instance of our CargoFlight class, but might be using a variable declared as Flight. So that code would only know about the capabilities of addPassengers as implemented in Flight. So any try‑catch they put in place there, they're going to catch the exceptions that are defined on Flight's implementation of addPassengers. We want to make sure that our derived class doesn't start throwing exceptions that the user of our class didn't know they were responsible to handle.

Throwing Exceptions and Custom Exceptions
In addition to being able to handle exceptions, as we've done up until now, our code can actually throw exceptions as well, and that would just mean in any case where we want a signal that an error has occurred. So we may throw an exception because our code has identified something wrong with the data we're working on. Or it might even be that our code has caught an exception and wants to throw a different exception to provide more information. Now the way we throw one exception is quite easy. We simply use the throw keyword and then provide an instance of the exception we want to throw. Now remember that exceptions are objects, so they have to be created before they can be thrown. So we just create them with the new keyword. And one of the most important things to remember when throwing an exception is that you want to be sure that you provide meaningful detail. We want to make it easy for whoever has to handle this exception to be able to figure out what was wrong. Now most exception classes provide a constructor that accepts a string message or some other detail. So you want to make sure you put as much meaningful information into that as you can. Now as we said, sometimes we'll throw an exception because our code caught an exception, and we want to add some more information to it. Well, in that situation, you want to always make sure that your new exception that you throw includes the original exception. You don't want to lose that detail. And this idea of tying one exception to another is very fundamental to the exception classes. All the exception classes have a method called initCause that will allow you to associate an exception with an instance of another exception. But this idea of associating exceptions together is so fundamental that many exception classes actually provide a constructor that will accept the other exception. So you can actually create the new exception and associate the original all in one step. Now, in most cases, when you're throwing an exception, you're going to want to throw one of the existing exception types. But it is possible to create your own custom exception types and throw those as well. Now to really reinforce this, in most cases, you're going to want to use one of the existing exception types. But if you really have a situation where you've got something you need to provide information on that doesn't really fit one of the existing exceptions, you can define your own. But, again, that's going to be one of those situations where you've got some real information, some real value to provide that you can't with the existing exception types. Now if you do define your own custom exception type, you're generally going to inherit from the Exception class, but that has an interesting implication. Remember that any exception that inherits from the Exception class but not the RuntimeException class is a checked exception. So the exceptions you define will become checked exceptions. The process of implementing a custom exception type is generally pretty easy. In fact, very often the only members that your exception type will have will be constructors. The reason for that is that most of the required functionality is inherited. The base classes have the ability for you to associate a string message and have the receiver of the exception access that message. The base class can provide things like stack traces. So you generally don't need to provide a lot more than that. I mean, there may be some situations where there's some extended error detail you might want to add. In those cases, you might have some additional getter methods to access those, but there's not going to be a lot of that. Now when you define your custom exception type, you'll generally want to have at least two constructors. You'll have one constructor that accepts whatever the required detail is. That may be a simple string message. It may be some meaningful fields. You'll generally also want to have another constructor that accepts that same detail, along with an originating exception, again, so that if this exception is thrown in response to a different exception, they can be tied together. And you could, of course, have more constructors than that if you want to. You can have a no argument constructor. You can have whatever you need, but you'll generally have at least these two. Now in the next clip, we'll take a look at how we can actually define a custom exception in code and how we actually throw it.

CalcEngine with Exceptions
In this demo, we'll add exceptions to our CalcEngine app. We'll create a custom exception class, which we'll then throw in cases where we find we have invalid data. And then, of course, we'll add a try/catch block to our app to handle those exceptions. Here we are in the source code for our CalcEngine app. And the app's exactly as we left it at the end of the last module, except I've added three more statements for us to process. Remember that each statement that we process is supposed to have three parts, a command and then the two numbers we want to operate on. Well each of these three statements I've added have a different problem. The first statement contains only two parts, the command and a single numeric value instead of having two values. The second statement has non‑numeric data, the xx. And then the third statement I added has an invalid command, addX. So what we want to do is update the app so that we can properly handle this invalid data. So the first thing we'll do is add our own custom exception class. So I'm going to create a class just like I always do because remember exception classes are just classes. And let's call this the InvalidStatementException. We'll say OK. Now remember that all of our exception classes will generally extend the class exceptions. So let's go and do that. And as I mentioned in the previous clip, in most cases, any custom exceptions really only have constructors inside them. So let's go ahead and add a public constructor for this. And this constructor will take two arguments, the reason that a statement is invalid and the statement itself. So they'll both be string parameters. And then all we need to do here is go ahead and call our super class constructor. So I'll say super. And one of the super class constructors accepts a string, which is a message. So what we'll do is we'll take these two parts, the reason and the statement, and combine them into a single message. So that's our first constructor. Now remember we said that normally there are two constructors, one that accepts the information that we need, which we have here, and also one that lets us associate another exception with it. So what I'm going to do here is I'm going to grab this first constructor. I'll just copy that, and I'll paste it in. And what I'm going to do on this second constructor here is add in a Throwable cause. So we've got the cause there, and all we're going to do is pass that to our base class constructor. And we now have a custom exception because remember that all the real work of being an exception we're inheriting from the base class. So we're really ready now have our own custom exception. So now what we need to do is add in the appropriate error checks into our code. So let's go to our CalculateHelper class here. And here we are inside the process method. Remember the job of the process method is to take that string statement, break it into its parts, and then do the right work under the covers. So remember that we said there are three things we're going to start checking for. The first one was to make sure that we have enough parts to the incoming statement. So the right place to check for that is right here after we call split because when we call split, we get back an array with all the parts. So what we want to do is make sure that array has exactly three members in it. So let's put an if statement in place. We'll just check to see if the parts length is equal to 3, or I should say if the parts length is not equal to 3. And then if it's not equal to 3, what we're going to do is throw an instance of our exceptions. We're going to say throw. We're going to new up an instance of our exception. Remember, our exception is the InvalidStatementException. Remember that we want to pass this one two parameters, the reason that something is wrong and then the statement itself. So the reason we'll say is incorrect number of fields, and then we'll pass our statement in. And so now we're throwing an exception there. So that takes care of the not having enough parts to it. Now the next issue was that of non‑numeric data. Now the way we're going to find that we have non‑numeric data is that when we call these parseDouble methods, they actually throw a NumberFormatException if that data is not numeric. So what we'll do in this case here where we actually convert the strings into doubles, let's wrap that in a try catch block to handle NumberFormatException. So we've got that there. So let's go ahead and complete our catch block. And again, we'll throw our InvalidStatementException. This time our reason will be non‑numeric data. So we've got our reason and the statement. But this time I'm going to add a third parameter, which is the original exception because we don't want to lose the fact that this was actually triggered by another exception. So we've got that there. So that takes care of our non‑numeric data situation. The last thing we need to check for is an invalid command. Remember the command is set by this setCommandFromString method. If I scroll down and look at that, remember that setCommandFromString actually takes that string value, goes through and tries to compare it with each one of the enumerations. And when it finds it, it sets the appropriate enumeration to our command field. So if we leave setCommandFromString and the command field is still null, we know it was an invalid command. So what we'll do is we'll scroll up here. Right after we get back from setCommandFromString, we'll check and see if that command field is null. And if it is, we'll again throw our invalid statement exception with the reason being invalid command. So now we have all of our error checking inside of our process method, and we raised those exceptions. But you'll notice that each one of these throws is underlined in red by my IDE. Well the reason is is it's complaining that I haven't handled this exception. Now, of course, I could put a try catch block in here to handle these exceptions. But obviously, I don't want to do that because I want the caller to get the exception. So what I need to do then is go up here to my method decoration and add a Throws clause for InvalidStatementException because remember our custom exceptions are checked exceptions. So now we've indicated that we throw that exception. So now if we go back to our main program, you'll notice that where we call process is now underlined in red because we're not handling the exception. The method declares that it throws it, so we have to handle it. So we'll wrap this in a try/catch block. And what I'm going to do is put the try/catch block inside the for statement because I want to make sure that if I get an error on one statement, I still process the next statement. If I put the entire for loop inside the try block, as soon as there was any error, it would jump out of the try block into the catch, and I wouldn't process anything else. So let's put a try block right in here, so we'll wrap the body of our for in the try. Then we'll catch the invalid statement exception. So we've got that there. And, of course, we'll put our catch block in place. We'll just scroll a little bit so we can see a little better. And what I want to do, of course, is print out the error message. And the way I get to the error message is I just go to the exception, and I call it getMessage method. And that'll write out the message for that exception. And that message for our exception was set when we called the base class constructor. Now remember that in some cases, we'll have not only our exception, but another exception. What we want to do is look inside of this exception and see if there's another exception that was the cause inside of there. So we'll put an if statement here again. I'm going to say e.getCause, and that checks to see if there's a cause associate with this, which is the other exception. Okay, if the cause comes back is non null, that means that we know that there was a cause. So if the cause comes back is non null, that means that there's another exception here. So what I'm going to do in this case is write out the message from that exception. So I call e.getCause to get the original exception and then call getMessage on that one. And so now when I go through here, anytime we get an InvalidStatementException, we'll write out the message for that InvalidStatementException. And if there was another exception inside of it, we'll write out that message as well. So let's go ahead and run this guy, and let's see what it looks like now. Alright, so we ran to completion. Let me make this window a little larger so we can see everything. And you notice here, everything worked as we expected. The first statement had an invalid number of fields because it only had two fields inside of it, the add and 1.0, so we see that there. The next one had non‑numeric data, the xx. So notice we write out our message non‑numeric data and show the statement. Beneath it we show the original exception, which pinpoints the fact that it was the xx. So that xx came from the NumberFormatException that was raised. And then our last erroneous one had that addX, which was an invalid command, which it wrote out appropriately. And then for the next four, which are all actually correct, those processed just fine. So we've now used a custom exception to signal our error, provide the caller with adequate information that they could then handle in their try/catch block.

Summary
To wrap up, remember, our focus in this module is on exceptions. And exceptions provide a non‑intrusive way to signal errors. And when we're working with exceptions, we use try, catch, and finally to provide a structured way to handle those exceptions. The try block is the work we want to perform normally, the catch block is what we want to do if something goes wrong, and finally gives us a common place to put our cleanup code. Now remember that exceptions are typed and can be caught by type. So you can have a separate catch statement for differing exception types. You can provide very specific handling for each type. Remember, though, you want to catch from most specific type to least specific because the system checks from the top down on the catches and the first catch it encounters that it can assign that exception type to it will use. So if you've got a more specific handler, you want put that before your more general handler. Remember, the exceptions are raised using the throw keyword, but remember that if a method has any checked exceptions that it doesn't catch, then it must declare that those exceptions can occur by using the throws clause on the method declaration. Now normally when we throw exceptions, we want to choose one of the built‑in exceptions, but if we need to, we can create our own custom exception types. And normally those exception types will inherit from the Exception class, which makes our custom exceptions checked exceptions.

Working with Packages
Introduction
Welcome to the next module in the Pluralsight Java Fundamentals course, the Java Language. In this module, we're going to cover working with packages. My name is Jim Wilson. So as we go through this module, the first thing we'll look at is, What exactly is a package in Java? We'll look at a lot of capabilities of packages and the benefits they provide, such as packages acting as a namespace. What does it mean to import a package? How do we use packages to limit access to content so we can have types and capabilities that are visible inside of a package, not outside of a package? And then this idea of distributing packages and working with Java archive files, otherwise known as JAR files?

What Is a Package?
Packages are important concept in Java, but they're actually a pretty simple concept. Basically, a package is just a group of related types. But by putting our types in packages, we get kind of three core benefits. One, packages create a namespace. They provide a way for us to avoid type naming collisions. To provide an access boundary. They provide a way for us to limit access to types and type members, and also, they act as a way for us to distribute our types. Now we'll look at each one of these ideas in detail throughout this module, but first, let's take a look at the idea of how we declare packages. Now each source file identifies the associated package, and we do that by using the package keyword. And the package declaration in a source file must appear before any type declarations. If we take a look at our idea of our Flight class here that we've been using throughout the course, to put that into a package, we simply add the keyword package and then the name of that package, in this case, xxxxxx. Once that package declaration is in the source file, any types that appear within that source file will now be part of that package. Now, obviously, a package name like xxxxxx is not going to be very useful in terms of dealing with naming collisions and so forth. So in this next clip, let's take a look at this idea of packages being useful as a namespace.

Packages Create a Namespace
As we mentioned, packages create a namespace, which is useful in avoiding naming collisions. And that's because the package name becomes part of the type name. Looking at our Flight class, the Flight class is now part of that package, and the package's name, again, is part of now the Flight class's name. But now naming your package all x's is not going to be very useful in avoiding naming collisions. But you recall from module 2 we mentioned that we follow a convention in our package names that creates uniqueness, and what we do is we use reverse domain naming. And what that means is that we take something like pluralsight.com. Pluralsight has registered with an authority to have the rights to use the domain pluralsight.com, and no one else in the world has the rights to use that domain. So if we make our package names a deviation of this register domain, we now get uniqueness. But, again, we do it in reverse order. So if we have a domain, pluralsight.com, we take our package and we name it something starting with com.pluralsight. If everyone follows that convention, we don't get naming collisions. Now we can further qualify the package name to be useful for whatever project we're working on. So for things like flights, we will put it into the travel package. So our Flight class is now in the package com.pluralsight.travel, and the type name now includes the package name, or we can say the type name is qualified by the package name. So if we go into code, and we want to go ahead and use the class Flight, there is no class named Flight anymore. What there is is a class named com.pluralsight.travel.Flight, and that fully qualified name now is unique throughout the world because of the conventions we follow. And the class's name is fully qualified in all uses whether we're declaring a variable like this or if we're creating an instance of it. With the package name being part of the type name, that's really useful for avoiding naming collisions, but fully qualifying all of our type names like we have here can be really cumbersome, so we need a way to get the benefits of the package name being part of the type name without having to fully qualify it each and every time. And that's what we'll take a look at the next clip.

Determining a Type's Package
With packages serving as a namespace for our types, obviously, the compiler needs to know each type's package. Now, of course, we can explicitly qualify each type with its package name, but doing that just is impractical. It just makes our code hard to read, and honestly, it's a lot of typing. Now Java offers several alternatives to explicitly qualifying our types, and what this does is it allows us to use the simple names of our types in our code. Now Java handles a couple of very common scenarios for us kind of automatically. One of those is that whenever you're working in a package, any types that you refer to that are part of that same package don't need to be qualified. Also, any types that we work with that are part of the java.lang package, and that's kind of the core package for the Java language, those don't need to be qualified, and that includes things like the Object class, our primitive rapper classes, the String class, StringBuilder, lots and lots of others. To see the full list of the classes that are in the java.lang package, just check out that URL I have on the screen there. These two behaviors take care of to kind of extremes, right, that the current package is the thing that's very personal to you, and the java.lang is the thing that's very general. But what about all the things in between? Most applications are going to involve a number of different packages, and that's where type imports come in. Type imports provide a way for us to tell the compiler how to map simple type names to qualified names. We do that using the import keyword. Now, one thing I want to note is that the keyword import may kind of give you the sense of direction of kind of loading something in, and that's not what import does. Import is just a mapping for the compiler, and basically, there's a couple of different ways we can do the import. One way is what's called a single type import. What a single type import does is it allows you to provide an import statement that maps in a single type. Now let's see what that looks like. So let's say we're working in our code, and we're building up the classes that we've been working on, so we have like our Flight class, and we specify that being part of a package. We've got like our Passenger class, and we specify that is being part of a package. So now both of those classes are in our com.pluralsight.travel package. So let's say as we're building up our application we want also incorporate maybe a third‑party package. And so if we think about if we're building code around flights and passengers, something that flights commonly do is provide beverage service, so things like selling beer and wine. So we want to go and use a third‑party package for those features. So we say we have a class like Beer that specifies a package from some company called XYZ Company, and it's also got a class in it called Wine that's part of that same package. So our package, com.xyzcompany.bar provides those capabilities around providing beverage service. So if we go off and we start building our application, and we want to go ahead and create an instance of our Flight class, and we don't have to explicitly qualified the class name, so in order to just say Flight, what we'll do is at the top of our source code we'll have an import that says com.pluralsight.travel.Flight. And so that tells the compiler that whenever we use the class Flight, what we're really referring to is the fully qualified class, com.pluralsight.travel.Flight. Or another way to say it is that we're referring to the Flight class as defined inside the package, com.pluralsight.travel. So if we want to use the Beer class, we'll do an import for that, so we'll say import.com.xyzcompany.bar.Beer, which tells the compiler that whenever we use the simple type name Beer, we're referring to the Beer class as defined in the package com.xyzcompany.bar. Same sort of thing if we want to use Passenger. We provide an import that maps that in, or if we want to use the type Wine, we provide an import that maps that in. So we end up with an import statement here for each of our individual types. Now, an alternative to the single type import is what's called import on demand. What import on demand lets us do is rather than providing a separate import for each individual type, it allows us to provide an import for each package and allows the compiler to map in all the types from within a package. If we take a look at the code that we have there, if we look at these four import statements we have here at the time, we can actually replace those, and instead of having a separate one for each individual type, we can have one for each of the packages. So we can have one that says import com.pluralsight.travel.* says to map in all the types from the com.pluralsight.travel package. We can do the same thing with import com.xyzcompany.bar.*, brings another type from that package. So then, during the compilation process, the compiler sees the simple name Flight. It looks inside those packages to find a definition of a class called Flight. So it automatically resolved that to com.pluralsight.travel.Flight. Or for Beer, it resolved to com.xyzcompany.bar.Beer. Now that may sound like a really good way to go, like, why would I use single type imports? Well, let's look at a scenario. Let's say that we're using these packages, and remember that com.xyzcompany.bar package comes from a third party. And so we go ahead and install a fresh version of that package because maybe there's a bug fix or something in there that we want. Inside of that package, maybe they've added another type. Maybe they've added a type inside of there called Flight. Something that's becoming very popular in recent years is rather than buying a single large beer, is buying something called a beer flight. A beer flight is this idea of three or four small beers where each one's a different kind so I can try out different things. So as this company wanted to stay current, they introduced this class called Flight, representing that concept. The problem with this is that now if I go ahead and compile my application, even though I haven't changed anything in my application, I'm now going to get an error on this line where I use Flight because the compiler is going to say that, well, both of those packages have a Flight class inside of there. I don't know which one to use. So with no changes to my code, I now have a bug. But if we use a single type important instead, because we've explicitly said when I use the class Flight, I mean com.pluralsight.travel.Flight, I'm not exposed to this problem. So the single type import prevents me from that kind of situation. So if we look at our options here, our single type of import is really the preferred way to import types because it's much safer. Now, you might be thinking that, well, I don't want to have to type in all those imports all the time. You don't have to worry about that. Modern IDEs will add your single type imports for you automatically. Pretty much all of them do. I know certainly IntelliJ and NetBeans do. Basically, when you're typing up your code, when you use the simple type name, the IDE automatically just adds the import to the top for you. But now, if you decide you want to use import on demand, remember that you want to use that with caution, because as we've seen, that exposes your code to potential breakage from things outside of your code itself.

Packages Provide Access Boundaries
As we mentioned, a package is generally a group of related types, and those types will provide some kind of related functionality. But sometimes all the capabilities inside of a package may not be meant to be used publicly. So a package can serve as an access boundary, a concept we've often referred to as package private. And what that's useful for is you have this case where you're providing some sort of public functionality, but sometimes there's some kind of internal work or internal housekeeping that has to go on that you don't want used outside the package. So the idea is that you've got these either types or features that support the package, but they're not meant to be used stand alone. And you can do this, again, at the type level. So you may have entire classes that provide functionality that's used by other classes inside the package, but not outside the package, or you might even have a public class that has certain features about it that are not meant to be used stand alone, they're only meant to be used to cooperate with other classes inside that package. So thinking about this now, we have four kinds of access modifiers available to us in Java, the one we just mentioned, the idea of this package private. Again, you do that by putting no access modifier either on a type or a type member, which means it can only be used by other types inside that package. Of course, we also have public, which means that the type or member can be used anywhere. We also have private, which means that it's a member that can only be used within the type itself. And then a concept of protected, and protected says it can be used by the type itself or other types that inherit from it. And as a protected member, it can be used by any type it inherits from the class, whether it's in the same package or not. So package private is the only one that really applies to package boundaries. Now one thing to note. The ideas of private and protected only being usable on types is limited to the concept of top‑level types. You have something called nested classes, they can be marked as private or protected. We're going to talk about nested classes just a little bit later in this course.

Separating CalcEngine into Packages
In this demo, we'll take our CalcEngine application and separate out the application part of it from the classes we might want to reuse in other applications. The way our CalcEngine project is currently written, the app part of it, our main entry point, is in the same package as all the classes we use to do the work. Now there's a high probability that if we do a job with these classes, we might want to use these features in other applications, so it probably makes sense to split the application part of this out from those other classes we might want to reuse. So we're here in our main application, so let's get it out of the com.pluralsight.calcengine package and let's move it into one called something like com.pluralsight.myapp. Now remember that the way we change the package from a Java standpoint is simply change the package declaration. So we want to change this calcengine to say myapp. From a Java standpoint, changing that package declaration is all we have to do. But remember as we talked about module 2, some of the IDEs actually require that the source file structure, or to say the source folder structure, matches the structure of the package name. So for IntelliJ, we actually have to move Main into a folder that corresponds to our package structure. Fortunately, IntelliJ will do that work for us. Notice this little lightbulb that's up here. If I click on that, it's going to say Move to package com.pluralsight.myapp. Making that selection now causes it to move that source file and re‑set up all the folder structure we need. NetBeans does that same thing. So if you look over here now, the way it's laid out is we've got under a src folder com.pluralsight, and there's two subfolders, one for calcengine and one from myapp. Myapp contains Main. And again, that works very similarly inside of NetBeans. Now the problem, of course, now is that because the main source file is no longer in the same package as our support code, things like CalculateHelper, we now need to add import statements for those. One of the nice things, though, is that the IDE helps with that, like our CalculateHelper here. Notice that it's saying that if I just do Alt+Enter, it'll go ahead and add that import for me. You notice the import was added at the top. Scroll up so you can see everything here. So we still have our package declaration, but that import was added for us. Again, NetBeans works very similar to that. It will go ahead and add those imports for us. If I scroll down here, things like our InvalidStatementException. Again, I can just do Alt+Enter and we'll add the import for that as well. So if I scroll back up here, I've got that as well. So if we scroll down here, again, that's going to happen for all our classes that are coming from our com.pluralsight.calcengine package, MathEquation, scrolling down here, things like CalculateBase, Divider, Adder, Subtractor, Multiplier, all those. So what we want to do is make sure we have imports for all those. So we'll have to add space so we have room for all those. Now again, I could go through and have IntelliJ add all those for us, but I'll go through and just add them here quickly. So now we have all the import statements that we need here. Now, one thing to note here is that right now we have about eight imports, all coming from com.pluralsight.calcengine. As we mentioned, it's good to use the single type imports because it protects us from any changes in an outside package. One thing I want to point out about a behavior in IntelliJ, I don't want to spend a lot of time on the IDE, but this is something that's important to note. IntelliJ does something with the imports. By default, if you have five or more imports from the same package, it actually switches over to import on demand. So it just replaces all these individual imports with one import with a star on it. Again, that's a dangerous behavior. So let me just show you quickly how to fix that inside of IntelliJ. If we go up to our Final menu and we choose Settings, here under Settings you want to go to the Editor section, the Java section under that, or I should say Java subsection, there's an Imports tab. You want to set this entry here where is says Class count to use import with *. Normally that's 5 by default, but you want to move it to a high value like 100 or 1000 to prevent it from actually switching over to import on demand. NetBeans does not have that issue. That's an IntelliJ thing. So now we have all our reusable classes in the CalcEngine package with Main off in its own package for the application. Now something to think about here. Let's go our CalculateHelper class. Remember, our CalculateHelper class has a field inside of it called command that uses the type MathCommand. Remember, MathCommand is an enumeration that we're using inside of CalculateHelper so that once we determine the string representation of the operation, we can use the enumeration in the rest of our code. Now that's meant for our own internal usage. We don't want other people using it, so we don't want that to be public. So what we'll do is go into our MathCommand source file here, and we'll just take away the public on it. So now it has become package private. It can only be used in our packet. It's important to do that with things like MathCommand here that we're using internally, because it may seem at first okay to say we'll just go ahead and leave it public, if people use it, who cares? Well, if other code that you don't control starts using this enumeration and then you need to make a change to it for some reason, you now risk breaking their code. So any types that we create that are meant only for use in our package, it's important to not declare them public, to make them package private. So what happens is that now that that's package private, if I go into Main, which is in a different package, but if I try to use MathCommand, it won't actually let me. If I just type MathCommand, notice that MathCommand is not even coming up in our options. I'll go ahead and type it all the way out. Notice that it still just says that that's an error, I don't know what that is. I can't resolve the symbol, even if I try to forcibly put the package name in front of it. You'll notice now I end up with an error saying it can't be accessed outside the package, so that protects it from being used outside of the package. So now with Main being off in its own package, myapp, everything should still work fine because I have all the necessary imports in there. So if I run this, you'll notice that we ended up getting an error here. And you see this ClassNotFoundException. And it's our main entry point. The problem here is not a Java problem, it's an IDE problem. Again, I don't want to spend a lot of time on IDE details, but one of things to be aware of is that if you change the class its associated with your application entry points in the IDE, you want to make sure that the IDE knows about it. So to tell IntelliJ that we've changed the startup path, we'll go here to Run, Edit Configurations, and notice that the Main class here is still pointing to the one in CalcEngine. So I could just go here and change this to myapp, or I can click the button here and just choose it. You'll notice it says, well, here's a class called Main in the com.pluralsight.myapp package that will actually satisfy the requirements of a startup path. So we'll go ahead and choose that, and now we'll say OK. And so now when we run our application, everything works just as it should.

Packages Act as a Unit of Distribution
When we create software, whether it's for an entire application or just some classes we want to give to other developers to use, at some point, we want to distribute that software. By working with packages, our software gets built into a predictable structure, and that predictable structure simplifies this idea of distribution. So our class files get organized in hierarchical folders that reflect the name of our package. Basically, each part of the package name gets a separate folder. So if we look at something like our Flight class that we've got in the package com.pluralsight.travel, when we build this, we'll get a folder com with a subfolder pluralsight with a subfolder travel, and then we have our Flight.class file goes into that travel folder. That Flight.class file is the compiled version of our class. It's the byte codes for our Flight class. So now if we have another class like Passenger that's in that same package, well, it'll be in the com folder with a subfolder pluralsight, subfolder travel, and then we get our Passenger.class file in there, the compiled version of that class. So all the classes that are in that package will be organized under this same folder structure. So I can actually distribute this software by taking that com folder and its contents and just copying it to another computer and it'll have the software. Now as nice as it is working with a simple folder structure like that, there might be a better choice than that, and that's where archive files come in. Archive files allow us to put that folder structure into a file, and these are commonly known as jar files. And what it does is it takes that entire hierarchy of the folders and can put it into a single file. And that file can even optionally be compressed. So we now get the convenience of moving from an entire folder of files into a single file, and the file can be efficiently stored. In addition, the archive file can optionally include a manifest, and that manifest provides information about what's going on inside that archive. And, basically, it's just a bunch of name‑value pairs, and I've got the URL on screen showing the documentation for the manifest. But one of the things we commonly use the manifest for is identifying the startup class that's contained in an archive file, making it easy for us to run a program that's inside of an archive file. Now it's easy to create archive files. The JDK actually provides the utility for doing so called the jar utility. Now it's a command line utility, and it's easy enough to use. But we have other options as well. Many other tools actually include the ability to create jar files. A number of the integrated development environments, or what we commonly know as IDEs, have that ability. In fact, both the ones we talk about in this course do. IntelliJ does, as well as NetBeans, as well as many others have that built right into it. So as part of our build process, we can generate a jar file. Also, many of the build automation systems, or what we commonly known as build managers, have that ability. Those include things like Gradle, as well as Maven and many others. So that we have that command line utility for creating jar files, very often we never have to use that. We can actually produce the jar files as part of other build processes that we do. So in our next clip, let's take a look at using packages for distribution and working with those packages in archive files.

Distributing CalcEngine as a Jar File
In this demo, we'll take a look at how we can package up our applications in a JAR file for distribution. Here we have our application opened up in an IDE, in this case it's IntelliJ, and the application is in the exact state it was when we finished up the last demo. Now, as we know, of course, we can run this from right inside of the IDE. We've done that a bunch of times. We want to look at now at how we can distribute it around so people without the IDE can run it. And we touched on this briefly back in module two, but we're going to look at things a lot more closely now. So now, if I switch over to the folder where this is built out at, so here I am in the folder that contains the demos for this module, working on the CalcEngine demo right now, so let's go inside of there. And what we want to look at is the out folder. And again, this out folder is something that IntelliJ uses. Other systems use different folder structures. So I'm going to go in here into a production folder and CalcEngine. So this is the output from CalcEngine. And you see the only thing we see here is a com folder. Remember that we said that building the Java application creates a folder structure that corresponds to the package names. So I say com, pluralsight, and when I get inside of there, there's two folders, because I have two packages that fall under com.pluralsight, calcengine and myapp. And from a nomenclature standpoint, calcengine is considered to be a subpackage of com.pluralsight. There's no special relationship there other than how they're stored, but it's just the terminology that's used. The same way myapp is a subpackage of com.pluralsight. If I go into myapp, we see the class file for Main. This is the compiled version of Main. If we go back over to pluralsight, go into count engine, you see all the class files there for all the compiled versions of the classes we have in that package. And so now if I want to jump back up here to com, then I'll go up one more level to where CalcEngine is, this is kind of the root of my package. So I feel to run the program from here. So if I wanted to, I can go in here, and I can open up a command prompt. So here we're on the command prompt. So if I want to run the program, I just type java, and then the class that's my entry point, which is com.pluralsight.myapp.Main. So now I just go ahead and hit Enter, and, of course, the application runs. So that proves that if we were actually to take this com folder and its contents and copy it over to another machine, as long as that machine had Java installed on it, we could run it on that machine just like this. But as we talked about, JAR files are a much more convenient way to distribute our applications, so let's take a look at how we can actually create that JAR file using the IDEs. We'll look first at doing it with IntelliJ, and then I'll show you as well how to do it in NetBeans. Again, of course, you could also use the actual JAR utility. I've got the URL on screen for the documentation for the JAR utility. But we're going to focus on the IDEs for right now. So, I'm going to go back here into IntelliJ. Now, IntelliJ is kind of interesting. It kind of uses a, kind of a, I would say kind of an unusual way, or at least a nonstandard way of how you specify you want to create a JAR file. Other environments tend to do it kind of more directly as part of the build process. IntelliJ actually has, the generation of the JAR as kind of something separate. So the way we set up the JAR file in IntelliJ is we go to the File menu, go to one here called Project Structure. And you notice here under Project Settings here on the left, there's one option here called Artifacts. Now, artifacts are other things you can produce from the project. A JAR file is considered an artifact in IntelliJ. So what we do is we go up to this plus sign up here, we choose that, and it says what kind of artifact you want? Well, I want a JAR artifact, and I want to generate a JAR file from the modules that are in this project. So I'm going to go ahead and choose that. And notice one of the options here when style box pops up is Main Class. So it says, well, do you want me to actually put a Main class as the entry point in this? And we do want to do that. So I'm just going to choose the dot, dot, dot here, and I'm going to choose my com.pluralsight.myapp.Main. So I'll say OK. Now what this does once I choose that option is it actually will generate the manifest for this JAR file, specifying that that's the main entry point. And we'll see why that's useful in a minute. So I'll go ahead and say OK. So that's all set up now, so we'll say OK again. So now if I was to go off and just build my project right now, I still wouldn't have a JAR file. In order to get the JAR file, what I have to do is go to the Build menu, choose Build Artifacts. So it says, what you want to do? So it's CalcEngine:jar, and I want to build it. And so that now goes off and builds that JAR file. So what I want to do is let's go back to the file system now. So here we are in the file system, and you'll notice that before we just had that com folder here. Notice now that there's a META.INF folder. That's actually going to contain our manifest. If I go inside of here, you see this MANIFEST.MF. That's our manifest file. If I double‑click on this, you notice that it has an entry in here of Main‑Class: com.pluralsight.myapp.Main. That actually gets included in the JAR file, so we're able to just basically execute the JAR file, and Java will know what class we want to run. So let's go ahead and close this guy out. I'm going to jump back up here to my out folder, and you notice here that there's an artifacts folder. If I go inside of there, notice there's a folder called CalcEngine_jar. So that's our JAR file. So let's go ahead and open a command prompt in this location now. So here we are in the folder containing the JAR file. And what's nice about this is that since the JAR file actually specifies what the main entry point is, I can effectively just run the JAR file. I can just say java. I'm going to use an option ‑jar, and then I'm going to put it in the name of the JAR file. So basically, that tells Java to run this JAR file. Because the JAR file includes a manifested that says what the main entry point is, Java can figure out what class to run. So if I just go and run this now, our application runs correctly. So you see that's where the value of the JAR files come in is that not only do we have this nice kind of packaging of the whole application in a single file, but even the file includes the information necessary to run its contents. And there's other information that can be included in there as well. Now, let's go back to our file system for a second. Now remember I mentioned that JAR files follow the standard ZIP file format, and so we can actually explore inside of a JAR file pretty easily. Now just note there are utilities that will actually let you kind of generate the source code tied to the contents of the JAR file. That's something we're looking at here. I just want to show you what the structure of the inside the JAR file looks like. So what I'm going to do is I'm going to take this file, and I'm just going to copy it. Going to paste it back in. And what I'm going to do is I'm going to change its name. I'm going to change its name to CalcEngine.zip. Now the reason I changed its name is because I'm on a Windows system right now, and on Windows, once it sees that that's a zip file extension, it will actually allow me to explore it as a ZIP file. So we'll go ahead and hit Enter. Windows just promised me to make sure I really do want to change the file name, and I'll say Yes. And so now when I double‑click on this CalcEngine.zip, I can now explore its contents. And you notice that it's looking very much like the folder we were looking at earlier. We see our com folder, pluralsight, and then these are the package subfolders containing the class files. So we can see the JAR file really is just a ZIP file with the addition of that manifest. As I mentioned earlier, IntelliJ uses a very different process for generating the JAR files than most other environments do. So I'd like to show you here just quickly inside of NetBeans how you set NetBeans to generate a JAR file. So what I have open here is this HelloNetBeans project we created earlier in the course. What we'll do is really straightforward. I'm going to go over here to the project structure, right‑click, choose Properties, and you notice there's an option here, or a section lets say, on Packaging. We're just going to choose Packaging, and basically we'll say go ahead and create the JAR file, compress the JAR file, and we'll say OK. The simple fact of doing that, now when we build a project, NetBeans will now generate the JAR file. So the JAR file will just be part of the build process. So, unlike IntelliJ, where generally the JAR file was a separate process, here in NetBeans it'll just be part of the overall build process.

Summary
To wrap up, remember that basically a package is a group of related types. We put types into a package by simply putting a package declaration inside of the source file. But remember that that package declaration must occur before any type declarations do. And although a package is a group of related types, that grouping of being a package provides a number of capabilities or a number of features. First of all, packages act as a namespace because types are qualified by their package name. That avoids naming collisions because it gives us fully qualified names, but typing those fully qualified names all the time is cumbersome. So we use the import statement to map simple names to qualified names. Packages serve as an access boundary. So we can have types and members that are visible inside of the package but not outside of the package so they can provide support for the capabilities of that package without being directly usable on their own. Packages serve as a simplified distribution. Remember that types inside of a package are organized hierarchically, which is nice, but to go one step further than that suborganization, we have archive files, or what are known as jar files, which allow us to take that package hierarchy and put it into a single file. Remember that archive files can also have a manifest, which then provides descriptive information about what's going on inside that archive file.

Creating Abstract Relationships with Interfaces
Introduction
Welcome to the next module of the Pluralsight Java Fundamentals course on the Java language. In this module, we're going to take a look at Creating Abstract Relationships with Interfaces. My name is Jim Wilson. Throughout this module, we'll look at a number of issues related to interfaces. We'll start by just defining what an interface is. We'll then look at implementing an interface, and we'll do that by taking a look at some of the interfaces that are provided by Java. We'll then look at how we can have a single class that implements multiple interfaces. We'll then take a look at declaring our own interface, and we'll do that by adding some features to our CalcEngine app that we've been working on throughout the course.

Introducing Interfaces & Implementing an Interface
In Java, an interface is a type that defines a contract. The key difference between an interface and a class is that interfaces do not provide any implementation, they simply provide the contract. Classes implement that interface, indicating that a class conforms to the contract. The key thing is that by implementing an interface, it doesn't limit other aspects of the class. The class can do whatever it needs to in a general sense, as long as when it's implementing the features of the interface, it conforms to the contract defined by the interface. Now the easiest way to see this is with an example. Let's take one of the built‑in interfaces called Comparable. The Comparable interface is used for determining relative order. How does one instance of a class compare to another instance? And so it has one method called compareTo, and basically inside that compareTo it's passed in another instance. And the return value of compareTo indicates how the current instance compares to in sequence to the other instance it was passed in. So, if compareTo returns a negative value, it says, well, the current instance should come before the one that was passed into it. If we return a positive value, it says the current instance should come after the one that was passed to it. If they're actually equal, it returns 0. Let's look at our Passenger class. Now our Passenger class has been used for a lot of things throughout this course, but let's say we want to add the concept of like a frequent flyer program so that we can give people premiums. So we'll have a concept of a member level. So the highest level is level 3, the lowest level is level 1. You might think of this as like level 1 might be like a silver member, 2 might be a gold member, and 3 might be like a platinum member. So any premiums we hand out, we want to give to the level 3 folks before we give them to the level 2, and before the level 1. We also want to keep track of how long someone has been a member. So what we'd like to be able to do is compare two passenger instances based on this idea of the frequent flyer program and have the people who have the highest priority come first, the people with the lowest come later. So what we'll do is we'll go ahead and add the implements keyword, and then the comparable interface. So we're going to say that our Passenger class implements the Comparable interface, or conforms to the comparable contract. So we'll have that one method, compareTo, it accepts a reference to another instance. Right now it's defined to accept an object. So one of first things we'll want to do is go ahead and cast that object into an instance of Passenger, and then we want to kind of go through the test we have to do to determine who should come first and who should come after. So we'll first check and see, well, if our member level is higher than the one that's passed in, we're going to return a ‑1, saying that we should come before that one. So if we are a level 3 and the one passed in is a level 2, it should return ‑1. On the other hand, if we're something like a level 1 and they're a level 2, we'll return a +1, saying that we should come after them. But now what if it's a tie? Well, you figure that if an airplane may have 200 passengers and there's only three levels of membership, there's a high probability that there are ties. So what we'll do is that in the case of a tie, we'll check how long they've been a member. So we'll put an else block here and then we'll say, well, if our number of days are greater than the one passed in, again we'll return ‑1 saying that we come before they do, then we'll say, well, if we're less than them, return a positive value would come after, and then if they're the same level member and they've been in for the same number of days, that's actually a tie, and we'll return 0. So now the value of implementing this interface is that we can take advantage of features that know how to work with a comparable contract. Let's put together some code here. So we'll declare an instance of a passenger, we'll name the passenger Bob, and we'll say that he is a level 1 member and he's been in for 180 days, so he's like a silver member and he's been around for six months. If I have another member, Jane, Jane is also a level 1 member and she's been in for 90 days, then we'll have Steve, who is a level 2 member, like a gold member, and he's been in for 180 days, or about six months. And then finally we have Lisa who is a level 3 member, so like maybe like a platinum member. She's been in for 730 days, or about two years. What we'll do then is declare a passenger array and then load that array up with Bob, Jane, Steve, and Lisa. We can then use a built‑in method called Arrays.sort and pass in passengers. Because we conform to the comparable contract, that sort method can now go through and do an efficient sort and order these based on the rules of our comparable implementation. So after we return from sort, the first member of passengers is going to be Lisa, the one with the highest status, the level 3 status, like our platinum status. Then it would be Steve who has the next highest level. Then we have Bob, because even though Bob and Jane tie on the level, Bob's been a member longer at 180 days, and then finally, Jane. So now, simply by implementing that comparable interface and conforming to that contract, we were able to take advantage of the efficient sort capabilities provided by Java. Let's look at another example. So we have this Flight class we've been working with throughout the course, and let's say we're going to have our flight start tracking the time that they fly. And for simplicity, we'll just track that time as minutes past midnight. So if a flight takes off at 12:15, then it would have a flight time of 15. If a flight takes off at 1:30 am, it would have a flight time of 90, right, 90 minutes past midnight. We want to be able to sort these flights based on the time they take off. So what we'll do is we'll implement that comparable interface, and we'll come in and compare our two. Now in this case, we're going to order them by time. So we'll first, of course, want to cast that object that's passed into a flight, and then we can say, well, if our flight time becomes before the passed‑in flight time, return ‑1, saying that we should be sorted first. If ours comes after, we return 1, saying that we should be sorted after. And of course if there's a tie, then return 0. But it's interesting if we look at this. If we look at the definition of the comparable interface, it says the compareTo uses the sign to determine order. It doesn't say it has to be ‑1 or +1, it simply says that negative says it should come first, positive says it should come after. Well if we think about this, if I have a flight time of, say 15, or 12:15, and I compare that to another flight time of 45, well if I subtract 45 from 15, I'll get ‑30. So that would still be negative saying I should come before. So I can actually simply take all this code we have here with these comparisons and boil it down to some simple arithmetic. If I simply subtract the passed‑in flight time from my time, if I'm before the value will be negative, so I'll be sorted before. If I am after, the value will be positive, I'll be sorted after. So that's a very simple implementation of compareTo. So again, I can do that sorting idea. So I have a flight, say lax045, that takes off 45 minutes past midnight, I have another flight, slc15 that takes off 15 minutes past midnight, and finally nyc030 that takes off 30 minutes past midnight, if I take the array, put those guys inside there, and sort it, I'll now get again that sorting ability. The 12:15 one will come first, the 12:30 will come second, and 12:45 will come after. And see, the key thing there is that Flight has a really, really simple implementation of comparable, Passenger had a much more involved implementation, but by simply conforming to that contract, we're now able to take advantage of the very same features and get the very similar results while still having the ability to define the right way to conform to that contract within the features of our type.

Implementing a Generic Interface
When working with interfaces, you'll notice that some interfaces require additional type information. This uses a concept known as generics. Now if we were to go in and take a look at the declaration for the Comparable interface, you'll notice that after the name Comparable, there's this less than symbol, the T, and then a greater than symbol. This is saying that the Comparable interface implementation can be tied to a type. So if we take a look now at the way it declares the compareTo method, you'll notice it has that same T. So we can specify in implementation what type we want to expect to receive in that compareTo method. So if we take a look here at our Flight class, now right now our Comparable doesn't specify a type, which is why compareTo is accepting an object. But if we instead after the Comparable put in the less than symbol and Flight and greater than, we're now saying that we want to implement Comparable using the Flight type. So our compareTo method then, rather than having an object as parameter, would have a parameter of type Flight. That would allow us to get rid of this cast from object to Flight. It would also give us all the type safety of having typed parameters, so we're not dependent on receiving things as an object and then having to convert them. We know that by the time they reach our code, it's already the appropriate type, in this case Flight. So, similarly, if we take a look at our Passenger class, rather than their comparative for Passenger accepting an object, we can specify that our Comparable should be tied to the type Passenger, so then in that case our CompareTo would instead accept a Passenger parameter, and we can get rid of again that cast that we have in place. Now, one thing to note is that when you implement the interface, the type that you pass in doesn't have to be the same type as the class that's implementing it. In some cases, it makes sense to, in other cases it doesn't. We'll see an example in the next clip of a time when we don't actually have to use that same type. I also want to note that generics are not something that's specific to interfaces. Generics are this kind of generalized concept in Java that's a very, very powerful concept. Once you've had a chance to work with the basics of Java a bit more, I would encourage you to check out the Pluralsight class on Java Generics. I have the URL for that class up on the screen now.

Implementing Multiple Interfaces
One of the real values of interfaces is that classes are free to implement multiple interfaces. Remember that a class can only extend one other class, but a class can implement as many interfaces as it needs to. So that means a class can conform to as many interface‑based contracts as it needs to. So let's take a look at something. Remember, we've got our Flight class here and we know it's already implemented, the interface Comparable, but let's say we want to extend our Flight class a little bit more. Remember that up until now, we've kind of kept a count of the number of passengers we have, but let's say we want to extend our Flight class to actually keep a list of actual passengers. So we create a member variable called roster, it's an array of Passenger, and let's also go ahead and create a CrewMember array we'll call crew, so we can keep track of all the people that are actually on the flight. Since we have all these people on the flight, we'll probably want to be able to list them all at some point, both crew members and passengers. Let's look at those two types. First we have our Passenger class. Now that implements an interface Comparable, but it doesn't have a base class, so we know its base class is object. And of course CrewMember doesn't have a base class either, so its base class is object. So anything that's common about CrewMember and Passenger at this point is the object class, and that's not really useful for us in terms of trying to treat them as kind of people. So it probably makes sense, first, to go ahead and create a class called Person that has the common characteristics of a person, we'll say each person at least has a name, there's probably other characteristics as well, and then we'll take our CrewMember class and we'll have it extend the Person class. We'll also have our Passenger class extend the Person class. So now CrewMembers and Passengers have a commonality, they're each considered an instance of a person. So what we'd like to be able to do here is use a for each statement to walk through every person on the flight and be able to print out their information or interact with their information. So if we look up at the for each statement, it would actually tell us that in order to be able to work with a for each statement, you have to implement an interface called iterable. If we take a look at that interface, so the iterable interface is really simple. Again, it's a generic interface, it has a type associated with it, and has one member, iterator. So we'll take our Flight class that already implements the interface Comparable, we'll go ahead and have it implement the interface Iterable. Notice that this one is based on a type person, and I just want to mention that earlier we said that sometimes we implement interfaces, the type associated with them is the same as the class, like it was for Comparable, it used Flight. But for Iterable, we're using Person, which is different than the class Flight because we want to actually keep passing back a person each time it goes through the list. So the interface Iterable has one method. So again, that's the iterator method, and it returns back a type called it iterator. Well, the type iterator is also an interface. It has two methods on it. It has one hasNext, which tells you if there's more to come, and then a method next that returns you back to the next thing, in this case it would be the next person. And when we implement iterators, we generally implement a separate class to actually manage the iteration. So what we'll need to do then is implement a class here that actually implements the interface Iterator. So let's go ahead and set that up, and we'll call this class our FlightIterator. As we said, we'll implement the interface Iterator. Again, each time it will return back a person. We have the two methods, hasNext and then the next method. So of course what we want to do here is walk through the list of every person on the flight, whether they're a crew member or a passenger. But, of course, we'll need those two arrays. So let's have member variables for each of those, one for the crew and one for the roster. We'll have a single index that will walk through the entire combined list, and let's create a constructor that we can use to actually accept those arrays. So we have a crew and roster, and we'll assign those two our member variables. And so now let's look at our implementation. Well, first we have hasNext. How do we know if there's more information to come? Well, if we haven't walked through the entire combined list of crew and roster, there's more to come. So as long as our index is less than the combined length of the crew array and the roster array, there must be more to come. Then our next is going to return back each individual person. So first we'll walk through the crew array, and then we'll walk through the roster array. So basically we'll have our Person p, and we'll actually say, well, if the index is less than the crew length, we'll simply return back the crew member that corresponds to that index. So if there were three crew members, indexes 0, 1, and 2, we'd walk through the crew array. Once we get to 3, we now want to switch over to the roster array. So in that case, we'll just use roster with the index minus the crew length. So if we're on index 3, well 3 minus the length of the crew array, 3 is 0, that gives us the first one in the roster. So once we have the person, we'll increment the index and then we'll return back that person. So now we have our FlightIterator class that manage generation itself. What we want to do now is return an instance of that back from our Flight class's iterator method. So we'll just return that back, that new instance. So now we actually have everything we need to be able to walk through every person that's on a flight, both crew and passengers, using our for each statement. So let's take a look at some code to do that. So we'll go out here and we'll create a flight, our lax045, and let's say we'll add some crew members to it, Pilot Patty, CoPilot Karl, and Marshal Mary, and then we'll add our passengers to it, Bob, Jane, Steve, and Lisa. And then we'll create our for each statement. So for(Person p:lax045). That's going to say use the iterator to go through each person that's on that flight, and we'll write them out. So of course we run this code, we would see each of the crew members first, and then each of the passengers. Now this may seem a little bit abstract because we read all that interface stuff, but nothing we're looking at here in the code actually shows the interface stuff. Well that's because the for statement actually expands out to actually work with the interfaces. So the code I'm going to show you here is kind of conceptually what happens, it's not the line‑by‑line detail of what actually happens, but it gives you an idea of what's actually happening under the covers. When we create that for statement, what effectively happens is it takes the flight, the lax045, casts that into its Iterable interface, then using that we get the it iterator. So here we're putting that in and calling persons, and then basically we loop over that. So we have a loop in place to just make sure that hasNext is returning true, saying there's more to come. Then we use the next method to get whatever is next, the next person. First the crew members, then the passengers, and then finally whatever is the body of our loop executes, in this case printing out the name. And so you see here now the power of interfaces is that the for each statement is used with many, many, many different types, and those types have very little or basically nothing in common. But because as long as the type conforms to that Iterable interface's contract, it can take advantage of the power of the for statement.

Declaring an Interface
Up until now, we've been looking at implementing existing interfaces, but we can also declare our own interfaces. Now declaring an interface is very similar to declaring a class. You use the interface keyword to define an interface. Now interfaces support a subset of the features that are available to classes. Now interfaces can have methods, but when we provide the methods to an interface, we simply list the method name, its parameters, and its return type. Remember that interfaces do not have an implementation, they're just defining a contract. Now the methods in the interface are implicitly public. Now interfaces can also have constants, and basically we're just saying that that is a typed named value. Now the constants that we put on an interface are always considered public, final, and static. We don't have to use those keywords, but they're treated that way. What that means is that any constant you associate with an interface has the same value for all implementers of the interface. There's no concept of a per‑instance, constant in interfaces. It's always interface wide or true for all implementers of that interface. Also, interfaces can be extended. One interface can extend another interface, and what that means, of course, is that it means you can add additional methods and constants to it. All right, so in a way that you can extend classes, one interface can extend another. And what's neat about that is that when you extend an interface, you're kind of adding an additional contract to it. So any class that implements an interface that extends another interface is automatically considered to implement the base interface. In our next clip, let's take a look at declaring our own interface inside of our CalcEngine program and what it's like to work with that interface once we declare it.

Dynamically Extending CalcEngine: Declare and Implement
In this demo, we'll be using interfaces to dynamically extend the capabilities of our CalcEngine app. As you recall earlier in the course, we added the ability of our CalcEngine app where we could type in things like this where we say add 1.0 2.0, and the CalcEngine app would then do the calculation and then write back the result in a more traditional format, 1.0 + 2.0 = 3.0. What we want to do now is make this more dynamic. Currently, the way the app is written is that the code that actually does all the work to take things apart and produce results is tied to a very particular class. What we want to do now is make that more abstract. Let the core work behave in terms of an interface and have specific calculation abilities implement that interface so we can easily plug in new abilities into our CalcEngine app. Here we are on our CalcEngine app, and we're picking up our code where we left off at the end of the last module. But what I've done, though, is that all the code that was in our Main function is now in this function called useCalculateHelper, and I've put a call into that function, but commented it out. Then what I've done is I've stripped it down so that we have just one statement, you can see the add 25 and 92, and then a simple for loop to walk through that array of statements. So what we want to do now is again take that functionality that we have in CalculateHelper, but make it more dynamic by using interfaces. Now if we look at our CalculateHelper class, if I go inside of here, basically when we process a statement, we do a few fundamental things. First of all we split it apart based on a particular character, which is the space character, and then once we've split it apart we have to identify the command we want to execute. If I scroll down here, currently the list of commands we support is hard coded, Add, Subtract, Multiply, and Divide. So we've got to work through that list. And then what we want to do is do the operation, but our operation is done in terms of a base class, CalculateBase, and then we produce output. And the output relies on having a symbol for each operation. If I go up top here you see that each symbol is hard coded, a plus sign, a minus sign, an asterisk, and a slash for divide. What we want to do now is take these ideas and implement them were generically using an interface. So that's going to create an interface now that represents the parts of doing this work. So I'm going to go in here, I'm going to go ahead and add an interface, so I'll add an interface in IntelliJ, very similar to a class, we'll just do a right‑click and New. And the way to tell in IntelliJ is that it's still the new class dialog, but we changed this from Class to say Interface. But we'll see that we could actually just type it in very easily. And we'll call our interface MathProcessing. So we'll go ahead and create that. And you can see the declaration is very simple, it looks very much like a class that just says interface instead of class. So we want the interface to represent the parts of what we need to do. So let's go ahead and add those in there. So first thing we'll do is we'll add a constant called SEPARATOR that has a value of space, that's the character we use to split statements apart, and then we want to model what we need to know for anything that implements operations that do these calculations. Well, one thing we need is a keyword. So let's add a method called getKeyword. So that would give back a keyword that the particular implementation knows how to handle. For example, maybe something like add if there's implementation that knows how to do adding. The next thing we need to know from any implementation is what symbol it wants to use in the output. So I have another method called getSymbol that's a type character. For something that did addition, that would be the plus sign. And the last thing we need to do is actually perform the operation. So let's create a method called doCalculation that returns double and it accepts two values, a leftVal and a rightVal that are both doubles. So that's our entire interface. Again, there's no implementations, it's just a contract. Classes that implement this will conform to the MathProcessing contract, which means they have to identify the keywords in there that it will work on, return back a symbol that will be used to produce the output, and then do the calculation that goes with that keyword. So what we can do is go ahead and use our existing Adder class to implement this interface. So I'm going to go over here to my Adder class, I'm going to go ahead and have it here implement MathProcessing. And of course we have to go ahead, provide the methods for that, so I'm going to let the IDE do that for me by saying Implement methods. I want to implement all the methods with that interface. So we'll say OK. And so that now provides those methods, right? So we just have to do the work associated with each method. Well, my Adder, the keyword to the handles it adds, so I'll have it return back the word add, the symbol that it uses is plus sign, and then we have to do the work. Our adder is written in terms of this CalculateBase class, so we'll do the addition using the CalculateBase class way of doing that. So the first thing we'll do is we'll set our left value. Then we'll set our right value. Then we'll call our calculate method. And then finally, we're going to return back the result. Scroll here so we can see everything. So when you see now, that's everything Adder has to do to conform to this interface. Now just one thing to note. Scroll up here. Adder extends CalculateBase, so we could have had CalculateBase implement the MathProcessing interface if we wanted all four classes that inherit from it to implement the interface. We basically just had CalculateBase say it implements MathProcessing, make all the interface methods abstract, and the derived classes would then implement them themselves. We're going to focus in here now just on having Adder do it. So this gives us now a class that implements that interface. In the next clip, let's see what code we'd need to write to now use this interface.

Dynamically Extending CalcEngine: Add support
So we have this interface, MathProcessing, that models the concept of a class being able to identify a keyword it operates on, do the operation, and tell us what symbol to use when producing the output. Adder implements it. What we want to do now is write a class that does that same work that CalculateHelper did, but would do it in terms of handlers that implement the interface rather than a set of hard coded operations. So let's go ahead and add another class to our project. We'll call this our DynamicHelper. So we have our DynamicHelper class, and what we'll do is store a list of handlers. So we'll do that as an array. So I'll declare an array here of type MathProcessing called handlers. So that will be the list of handlers that a given instance of DynamicHelper has access to. We'll then have the constructor accept an array of handlers and store it inside of our class variable. So whenever we create an instance of this class, we just pass in that array that contains all the handlers we want it to use. And then from there we'll add a method called process that accepts a string statement to operate on and returns back a string result. So the idea is that what would come in would be something like add 1.0 2.0, and then what goes out would be the traditional math representation of that showing the result. So the same work we did earlier in CalculateHelper, but again we're doing it this time in terms of the interface. Now we still have to do some of the basic work, like one of things we have to do is split the statement up using the string split method. So when we split it, we use the constant that was defined on our MathProcessing interface called SEPARATOR, and that constant was a space, so we're still going to go ahead and split it based on a space. And then of course our keyword is the very first part of the statement. So in this case, that might be something like the add keyword. So now what we need to do is loop through the handlers to find the handler that knows how to handle add. So what I'll do is first of all I'll declare a local variable called theHandler of type MathProcessing, and then what I want to do now is loop through that array of handlers to try to find a handler that knows how to handle the keyword that was in the statement. So what I'll do down here is I'll create a for loop. Let me just scroll down a little bit so we can see everything a little better. So again, we'll have that for loop that will go through the handlers. So inside of there let's add an if statement. We'll say our keyword, we'll use equalsIgnoreCase, and what do we want to do? We want to take the current handler that we're looping through, and we'll call it getKeyword method. In other words, does the keyword in this statement match the keyword that this handler knows how to handle? If it does, we'll take the current handler and assign it or local variable, theHandler. And then we'll just go ahead and break out of the loop. Okay, so when we get out of this for statement now, we know that we have a handler that knows how to handle that particular keyword. Now we still have a little bit of housekeeping to do. We want to get our left values and right values and convert those into a double. So we'll use the same mechanism we used earlier in the course. So I'll declare a local variable called leftVal of type double. I'll then use the Double class's parseDouble method, and I'll do that for parts of 1. So that would be something like our 1.0 value. Right now we'll do the same thing for rightVal. So now we have both values. So what we can do is have a local variable we'll call result, and then it will call the handlers doCalculation method, and we simply pass in leftVal and rightVal. So when this returns, the result now has whatever the result of the calculation was. So what we want to do now is build that string output value, again, that ID of 1.0 + 2.0 = 3.0. Now the code to do that is going to be almost exactly the same as the code we used in CalculateHelper. So we're going to go over here to our CalculateHelper class, scroll down to its toString method. I'm going to grab the code here where it actually builds the output string. So let's copy that, go back to my DynamicHelper, paste that in. And of course I've got to make sure my variable names match. So instead of leftValue I have leftVal, RightValue is rightVal. But now the one for the symbol, like the plus sign, well, how am I going to get that? Well I'll go to the handler and I'll call its getSymbol method. So I'll get back whatever symbol is appropriate for this handler. So again, if we look at our Adder implementation, our keyword is add, our symbol is the plus sign, and doCalculation does the appropriate arithmetic. It adds them together. So, our DynamicHelper that we have here now is all set to go. So let's go back to our main program now and create our DynamicHelper. So we'll create a local variable here of type DynamicHelper, we call the variable helper, we go ahead and new up DynamicHelper, and we're going to pass in a new array of MathProcessing. And what we'll do is we'll just initialize the array in place, and what we do is put in the implementations we have for MathProcessing. Now currently the only one we have is Adder, so I'll just new up Adder. And so now we want to do is loop through each of the statements, passing them in to our helper. So we'll go through here, we'll declare a string to get our output, and then we simply say helper.process and we pass in our statement. So when that returns, the variable output should have whatever our helper produced. So let's go ahead and write out output. And so with that, we should have all the code in place that we need at this point to handle that one statement that does the add. The key thing here is that our DynamicHelper is doing all the work in terms of the MathProcessing interface. So let's go ahead and run our program and see if everything works as we expect. And it does. If I scroll down here, when we add 25.0 and 92.0, we get back 117.0. So everything worked just as we expected it to, but it did it in terms of the interface. So now in the next clip, let's see what it's like to add another handler into our DynamicHelper and see that we can get new processing capabilities without making any changes to our dynamic helper.

Dynamically Extending CalcEngine: New Functionality
Here we are back in our CalcEngine app, and remember we have our dynamic helper class that knows how to parse apart a statement, find a handler that knows how to deal with a keyword, ask the handler to do the operation, and then our dynamic helper can build the output. Now again we've done all this in terms of the interface, so we can actually extend the ability of a dynamic helper very easily. So let's imagine that we want to have another statement in here, something we've never done before. Maybe we want to support a statement that can actually raise values to a power. So we use the keyword power, and we want to say something like 5.0 2.0. In other words, we want to square the value 5.0, multiply 5.0 times itself. All right, so the result of that would be something like 5.0, let's say we use the caret for power of, 2.0 = 25.0. So we want to build a handler that can do that work. So what we'll do is we'll add a new class to our project called PowerOf, create the class, and I'm going to have it implement our MathProcessing interface. We'll go ahead and add all the methods, so all three of them. So now we want our PowerOf implementation here to do the work necessary to plug into our dynamic helper. We'll have the get keyword, we'll have the keyword that understands its power, the symbol that it returned is that caret, and then to do the actual work we'll use one of the built‑in math libraries called pow, p‑o‑w. Into pow we'll pass in our leftVal and our rightVal. So we now have a class, PowerOf, that knows how to raise values to a power and conform to our MathProcessing interface. So now to add that into our dynamic helper, all we have to do is go back to our Main, and here we new up the Adder. We're going to go ahead in that same array we passed in there, we'll now new up PowerOf. And that's all we do, create an instance of a class that implements the interface and then make dynamic helper aware of it. Now when we run this, we should see that both the add statement and the power statement get handled. And you see there that we do. The add statement adds the numbers together correctly, the power statement raises 5.0 to the power of 2, producing 25. You see, and that's where the power of interfaces really shine through, that ability to take a problem, abstractly model it in terms of its individual pieces, model the contract to fulfill those pieces as an interface, and then you can very easily just build implementations of the interface that focus on a very specific set of work. And then you can leverage allow that existing work that you've already done to get very powerful results with only a little bit of incremental work each time.

Summary
To wrap up, remember the key things you want to remember from this module is that an interface defines a contract. It does not provide any sort of implementation, it's simply the contract. That contract can consist of methods and constants. So the way interfaces are implemented are by classes, classes implement interfaces. And what that means is that any class that implements the interface conforms to the contract defined by the interface, and that allows us to have classes with very different features and capabilities, but then can conform at times when they need to to specific contracts. One of the key things is that whereas a class can only extend one class, a class is free to implement as many interfaces as it needs to, so it can conform to as many contracts as it needs to. And remember that interfaces can also extend one another, so you can define an interface that extends another interface. And remember that whenever you implement an interface that extends another interface, by implementing the extended interface, you implicitly implement the base interface.

Static Members, Nested Types, and Anonymous Classes
Introduction
Welcome to the final module of the Pluralsight Java Fundamentals course on the Java language. In this module, we're going to look at static members, nested types, and anonymous classes. My name is Jim Wilson. So as we go through this module, we're going to touch on a number of things. First of all, the idea of static members having static methods and fields, and then we'll look at something called static initialization blocks, the ability to do one‑time type initialization. Then we'll look at nested types, and then a very particular type of nested type called inner classes where we actually can have the nested class's instance automatically associated with an instance of its enclosing class. And then finally, we'll talk about anonymous classes, the ability to declare and create a class all at one time.

Static Members
In the classes we've been working with throughout the course, we've always been using what are called instance members where each class member is associated with a specific class instance. And that's what you normally want, but sometimes you want to be able to have a class member that's available class‑wide, and that's where static members come in. So a static member is a class member that's not associated with any individual instance. Now the way you declare static members is very similar to the way you declare instance members except you include the keyword static. So a static field is declared just like a regular field, except you put keyword static in front of it, similarly when declaring a static method. The thing is that when you create static members, because they're not associated with the individual instance, you can actually access them using the class name. So if you think about like a static field, so a static field would be a field whose value is not associated with any specific instance. So again, it's class wide. What that means is that each instance of the class will actually access the same value for that field. So a static method is usually a case where you have a method that wants to do some work that's not specific to any individual instance. Static methods can only access static fields, they can't access instance fields because, again, they're not associated with any individual instance. So let's take a look at using this in some code. So we've got our Flight class we've been using throughout the course, and we know that one of the things we've done is keep track of the number of passengers. So each flight can track how many people are on that one flight with the passengers field. We have this add1Passenger method that increments the count there. Now let's say what we want to do now is that in addition to each flight keeping track of how many passengers are on that flight, we'd like to have an easy way to keep track of how many passengers are on the total of all flights. And that's a great use for a static field. So what I'm going to do is add a field here called allPassengers. Again, I declare it just like an instance field, but I've actually marked it with static. That now means it's not associated with any instance. I'll add some methods to work with it. I'll have a method here, getAllPassengers, and I'll simply return back the value of allPassengers. So again, getAllPassengers is declared like any other method except it's marked as static. And I also want to have the ability to set the number of all passengers back to 0, so I have a method here called resetAllPassengers, which then just sets it to 0. So now let's use this in some code. So we'll go down here, and let's say first of all we want to just go ahead and reset all passengers. Now again, the key thing to understand in static members is that they are stored separate from any instance. So the storage area for all passengers is outside of any instance of the Flight class. So if I go out here and I say println Flight.getAllPassengers, getAllPassengers will get the current value of all passengers, which, of course is 0, and print that out. So now the question is is how do I change the value of all passengers? How do I increment that? Because I want to increment it each time I add a passenger. Well in our add1Passenger method, just below where we increment passengers by 1, we'll go ahead and just simply add 1 to all passengers. See, we're not really interacting with it any differently. What's going to change its behavior is the way its storage is managed. Let's say we have now our flight lax045. So we actually create an instance of the Flight class, it has its own memory, and again notice that that instance memory is separate from the allPassengers memory. So if I go up and I say lax045.add1Passenger, of course the passengers for the instance lax045 gets incremented by 1, as does allPassengers. All right, so if I call add1Passenger again on lax045, lax045 passengers increments by 1, as does allPassengers. But now let's create another instance. We have our slc015, of course it has its own memory associated with it. So when I call add1Passenger on slc015, passengers in slc015 increments by 1, going from 0 to 1, but allPassengers keeps its old value, so it now goes from 2 to 3. You see that allPassengers is continuing to count up even as we interact with it through different instances, and that's where the power of statics come in. So now if I go ahead and print out the value of getAllPassengers, I get 3. So I'm not doing any extra work to keep this total value across all instances. So by declaring it as static gave me that ability. Now as I mentioned, we can access static members by using the class name. But Java also has a shorthand for accessing static members called static import, and static import allows you to access static members without even using the class name. So it's really just kind of a shorthand mechanism. So if we take a look at our code here, again we're reusing the Flight class and we're calling into resetAllPassengers and getAllPassengers, well rather than have to always say flight. in front of it, we'd like to be able to just say resetAllPassengers or getAllPassengers. We'll use a static import to do that. So the first one was going to give us a little bit more room to work here. And so, it's an import statement, so we're going to use an import at the top. Remember, we used import earlier to actually be able to use shorthands for classes so we didn't have to package qualify them, now we're going to use the import for shorthands for static members so we don't have to qualify them. So we have the word import. In this case, we include the word static. So this is a static import. We then give it the package name, dot, the class name, which is our Flight class, and then we also include the member name, so resetAllPassengers. So now where we say Flight.resetAllPassengers, now that can simply become resetAllPassengers. The import statement allows us to use just a method name. So the same thing for our getAllPassengers. I can have an import, static, the package name, dot, the class name, is this case Flight, dot the method name. So in each case we now print out and call getAllPassengers, instead of saying Flight.getAllPassengers, we'll say getAllPassengers. Same thing in the other print statement. And so the static import just allowed us to type that more succinctly. In the next clip, we'll see some other uses and other behaviors of working with statics as we talk about static initializers.

Static Initialization Blocks
There are times in our applications where we need to do some kind of work to prepare a class before we use it, and that's where static initialization blocks come in. Static initialization blocks perform basically one‑time type initialization. And the neat thing about them is that they execute automatically before your types first use. Now remember, we've talked about initialization blocks earlier in the course, but those were instance initialization blocks. Remember that the instance initialization blocks automatically execute before any of your constructors. Well, static initialization blocks execute before you actually even start using the type. You can kind of think of those as type initializers. Now basically, there are statements enclosed in brackets outside of any method or constructor, but you have to mark it, of course, with the keyword static. Now, being static, they cannot access any instance members, they can only access static members, and because they're called automatically, you have to handle any checked exceptions within the initialization block. There's no concept of a throws keyword on here, you have to make sure you take care of everything within the initialization block itself. So let's see an example of using this in an application. Now let's imagine that we have a file listing crew members that are available to do some work. If you look at this, you'll notice that the first column is the person's job, things like a pilot or copilot, and each of these values corresponds to the enumeration we created earlier in the course, which is our flight crew jobs. And then after the job we have a comma and then the person's name. Now what we want to do with these values is we want to be able to in our code to be able to declare a variable, something like CrewMember, and we'll have a class that we'll call CrewManager where we can call a static method on it, FindAvailable, where we identify the job that we need to fill and the CrewManager.FindAvailable method will return back a crew member who can fill in that job that's not already assigned to another job. So let's look at our CrewManager class. Now the idea of FindAvailable is pretty simple, right? As we lay out our CrewManager class, of course we'll need to have a constant for the FILENAME we want to load from, we'll need to have the array of crew members that we'll call pool, and then we can go ahead and have our FindAvailable method. Again, it accepts the job as a parameter, and the implementation is pretty straightforward. Basically we'll have to have a variable to hold the matching crew member. I want to loop through that pool of crew members, and then inside there we basically just want to check, as long as there's a valid spot in the pool, if the job matches then we know we want that person, so we'll store reference to them from the pool, we'll remove them from the pool so we don't assign them to two different jobs, and then from there we break out and return back that crew member. The question is, though, is that how does pool get initialized from the file? Now we could go write another static method called initialize, or something like that, that loaded up the file contents, but in complex applications you can't always be sure kind of what order things are going to happen. It would be nice to be able to know that that pool field would automatically get loaded prior to our first use, and that's where static initialization blocks come in. So if we take a look at that, let's add a little bit more room here to add some code to our CrewManager class. And what we'll do then is that we'll add a static initialization block. Remember, that's just the brackets marked by the word static outside of any method, so we've got that there. And so what we want to do is read from the file, so we'll go ahead and create our reader. We'll need to, of course, have a variable to read a line from the file and an index to track our way through the array. We want to allocate some space in the array. And then from there, we just start reading through the file. So we read through the file, we go ahead and read the line and split it into its parts. Remember, the first part is a string representing the job, the second part is their name. We then went a map that string into our FlightCrewJob enumeration. Now remember that earlier in the course we talked about mapping strings to enumeration values, and we did it with a series of explicit if statements, and that gave us a lot of flexibility because we were actually completely independent of string case or anything like that. If we have a scenario where we know that the string value coming in matches the case and capitalization of our enumeration values, we can use the enumeration's valueOf method. So, for example, Pilot is always capital P in our enumeration. So if we know our string is coming in with a Pilot, capital P, we can use valueOf. CoPilot is capital C, capital P. So as long as the strings match that capitalization, rather than reading that explicit if, we can use this valueOf method. So I'll go ahead and map that into a job from the string value that's in the file. So we'll go ahead and create an instance of CrewMember based on that job, put them in the array, set their name from the value inside the file, and then increment our index through the array. So that takes care of actually reading in the contents. But remember though that, we talked about this earlier, that when we interact with a file, there are I/O exceptions that can occur. That's a checked exception. Inside of our static initialization blocks, we have to handle all checked exceptions. So we want to make sure that we go ahead and wrap this up in a try catch that handles that I/O exception. So with this, our CrewManager class is all set to go. And the magic here is that that stack initialization block is automatically called for us prior to the first use. So what we can do then is when we're ready to use this class, whenever we call the CrewManager class for the very first time, our FindAvailable, the system will automatically run that code that's inside of the second initialization block and load up the array for us. Each time after that that we use it, the array is already loaded, so we can go ahead and find the next person who matches a job and the next person. So the static initialization block is a really powerful capability that takes care of initializing our classes prior to their first use with no special calls on the part of the user.

Nested Types
At a few points during the course, we've mentioned nested types briefly, and I've always said that's something we would talk about later. Well, later is now. Now a nested type is simply a case where you have a type that's declared within another type. So you can have classes that are declared within the other classes or within an interface, you can also have interfaces that are declared within classes or a different interface. When you nest one type inside of another, the nested type is actually a member of its enclosing type. So what that means is that the nested type actually has visibility of private members of its enclosing type. Also as a member, it can have all the member access modifiers. So, a nested class can, of course, be public or a package private just as a top level class, but you can also have a nested class that is protected, meaning that it would only be accessible by classes that inherit from its enclosing class. Or it can even be private so you can have a class that's only visible to the class in which it's contained. When we work with nested types, there's generally two ways we work with them. In one case we're really using them for structure and scoping, and in this case there's no special relationship between instances of the nested class and instances of the enclosing class. It's really because you want to make the type only usable in certain scenarios or you want to structure its naming relative to another class. So this happens when you have what's called a static nested class, or if you put a class inside of an interface, or if you have a nested interface. To see what this looks like, remember we have our Passenger class here, and one of things we did with passengers is we had a rewards program. Now the rewards program relied on two values, what the person's level was in the rewards program and how long they'd been a member of the program. And this is a case where it takes two values to represent a single concept, and oftentimes when we have that scenario, we go ahead and wrap that up in a class. So we could go off and create a RewardsProgram class. But this is a rewards program as it applies to a passenger. What if we had a different rewards program as it applied to crew members. Well, we could start naming one, like PassengerRewardsProgram, another one CrewMemberRewardsProgram, or we could have a RewardProgram class that we nest inside of passenger. So let's go ahead and do that. So we'll wrap those two values inside of our RewardProgram class. So RewardProgram is the nested class, Passenger is the enclosing class. RewardProgram is marked as static, which means, again, we're using it for structure and scoping. As a class, it can do all the things classes are allowed to do. So it could have methods inside of it. So we have a getter and a setter for memberLevel and a getter and setter for memberDays. Now all we've done at this point is declared the RewardProgram class. There's no instance of it yet, so what we're going to do inside our Passenger class, we'll add a field, we'll type RewardProgram that we'll call rewardProgram. Now, it's still a reference type, so we need to go ahead and new it up, so we'll new up an instance of it. Now we've marked RewardProgram as private in terms of the field, but notice our RewardProgram class is public. So, you can't access the field directly, so we'll go ahead and put a getter around that as well. Okay, so now we have our RewardProgram class that's nested inside of our Passenger class. Let's see how this affects our code when we use it. So let's go over here, and we'll go ahead and create an instance of a passenger, we'll call him Steve. If we want to go ahead and set up his reward program information, it's just like working with any other field that's based on a class. We have our Steve variable, we call getReward Program to actually get a reference to his reward program information, and then we just call methods on it. So we can set his level to 3, and we'll go ahead and set his memberDays to 180. So really, there is nothing different there. But now, remember we said that we declared RewardProgram as a public nested class, so it's usable outside of the Passenger class. So we can actually create variables and instances of that reward program outside of the Passenger class. So let's go ahead and create a variable here called platinum, but you notice the name of the class. The class's name is Passenger.RewardProgram, right, the enclosing class, dot, the nested class. And when we new it up, we use the class name, so we go ahead and new up an instance of Passenger.RewardProgram. So you see how we've got a structured name here so that the reward program name is qualified by the Passenger class. If we had a different reward program for crew members, we can nest that inside of the CrewMember class, then its name would be qualified by the CrewMember class. So we can go ahead and use this platinum variable, so we'll go ahead and set the level to 3. So we're saying now this variable platinum represents a reward program at the platinum level. So we can use all this stuff just as we do any other bit of our code. So I want to do a test. I can say, hey, Steve, get the reward program. What's its level? Well, if its level equals the level in platinum, then we know that Steve is platinum. So again, this is a case of using nested classes as a mechanism for providing structure and scoping. RewardProgram is a nested class that's marked as static, so its name was scoped within the Passenger class. In the next clip, we'll see how things differ if we nest the class and do not mark it as static.

Inner Classes
As we saw in the last clip, nesting one class inside of another, or one type inside of another, provides scoping where we can limit who can access the type, and structure. We could even kind of create the name of one class to be structured inside of another. But that's just the beginning of what nested types can do. We can get a much closer relationship when we nest one class inside of another. There's a concept called inner classes. And with inner classes, you actually have a class who each instance of which is associated with an instance of its enclosing class. So there's this kind of implicit relationship between instances. This occurs anytime you nest one class inside of another and don't mark the nested class as static. To see how this works, let's take a look at our Flight class again. So remember that our Flight class implements the iterable interface. So its method iterator returned back an instance of this class called FlightIterator that we created. And if we look at FlightIterator, it has kind of one job, right, walking through that list of crew and roster. The hasNext and next methods are needed, of course, because they're part of the iterator interface, and of course we need the index field to keep track of our location. But the constructor that we have there and the crew and roster fields, those exist just to kind of duplicate content that's already inside of the Flight class. Using inner classes, we can actually simplify our FlightIterator by taking advantage of the implicit relationships that can occur between the classes. So let's take our FlightIterator class and we'll move it inside of our Flight class here. A couple things to note here. The FlightIterator class is marked as private, which means that the type can't be seen outside of the Flight class itself. Also, the class is not marked as static. That's what makes it an inner class. It's a nested class inside of another class, the nested class is not marked as static. So of course we'll need our index field to keep track of our location, but then we'll implement our hasNext method. So, of course, inside of here, we're going to check with the indexes. So we have our index and we can actually compare the index to crew and roster, even though crew and roster are not declared inside of FlightIterator, they're part of Flight. All right, similarly, we have our next method. We can, of course, use the index to get to the right member of crew or roster, and of course return that back. With this, our FlightIterator class is nested inside of the Flight class and can replace that separate FlightIterator class. And so when we actually inside of the iterator method, when we create FlightIterator, we don't have to pass in any parameters, we just create that nested FlightIterator itself. So why does this work? Well, as a nested class, the FlightIterator actually has two this references. It has the traditional this reference, the ability to access its own members, but it also has a Flight.this reference, which allows it to access the members of the instance of flight in which it was created. And that, again, is this power of inner classes. By simply declaring FlightIterator as a class that's nested inside of another class and not marking it as static, each time we create an instance of FlightIterator, that FlightIterator instance is automatically associated with the instance of the Flight class in which it was created.

Anonymous Classes
Java provides the ability to create anonymous classes. With anonymous classes, rather than use the class keyword to go ahead and give a class a name, to give its declaration, then later go off and create it, with anonymous classes we're able to declare our class as part of the class's creation. And what they're useful for are cases where you want to implement an interface or extend a particular class, generally to provide some specific solution, something you're not generally going to use throughout your application, but to solve a particular problem. Now anonymous classes are inner classes, so that means that your anonymous classes have access to the instance members of the enclosing class. We create an anonymous class as if we're constructing an instance of the interface or base class that we want to extend. But what we do then as part of that creation process is we go ahead and follow it with the opening and closing brackets and then provide our class implementation right there where we're creating it. Now to see how this works, let's take a look at our Flight class again. And again, we're going to look at our iterable implementation. Now in our last clip, we actually used an inner class to provide the iterator implementation. So we have that FlightIterator class, and then inside of our Iterator method, we actually go ahead and create an instance of that class. Well, that FlightIterator class is not used anywhere else in our program except within this one method, Iterator. So this is actually a great chance for us to use an anonymous class to kind of further make our code a little bit more concise. So what we're going to do is go ahead and take the FlightIterator out of my code here. So I'm going to get rid of the declaration, as well as the creation of it. So now here inside of our Iterator method, we're going to go ahead and move that closing bracket down so we have a little bit more room, and we're going to start out very similar to what we did before. We're going to go ahead and have a return statement and call new because we're about to create a class, but normally we would follow new with an existing class we've already declared we want to create. But in this case, we're going to go ahead and put the interface name there. You notice that the interface name has the opening/closing parens there because we're calling a constructor. Now because we're implementing an interface, the only constructor we can call is the no argument constructor. But if we were extending a base class, we could use any constructor provided by that base class. But here, rather than just end the statement, we're going to go ahead and put in our opening and closing brackets, and it's inside of these brackets are where we're going to go ahead and implement our class. So basically we've done this iterator several times now so we know that we need to have a field for the index to keep track of our location. We'll go ahead and provide our hasNext method. Now in our hasNext, we're going to check our index location, so we're using the field inside of our anonymous class, and we're going to check that against the combined length of the crew and roster. Remember again that our anonymous class is an inner class, so it has access to the members of the containing class, because again, this instance is associated with the instance of our enclosing class, Flight. And then we'll go ahead as well and implement our next method, just as we did previously. And that's it. We now have our anonymous class, so we're actually implementing our iterator interface right here as part of the creation. So anonymous classes allow us to avoid the need to go off and declare these bunch of classes and give them names that we're only using in one place. Instead, right here where we need it, we take care of the entire job of declaring the class and creating it.

Summary
To wrap up, here are the key things you'll want to remember. Remember that static methods and fields are shared class wide. You can access them using the class name, and they're not associated with any individual instance of your class. Static initialization blocks allow you to provide one‑time type initialization, and it allows you to have a block of code that's automatically run before the first time you use that type. A nested type is a type declared within another type. Now they can be used to provide just structure and scoping, and that's true if you have a class that's marked as static or any time we're using interfaces with nesting, or you can use inner classes. Inner classes occur when you have one class inside of another, and that nested class is not marked as static. In that case, whenever you create an instance of the nested class, that instance is automatically associated with the instance of the enclosing class from which it was created, so you get a lot of power with that automatic association. And then we have novice classes that are actually declared as part of their creation. Remember that anonymous classes are considered inner classes, so they can actually access the members of the enclosing type, and they're useful for those situations where you want to implement some interface or you want to go ahead and extend a class for a very specific situation. So you don't need to go off and declare a class explicitly, just go ahead and create it right there in place when you need it. And that brings us to the end of our course, Java Fundamentals: The Java Language. Whether you plan to go off and work on servers, clients, or devices, you're now armed with the knowledge of the Java language that you need to start building your killer app. To continue developing your Java skills, I encourage you take a look at the Pluralsight Skill Path for Java. It contains a great progression of courses that will build your skills as a Java developer. In fact, there's a good chance you arrived at this course from the Java Skill Path. If you haven't already checked out the Java Skill Path, I encourage you to go over and take a look at the courses contained there. And finally, thank you for joining me throughout our discussion of the Java language. I wish you the very best as you begin applying your new Java language skills and as you continue learning and developing your skills as a Java developer.